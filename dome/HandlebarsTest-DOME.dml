<?xml version="1.0" encoding="UTF-8"?>

<model type="DomeModel" id="e903010b-dffa-1004-8ab4-1037084ba065" name="Test">
    <modelinfo>
        <version>0.0.3</version>
    </modelinfo>
    <parameters>
        <parameter id="2de11cfb-dff9-1004-8053-4b6b5190a41e" name="InputStage">
            <currentType value="Integer"/>
            <data>
                <dataobject type="Integer">
                    <quantity magnitude="0" unit="No_Unit"/>
                </dataobject>
            </data>
        </parameter>
        <parameter id="2de11cff-dff9-1004-8053-4b6b5190a41e" name="OutputStage">
            <currentType value="Integer"/>
            <data>
                <dataobject type="Integer">
                    <quantity magnitude="0" unit="No_Unit"/>
                </dataobject>
            </data>
        </parameter>
        <parameter id="ed2f8a8a-dffc-1004-896f-4e4d575adaac" name="pageBase">
            <currentType value="String"/>
            <data>
                <dataobject type="String">&lt;div&gt;&lt;style&gt;{{pageStyle}}&lt;/style&gt;&lt;div id="theBody"&gt;{{pageMain}}&lt;/div&gt;&lt;script src="https:&lt;script&gt;{{pageScript}}&lt;/script&gt;&lt;/div&gt;</dataobject>
            </data>
        </parameter>
        <parameter id="ed2f8a8d-dffc-1004-896f-4e4d575adaac" name="pageMain">
            <currentType value="String"/>
            <data>
                <dataobject type="String"></dataobject>
            </data>
        </parameter>
        <parameter id="ed2f8a90-dffc-1004-896f-4e4d575adaac" name="pageUnit">
            <currentType value="String"/>
            <data>
                <dataobject type="String"></dataobject>
            </data>
        </parameter>
        <parameter id="ed2f8a97-dffc-1004-896f-4e4d575adaac" name="outputTemplate">
            <currentType value="String"/>
            <data>
                <dataobject type="String">&lt;div&gt;&lt;style&gt;{{pageStyle}}&lt;/style&gt;&lt;div id="theBody"&gt;{{pageMain}}&lt;/div&gt;&lt;script src="https:&lt;script&gt;{{pageScript}}&lt;/script&gt;&lt;/div&gt;</dataobject>
            </data>
        </parameter>
        <parameter id="e05ae006-e002-1004-8b78-46d8a5cbbeea" name="pageStyle">
            <currentType value="String"/>
            <data>
                <dataobject type="String"></dataobject>
            </data>
        </parameter>
        <parameter id="e05ae009-e002-1004-8b78-46d8a5cbbeea" name="pageScript">
            <currentType value="String"/>
            <data>
                <dataobject type="String"></dataobject>
            </data>
        </parameter>
        <parameter id="5041d540-e007-1004-88d8-84730f2d9e5d" name="jsstl">
            <currentType value="String"/>
            <data>
                <dataobject type="String">/**** Converts a given block of binary stl data (as an arraybuffer) to a threeJS representation* of the geometry. Function courtesy of 'tonylukasavage' from Github, who released this to* the public domain. ** @method parseStlBinary* @for renderGlobal* @param {Arraybuffer} stl The binary stl data* @return {Object} threeJS geometry object* */var parseStlBinary = function(stl) {var geo = new THREE.Geometry();var dv = new DataView(stl, 80); var isLittleEndian = true;var triangles = dv.getUint32(0, isLittleEndian); var offset = 4;for (var i = 0; i &lt; triangles; i++) {var normal = new THREE.Vector3(dv.getFloat32(offset, isLittleEndian),dv.getFloat32(offset+4, isLittleEndian),dv.getFloat32(offset+8, isLittleEndian));offset += 12;for (var j = 0; j &lt; 3; j++) {geo.vertices.push(new THREE.Vector3(dv.getFloat32(offset, isLittleEndian),dv.getFloat32(offset+4, isLittleEndian),dv.getFloat32(offset+8, isLittleEndian)));offset += 12}offset += 2; geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));}geo.computeFaceNormals();return geo;}; /**** Processes a given string to make it parsible for parseStl and returns* the results** @method trim* @for renderGlobal* @param {String} str ASCII STL data* @return {String} processed string* */function trim (str) {str = str.replace(/^\s+/, '');for (var i = str.length - 1; i &gt;= 0; i--) {if (/\S/.test(str.charAt(i))) {str = str.substring(0, i + 1);break;}}return str;}/**** Converts an arraybuffer into a string of equivalent binary content* @method arrayToString* @for renderGlobal* @param {Arraybuffer} buf The arraybuffer* @return {String} * */function arrayToString(buf) {var pos=0;var arr=new Uint8Array(buf);var lim=arr.length;var result="";while(pos&lt;lim){result=result+String.fromCharCode(arr[pos]);pos++;}return result;}/**** Converts a given block of ASCII stl data (as an arraybuffer) to a threeJS representation* of the geometry. Function courtesy of 'tonylukasavage' from Github, who released this to* the public domain. ** @method parseStl* @for renderGlobal* @param {Arraybuffer} stl The ASCII stl data* @return {Object} threeJS geometry object* */var parseStl = function(stl) {var state = '';stl=arrayToString(stl);var lines = stl.split('\n');var geo = new THREE.Geometry();var name, parts, line, normal, done, vertices = [];var vCount = 0;stl = null;for (var len = lines.length, i = 0; i &lt; len; i++) {if (done) {break;}line = trim(lines[i]);parts = line.split(' ');switch (state) {case '':if (parts[0] !== 'solid') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "solid"');return null;} else {name = parts[1];state = 'solid';}break;case 'solid':if (parts[0] !== 'facet' || parts[1] !== 'normal') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "facet normal"');return null;} else {normal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];state = 'facet normal';}break;case 'facet normal':if (parts[0] !== 'outer' || parts[1] !== 'loop') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "outer loop"');return null;} else {state = 'vertex';}break;case 'vertex': if (parts[0] === 'vertex') {geo.vertices.push(new THREE.Vector3(parseFloat(parts[1]),parseFloat(parts[2]),parseFloat(parts[3])));} else if (parts[0] === 'endloop') {geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );vCount++;state = 'endloop';} else {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');return null;}break;case 'endloop':if (parts[0] !== 'endfacet') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "endfacet"');return null;} else {state = 'endfacet';}break;case 'endfacet':if (parts[0] === 'endsolid') {return geo;done = true;} else if (parts[0] === 'facet' &amp;&amp; parts[1] === 'normal') {normal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];if (vCount % 1000 === 0) {}state = 'facet normal';} else {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');return null;}break;default:console.error('Invalid state "' + state + '"');break;}}};</dataobject>
            </data>
        </parameter>
        <parameter id="5041d543-e007-1004-88d8-84730f2d9e5d" name="treequence">
            <currentType value="String"/>
            <data>
                <dataobject type="String">;/**** Given a jQuery object, returns a full list of all of its children.** @method whatsIn* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose children should be returned* @return {Array} Array of the object's children* */function whatsIn(theTree){return document.getElementById("warning").innerHTML=$(theTree).children("*");}/**** Given a jQuery object and a string, returns the first child of the given element with* a tag equivalent to the given string.** @method grab* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose child is to be returned* @param {String} theMember The name of the tag being searched* @return {jQuery Object} The first child with the given tag. If such a child does not * exist, null is returned.* */function grab(theTree,theMember){if($(theTree).children(theMember).length!=0){return $(theTree).children(theMember)[0];}else{return null;}}/**** Given a jQuery object and an integer "N", returns the Nth child of the given element with* the given tag. ** @method grabInd* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose child is to be returned* @param {String} theMember The name of the tag being searched* @param {String} theIndex The ordinal of the matching child to be returned* @return {jQuery Object} The child meeting the tag and ordinal requirement. * If such a child does not exist, null is returned.* */function grabInd(theTree,theMember, theIndex){if($(theTree).children(theMember).length&gt;theIndex){return $(theTree).children(theMember)[theIndex];}else{return null;}}/**** Given a jQuery object derived from parsing an XML document, extracts all information* relevant to part movement and composes it into an identically structured tree of * nested javascript objects which is then returned** @method getMovement* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @param {Float} myX The X position of the subassembly represented by the root node of theTree* @param {Float} myY The Y position of the subassembly represented by the root node of theTree* @param {Float} myZ The Z position of the subassembly represented by the root node of theTree* @param {Float} myTime The time value of the subassembly represented by the root node of theTree* @return {Object} The root node of the tree of extracted movement data * */function getMovement(theTree, myX, myY, myZ, myTime){if(($(theTree).children("Install").length==0)){return { Name: $(theTree).attr("Name"), X: myX, Y: myY, Z: myZ, Time: myTime, Ref: null, Mov: null, Fst: [] };}else{var childTime=parseFloat(grab(grab(theTree,"Install"),"Time").innerHTML)+myTime;var movDirection=grab(grab(theTree,"Install"),"InstallDirection");var movXDir=parseFloat(grabInd(movDirection,"double",0).innerHTML);var movYDir=parseFloat(grabInd(movDirection,"double",1).innerHTML);var movZDir=parseFloat(grabInd(movDirection,"double",2).innerHTML);var movDistance=parseFloat(grab(grab(theTree,"Install"),"InstallDistance").innerHTML);movDistance = Math.min(movDistance,800);var movX=myX-movXDir*movDistance;var movY=myY-movYDir*movDistance;var movZ=myZ-movZDir*movDistance;var ref=getMovement(getRef(theTree), myX, myY, myZ, childTime);var mov=getMovement(getMov(theTree), movX, movY, movZ, childTime);var fasteners = $(theTree).children("Secure");var theFst;var theDir;var theDist;var Fst = [];if(fasteners.length &gt;= 1){fasteners = $(fasteners[0]).children("Fasteners");if(fasteners.length &gt;= 1){fasteners = $(fasteners[0]).children("Fastener");var pos = 0;var lim = fasteners.length;while(pos&lt;lim){theDist = parseFloat($(fasteners[pos]).children("InstallDistance")[0].innerHTML);theDir = ($(fasteners[pos]).children("InstallDirection"))[0];theDir = $(theDir).children("double");theFst = { Name: "subasm-"+($(fasteners[pos]).children("Name"))[0].innerHTML, X: myX-parseFloat(theDir[0].innerHTML)*theDist, Y: myY-parseFloat(theDir[1].innerHTML)*theDist, Z: myZ-parseFloat(theDir[2].innerHTML)*theDist, Time: childTime, Ref: null, Mov: null,Fst: []};Fst.push(theFst);pos++;}}}return { Name: "", X: myX, Y: myY, Z: myZ, Time: myTime, Ref: ref, Mov: mov, Fst: Fst};}}/**** Given a jQuery Object, will return the first child with the tag "Reference" of the first child with* the tag "Install" of the object. If no such child exists, null is returned. ** @method getRef* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be accessed* @return {jQuery Object} The resulting child* */function getRef(theTree){theTree=grab(theTree,"Install");theTree=grab(theTree,"Reference");return theTree;}/**** Given a jQuery Object, will return the first child with the tag "Moving" of the first child with* the tag "Install" of the object. If no such child exists, null is returned. ** @method getMov* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be accessed* @return {jQuery Object} The resulting child* */function getMov(theTree){theTree=grab(theTree,"Install");theTree=grab(theTree,"Moving");return theTree;}/**** Given a jQuery object derived from parsing an XML document, extracts all information* relevant to installation timing and composes it into an identically structured tree of * nested javascript objects which is then returned** @method getTimes* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @param {Float} parentTime The time value of the subassembly represented by the root node of theTree* @return {Object} The root node of the tree of extracted time data * */function getTimes(theTree, parentTime){if(($(theTree).children("Install").length==0)){return { Time: parentTime, Ref: null, Mov: null };}else{var myTime=parseFloat(grab(grab(theTree,"Install"),"Time").innerHTML)+parentTime;var ref=getTimes(getRef(theTree),myTime);var mov=getTimes(getMov(theTree),myTime);return { Time: parentTime, Ref: ref, Mov: mov};}}/**** Given a tree of nested objects, returns the highest "Time" value from all the nodes** @method getLongestTime* @for renderGlobal* @param {Object} timeTree The tree of time values* @return {Object} The highest time value in the tree* */function getLongestTime(timeTree){if(timeTree==null){return 0;}return Math.max(getLongestTime(timeTree.Ref),getLongestTime(timeTree.Mov),timeTree.Time);}/**** Given a jQuery object derived from parsing an XML document, extracts all part name * information and composes it into an identically structured tree of nested javascript* objects which is then returned** @method getNames* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @return {Object} The root node of the tree of extracted name data * */function getNames(theTree){if(($(theTree).children("Install").length==0)){return {Name: $(theTree).attr("Name"), Ref: null, Mov: null};}else{var ref = getNames(getRef(theTree));var mov = getNames(getMov(theTree));return {Name: "", Ref: ref, Mov: mov};}}/**** Given a three trees of nested javascript objects, one holding time data, one holding* movement data, and one holding part name data** @method mergeTrees* @for renderGlobal* @param {Object} TimeTree The root node of the tree containing time data* @param {Object} SpaceTree The root node of the tree containing movement data* @param {Object} NameTree The root node of the tree containing name data* @return {Object} The root node of the resulting tree* */function mergeTrees(TimeTree,SpaceTree,NameTree){if(TimeTree==null || SpaceTree==null || NameTree==null){return null;}else{var ref=mergeTrees(TimeTree.Ref,SpaceTree.Ref,NameTree.Ref);var mov=mergeTrees(TimeTree.Mov,SpaceTree.Mov,NameTree.Mov);return {Time: TimeTree.Time, Space: SpaceTree.Space, Name: NameTree.Name, Ref: ref, Mov: mov};}}/**** Given a three trees of nested javascript objects, one holding time data, one holding* movement data, and one holding part name data** @method getNameList* @for renderGlobal* @param {Object} TimeTree The root node of the tree containing time data* @param {Object} SpaceTree The root node of the tree containing movement data* @param {Object} NameTree The root node of the tree containing name data* @return {Object} The root node of the resulting tree* */function getNameList(theTree){if(theTree==null){return [];}else{var result;if(theTree.Name===""){result=[];}else{result=[theTree.Name];}result=result.concat(getNameList(theTree.Ref));result=result.concat(getNameList(theTree.Mov));return result;}}/**** Given an array of strings, returns the first index at which at least * two of the included strings are different** @method similarityCutoff* @for renderGlobal* @param {Array} theList The list of strings to be anylized* @return {Index} The computed index* */function similarityCutoff(theList){var pos;var it=1;var lim=theList[0].length;var finish=theList.length;while(it&lt;finish &amp;&amp; lim!=0){pos=0;while(pos&lt;lim){if(theList[it][pos]!=theList[0][pos]){lim=pos;}pos=pos+1;}it=it+1;}return lim;}/**** Given a tree of nested javascript objects (each with a string attribute "Name") and an* integer "N", removes the first N characters of each Name attribute** @method cutOffNames* @for renderGlobal* @param {Object} theTree The structure containing name data* @return {Void}* */function cutOffNames(theTree,theCutOff){if(theTree==null){return;}else{if(theCutOff&lt;theTree.Name.length){theTree.Name=theTree.Name.substr(theCutOff,theTree.Name.length);}cutOffNames(theTree.Ref,theCutOff);cutOffNames(theTree.Mov,theCutOff);var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){cutOffNames(theTree.Fst[pos],theCutOff)pos++;}return;}}/**** Given a tree of nested javascript objects (each with a string attribute "Name"), and two lists,* regTreeNames and fstTreeNames, inserts all regular part names into regTreeNames and inserts all* fastener part names into fstTreeNames** @method getTreeNames* @for renderGlobal* @param {Object} tree* @param {String List} regTreeNames* @param {String List} fstTreeNames* @return {Void}* */function getTreeNames(tree,regTreeNames,fstTreeNames){if(tree===null){return;}else{if(tree.Ref===null){regTreeNames.push(tree.Name);}else{getTreeNames(tree.Ref,regTreeNames,fstTreeNames);getTreeNames(tree.Mov,regTreeNames,fstTreeNames);}var pos = 0;var lim = tree.Fst.length;while(pos&lt;lim){fstTreeNames.push(tree.Fst[pos].Name);pos++;}}}/**** Given a list of parts, returns a list of the names of each part** @method getPartNames* @for renderGlobal* @param {Part List} parts The list of part objects.* @return {String List}* */function getPartNames(parts){var result = [];var pos = 0;var lim = parts.length;while(pos&lt;lim){result.push(parts[pos].Name);pos++;}return result;}/**** Given a tree of nested javascript objects (each with a float attribute "Time") and a* float "N", sets each Time value to N minus that value** @method flipTreeTime* @for renderGlobal* @param {Object} theTree The structure containing time data* @param {Float} axis The value used to mirror the time values* @return {Void}* */function flipTreeTime(theTree,axis){if(theTree==null){return;}else{theTree.Time=axis-theTree.Time;flipTreeTime(theTree.Ref,axis);flipTreeTime(theTree.Mov,axis);var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){flipTreeTime(theTree.Fst[pos],axis);pos++;}return;}}/**** Given a tree of nested javascript objects, returns the depth of the tree** @method getDepth* @for renderGlobal* @param {Object} theTree The object structure* @return {Int} The depth of the object* */function getDepth(theTree){if(theTree==null){return 0;}return 1+Math.max(getDepth(theTree.Ref, theTree.Mov));}/**** Given a staggered array of integer pairs, returns a random UTF character with a UTF value* within one of the given integer ranges (inclusive)** @method getRandomUTF* @for renderGlobal* @param {Array} selectSpace A staggered array of integer range limits* @return {Void}* */function getRandomUTF (selectSpace){if(selectSpace.length%2==1 || selectSpace.length==0){return '?';}var pos=0;var lim=selectSpace.length/2;var spaceSize=0;while(pos&lt;lim){spaceSize=spaceSize+selectSpace[pos+1]-selectSpace[pos];pos=pos+2;}var sel=Math.random() * (spaceSize);pos=0;while(sel&gt;(selectSpace[pos+1]-selectSpace[pos])){sel=sel-(selectSpace[pos+1]-selectSpace[pos]);pos=pos+2;}var result= String.fromCharCode(selectSpace[pos] + Math.random() * (selectSpace[pos+1]-selectSpace[pos]+1));return result;}/**** Given a tree of nested javascript objects and an html element, inserts the contents* of the root node of the given tree as an html element into the given element. Returns* the name of the generated node.** @method insertTreequenceHTML* @for renderGlobal* @param {Object} theTree The tree structure* @param {HTML Element} parentElement The html element to contain the node information* @return {Void}* */function insertTreequenceHTML(theTree,parentElement){if(theTree==null){return "";}var theButton=document.createElement("BUTTON");var theName="";theButton.innerHTML="-";theButton.setAttribute("onclick","swapHiding(parentElement)");theButton.setAttribute("style","background-color: #000000;\border: none;\color: white;\padding: 2px 4px 2px 4px;\text-align: center;\text-decoration: none;\display: inline-block;\font-size: 100% ;")if(theTree.Ref!=null || theTree.Mov!=null){parentElement.appendChild(theButton);}else{theName=getRandomUTF([ /*0x03B0,0x03FF,0x0531,0x0556,0x07C0,0x07EA,0x10A0,0x10C5,0x16A0,0x16EA,0x1A00,0x1A16,0x1B83,0x1BA0,0x20A0,0x20BE,0x2C00,0x2C2E,0xA500,0xA62B*/0x2600,0x2625,0x2639,0x2668,0x2690,0x269D,0x26B3,0x23BE/*0x1F300,0x1F3FA,0x1F400,0x1F4FF,0x1F600,0x1F64F,0x1F910,0x1F91E,0x1F920,0x1F927,0x1F950,0x1F95E,0x1F980,0x1F991*/]);parentElement.appendChild(document.createTextNode(theTree.Name.substring(0,theTree.Name.length-4)+"("+theName+")"));}var movName;var refName;if(theTree.Mov!=null){var theMov=document.createElement("DIV");parentElement.appendChild(theMov);movName=insertTreequenceHTML(theTree.Mov,theMov);}if(theTree.Ref!=null){var theRef=document.createElement("DIV");parentElement.appendChild(theRef);refName=insertTreequenceHTML(theTree.Ref,theRef);}if(theTree.Ref!=null || theTree.Mov!=null){theName=movName+refName;parentElement.insertBefore(document.createTextNode(" "+theName),theMov);}hideChildren(parentElement);return theName;}/**** Given an html node containing a button, hides all child treequence elements* if the button text is not "+" and shows them if it is.** @method swapHiding* @for renderGlobal* @param {HTML Element} theNode The html element whose treequence elements are to be manipulated.* @return {Void}* */function swapHiding(theNode){var buttonState=getChildrenByTag(theNode,"BUTTON");if(buttonState==null || buttonState.length&lt;1){return;}var theButton=buttonState[0];if(theButton.innerHTML=="+"){theButton.innerHTML="-";showChildren(theNode);}else{theButton.innerHTML="+";hideChildren(theNode);}}/**** Given an HTML element, sets the style attributes of that element to display it's contents.** @method show* @for renderGlobal* @param {HTML Element} theNode The HTML element to be shown.* @return {Void}* */function show(theNode){var theText=getChildrenByTag(theNode,"TEXT");theNode.setAttribute("style","display: block; position: relative; left: 15px; border-style: solid; border-color: #000000;");}/**** Given an HTML element, sets the style attributes of that element to hide it's contents.** @method hide* @for renderGlobal* @param {HTML Element} theNode The HTML element to be hidden.* @return {Void}* */function hide(theNode){var theText=getChildrenByTag(theNode,"TEXT");/*if(!(theText==null || theText.length&lt;1)){console.log("Hiding: "+theText[0].innerHTML);}*/var buttonState=getChildrenByTag(theNode,"BUTTON");if(!(buttonState==null || buttonState.length&lt;1)){buttonState[0].innerHTML='+';}theNode.setAttribute("style","display: none;");}/**** Given an HTML element, sets the style attributes of that element's children* to display their contents.** @method showChildren* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be shown.* @return {Void}* */function showChildren(theNode){var theChildren = getChildrenByTag(theNode,"DIV");var pos=0;var lim=theChildren.length;while(pos&lt;lim){show(theChildren[pos]);hideChildren(theChildren[pos]);pos++;}}/**** Given an HTML element, sets the style attributes of that element's children* to hide their contents.** @method hideChildren* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be hidden.* @return {Void}* */function hideChildren(theNode){theNode.setAttribute("style","display: block; position: relative; left: 15px; border-left: solid #000000; padding: 10px 5px 0px 5px;");var theChildren = getChildrenByTag(theNode,"DIV");var pos=0;var lim=theChildren.length;while(pos&lt;lim){hideChildren(theChildren[pos]);hide(theChildren[pos]);pos++;}}/**** Given an HTML element and a string, returns a list containing all child elements* of the given element with a tag equivalent to the given string** @method getChildrenByTag* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be searched* @param {String} tag The string to be used when searching for element children* @return {Void}* */function getChildrenByTag(theNode,tag){var childs=theNode.children;var pos=0;var lim=childs.length;var result=[];while(pos&lt;lim){if(childs[pos].tagName===tag){result.push(childs[pos]);}pos++;}return result;}</dataobject>
            </data>
        </parameter>
        <parameter id="5041d546-e007-1004-88d8-84730f2d9e5d" name="partRender">
            <currentType value="String"/>
            <data>
                <dataobject type="String">;/**** Returns a normal material for meshes if the global variable "standard" is false. If "standard"* is set to true, returns a chromadepth material instead.** @method getStdMaterial* @for renderGlobal* @return {Object}* */function getStdMaterial(){if(standard === true){return new THREE.ShaderMaterial({vertexShader: document.querySelector('#chroma-vert').textContent.trim(),fragmentShader: document.querySelector('#chroma-frag').textContent.trim(),uniforms: {cameraNear: { value: camera.near },cameraFar: { value: camera.far }}});}else{return new THREE.MeshNormalMaterial({transparent: true} );}}/**** Returns a normal material for lines if the global variable "standard" is false. If "standard"* is set to true, returns a chromadepth material instead.** @method getStdMaterial* @for renderGlobal* @return {Object}* */function getStdLine(){if(standard === true){return new THREE.ShaderMaterial({vertexShader: document.querySelector('#chroma-vert').textContent.trim(),fragmentShader: document.querySelector('#chroma-frag').textContent.trim(),uniforms: {cameraNear: { value: camera.near },cameraFar: { value: camera.far }}});}else{return new THREE.LineDashedMaterial({color: 0x333333,dashSize: 50,gapSize:50})}}/**** Accepts an array of objects containing a string property called "Name" and returns* the first index where any two "Name" properties in the array have different characters.*** @method getPartNameCutoff* @for renderGlobal* @param {Object Array} partFrames An array of objects, each of which should containin* a property called "Name" with a non-null string.* @return {Int} The first index where any two "Name" properties in the array are different.* */function getPartNameCutoff(partFrames){var pos=1;var lim=partFrames.length;var checkPos;var checkLim=partFrames[0].Name.length;while(pos&lt;lim){checkPos=0;while(checkPos&lt;checkLim){if(partFrames[pos].Name[checkPos]!=partFrames[0].Name[checkPos]){checkLim=checkPos;}checkPos++;}pos++;}return checkLim;}/**** Accepts an array of objects containing a string property called "Name" removes* the first N characters in each string, where N is the first index where any two* "Name" properties in the array have different characters.*** @method cutoffPartNames* @for renderGlobal* @param {Object Array} partFrames An array of objects, each of which should containin* a property called "Name" with a non-null string.* @return {Void}* */function cutoffPartNames(partFrames){var cut=getPartNameCutoff(partFrames);var pos=0;var lim=partFrames.length;while(pos&lt;lim){partFrames[pos].Name=partFrames[pos].Name.substr(cut,partFrames[pos].Name.length-(cut+4));pos++;}}/**** Finds the average position of all the vertices in a given threeJS Geometry model.** @method centerGeometry* @for renderGlobal* @param {threeJS Geometry Object} theGeo* @return {threeJS Vector3 Object} A 3d coordinate, with each component being the unweighted* average of the corresponding component in each vector in the provided geometry object. If nodeName* vertices are present in the object, a zeroed vector is returned.* */function centerGeometry(theGeo){var verts=theGeo.vertices;var pos=0;var lim=verts.length;var avgX=0;var avgY=0;var avgZ=0;if(lim==0){return new THREE.Vector3(avgX,avgY,avgZ);}while(pos&lt;lim){avgX+=verts[pos].x;avgY+=verts[pos].y;avgZ+=verts[pos].z;pos++;}avgX/=lim;avgY/=lim;avgZ/=lim;pos=0;while(pos&lt;lim){verts[pos].x-=avgX;verts[pos].y-=avgY;verts[pos].z-=avgZ;pos++;}return new THREE.Vector3(avgX,avgY,avgZ);}/**** Accepts a list of binary stl buffer objects and returns a corresponding list* of ThreeJS objects.** @method getGeometries* @for renderGlobal * @param {Buffer Object List} theSTLs* @return {ThreeJS Object List}* */function getGeometries(theSTLs){var result=[];var pos=0;var lim=theSTLs.length;while(pos&lt;lim){result.push(parseStlBinary(theSTLs[pos]));pos++;}return result;}/**** Combines a given array of objects (each associating an array of keyframes to name) with a * given array of objects (each associating a threeJS mesh with a name), creating an array* of objects with keyFrame arrays and threeJS meshes associated with the same name** @method bindPartsToKeyFrames* @for renderGlobal* @param {Array} theKeyFrameLists An array of objects, each containing an array of keyframe objects * called "Frames" and a string property called "Name")* @param {Array} theParts An array of objects, each containing a threeJS mesh object called "Mesh" and* a string property called "Name"* @return {Array} **/function bindPartsToKeyFrames(theKeyFrameLists, theParts){var pos=0;var searchPos;var lim=theKeyFrameLists.length;var searchLim=theParts.length;var result=[];while(pos&lt;lim){searchPos=0;while(searchPos&lt;searchLim){if(theKeyFrameLists[pos].Name===theParts[searchPos].Name || theKeyFrameLists[pos].Name+".STL"===theParts[searchPos].Name || theKeyFrameLists[pos].Name===theParts[searchPos].Name+".STL"){ break;}searchPos++;}if(searchPos==searchLim){pos++;continue;}theParts[searchPos].Mesh.material.transparent = true;console.log(theParts[searchPos].Mesh);result.push({Name: theKeyFrameLists[pos].Name,Frames: theKeyFrameLists[pos].Frames,Mesh: theParts[searchPos].Mesh});/*console.log({Name: theKeyFrameLists[pos].Name,Frames: theKeyFrameLists[pos].Frames,Mesh: theParts[searchPos].Mesh});*/pos++;}flipTheTimes(result);return result;}/**** Combines a jagged array of objects, each object at least possessing a numeric* property called "Time", returns the value of the greatest "Time" property** @method longestTimeFromFrames* @for renderGlobal* @param {Array} partFrames The jagged array* @return {Int} The greatest "Time" value in the jagged array**/function longestTimeFromFrames(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var best=0;while(x&lt;xLim){y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){best=Math.max(best,partFrames[x].Frames[y].Time);y++;}x++;}return best;}/**** Given a jagged array of objects, each object at least possessing a numeric* property called "Time", sets each Time property to the greatest Time value in* the jagged array minus the origional value, thus effectively reversing the* temporal order of each object** @method flipTheTimes* @for renderGlobal* @param {Array} partFrames The jagged array* @return {Int} The greatest "Time" value in the jagged array**/function flipTheTimes(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var tFlip=longestTimeFromFrames(partFrames);while(x&lt;xLim){y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){partFrames[x].Frames[y].Time=tFlip-partFrames[x].Frames[y].Time;y++;}partFrames[x].Frames.reverse();x++;}return;}/**** Logs the contents of the given jagged array of keyFrame objects, each containing numeric properties "X",* "Y", "Z", and "Time", to the console as a string.** @method showFrames* @for renderGlobal* @param {Array} partFrames A jagged array of keyframe objects* @return {Void}**/function showFrames(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var tFlip=longestTimeFromFrames(partFrames);var timeList;var listList=[];while(x&lt;xLim){timeList=[];y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){theFrame=partFrames[x].Frames[y];timeList.push("X: "+theFrame.Position.x+" Y: "+theFrame.Position.y+" Z: "+theFrame.Position.z+" Time: "+theFrame.Time);y++;}listList.push(timeList);x++;}return;}/**** Logs the contents of a given keyFrame object, containing numeric properties "X",* "Y", "Z", and "Time", to the console as a string.** @method showFrame* @for renderGlobal* @param {Array} theFrame the keyFrame object to be logged* @return {Void}**/function sayFrame(theFrame){console.log("X: "+theFrame.Position.x+" Y: "+theFrame.Position.y+" Z: "+theFrame.Position.z+" Time: "+theFrame.Time);}/**** Returns true if any position component of the given keyframe object is NaN** @method hasNaN* @for renderGlobal* @param {Object} theFrame A keyFrame object* @return {Boolean}**/function hasNaN(theFrame){return (isNaN(theFrame.Position.x) || isNaN(theFrame.Position.y) || isNaN(theFrame.Position.z));}/**** Returns a copy of the provided keyframe object** @method copyFrame* @for renderGlobal* @param {Object} theFrame A keyFrame object* @return {Object} The copy**/function copyFrame(theFrame){var result={Quat: new THREE.Quaternion(0,0,0,0),Position: null,Time: null,Alpha: 1.0}result.Quat.copy(theFrame.Quat);result.Position=theFrame.Position.clone();result.Time=theFrame.Time;result.Alpha = theFrame.Alpha;return result;}/**** Returns a copy of the provided array of keyframe objects** @method copyFrameList* @for renderGlobal* @param {Array} partFrames A keyFrame object array* @return {Array} The copy**/function copyFrameList (theFrameList){var pos=0;var lim=theFrameList.length;var result=[];while(pos&lt;lim){result.push(copyFrame(theFrameList[pos]));pos++;}return result;}/**** Creates a keyframe list for the given fastener object and adds it to currentFrameList** @method makeFastenerKeyFrames* @for renderGlobal * @param {Object} theFst The object representation of the fastener being keyframed* @param {Object List} runningList The current running list of keyframes* @param {Object List} currentFrameList The list of part-keyframe list objects* @return {Void}* */function makeFastenerKeyFrames(theFst,runningList,currentFrameList){var newQuat= new THREE.Quaternion();newQuat.setFromEuler(new THREE.Euler(0,0,0,'XYZ'));var presentFrame={Quat: newQuat, Position: new THREE.Vector3(theFst.X,theFst.Y,theFst.Z),Time: theFst.Time};runningList.push(presentFrame);var copiedList= copyFrameList(runningList);if(copiedList.length===1){copiedList.length = 2;copiedList[1] = copiedList[0];copiedList[0] = {Quat: newQuat, Position: new THREE.Vector3(0.0,0.0,0.0),Time: 0.00};}currentFrameList.push({Name: theFst.Name, Frames: copiedList});console.log({Name: theFst.Name, Frames: copiedList});runningList.pop();return;}/**** Given a tree representation of the assembly process through nested javascript objects, returns an array* of keyframe array objects, with each keyframe array object being a representation of the movement of each part * in the tree representation throughout the assembly proceess, with a list of keyframe objects and a given part name** @method makeKeyFrames* @for renderGlobal* @param {Object} theTree Tree representation of the assembly process through nested javascript objects* @param {Array} runningList Internally used variable. Should be an empty array for outside use.* @param {Array} currentFrameList Internally used variable. Should be an empty array for outside use.* @return {Array} The jagged array of keyFrame objects**/function makeKeyFrames(theTree, runningList, currentFrameList){var isRoot=0;if(runningList.length==0){isRoot=1;/*console.log("ROOT");console.log(theTree);*/}var newQuat= new THREE.Quaternion();newQuat.setFromEuler(new THREE.Euler(0,0,0,'XYZ'));var presentFrame = {Quat: newQuat, Position: new THREE.Vector3(theTree.X,theTree.Y,theTree.Z),Time: theTree.Time,Alpha: 1.0};runningList.push(presentFrame);if(theTree.Ref === null){var copiedList= copyFrameList(runningList);currentFrameList.push({Name: theTree.Name, Frames: copiedList});runningList.pop();}else{makeKeyFrames(theTree.Ref,runningList,currentFrameList);makeKeyFrames(theTree.Mov,runningList,currentFrameList);runningList.pop();}var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){makeFastenerKeyFrames(theTree.Fst[pos],runningList,currentFrameList);pos++;}if(isRoot===1){return currentFrameList;}return;}/**** Given two keyFrames and a normalized float "proportion", returns an interpolation* between the two keyframes with a weight towards the second keyframe proportional* to "proportion"** @method interpolate* @for renderGlobal* @param {Object} keyFrame1 The earlier keyFrame* @param {Object} keyFrame2 The later keyFrame* @param {Float} proportion A normalized value representing what proportion of the path of* interpolation is between the result and the earlier keyFrame* @return {Object} The jagged array of keyFrame objects**/function interpolate(keyFrame1, keyFrame2, proportion){var result={ Quat: new THREE.Quaternion(), Position: new THREE.Vector3(0,0,0), Time: null, Alpha: 1.0 };THREE.Quaternion.slerp (keyFrame1.Quat, keyFrame2.Quat, result.Quat, proportion);result.Position.x=keyFrame1.Position.x*(1-proportion)+keyFrame2.Position.x*proportion;result.Position.y=keyFrame1.Position.y*(1-proportion)+keyFrame2.Position.y*proportion;result.Position.z=keyFrame1.Position.z*(1-proportion)+keyFrame2.Position.z*proportion;result.Time=keyFrame1.Time*(1-proportion)+keyFrame2.Time*proportion;result.Alpha=keyFrame1.Alpha*(1-proportion)+keyFrame2.Alpha*proportion;/*if(hasNaN(result)){console.log("vvvvvvvvvvvv");console.log("Prop: "+proportion);sayFrame(keyFrame1);sayFrame(keyFrame2);sayFrame(result);console.log("^^^^^^^^^^^^");}*/return result;}/**** Given a list of keyframes and a time quantity, returns a keyframe object interpolating* between the two temporally closest keyframes. In cases where the provide time is beyond the* range of times represented by the list, returns the closest keyframe** @method grabInterp* @for renderGlobal* @param {Array} frameList A list of keyframes. Must be organized from least time value to greatest time value* @param {Float} time Floating-point representation of what time in the keyframe progression the interpolation* should occur* @return {Object} The interpolated keyframe**/function grabInterp(frameList, time){var pos=0;var lim=frameList.length;while((pos&lt;lim) &amp;&amp; (time&gt;frameList[pos].Time)){pos++; }/*if(pos&lt;lim){timeReport=timeReport+" -&gt; "+time+" &lt;- "+frameList[pos].Time.toString();}else{timeReport=timeReport+" -&gt; "+frameList[lim-1].Time.toString()+" -&gt; "+time;}console.log(timeReport);*/if(pos==0){var theResult= copyFrame(frameList[0]);}else if(pos==lim){var theResult= copyFrame(frameList[lim-1]);}else{var prop=(time-frameList[pos-1].Time)/(frameList[pos].Time-frameList[pos-1].Time);var theResult=interpolate(frameList[pos-1],frameList[pos],prop);}return theResult;}/**** Given an array of objects (each containing a threeJS mesh object and an array of * keyFrame objects), and two floating points "time" and "timeWarp", will animate each* mesh in the array along the keyframes in their associate objects according to the * given "time" and returns the new time as given by the standard time step multiplied* by "timeWarp" ** @method animate* @for renderGlobal* @param {Array} partFrames List of objects relating threeJS mesh objects with their * respective keyframe arrays * @param {Float} time The time to be used when interpolating keyFrames for the models* @param {Float} timeWarp The coefficeint to be applied to the timestep in the* animation* @return {Float} The new value of time in the animation**/function animate(partFrames, time, timeWarp){var pos=0;var lim=partFrames.length;var interp;var eul= new THREE.Euler();var delt=new THREE.Vector3();while(pos&lt;lim){interp=grabInterp(partFrames[pos].Frames,time,partFrames[pos].Mesh.position);eul.setFromQuaternion(interp.Quat);partFrames[pos].Mesh.rotation.x=eul.x;partFrames[pos].Mesh.rotation.y=eul.y;partFrames[pos].Mesh.rotation.z=eul.z;partFrames[pos].Mesh.position.x=interp.Position.x;partFrames[pos].Mesh.position.y=interp.Position.y;partFrames[pos].Mesh.position.z=interp.Position.z;partFrames[pos].Mesh.material.opacity = interp.Alpha;pos++;}var timeStep=timeWarp/60;time+=timeStep;return time;}/**** Given two threeJS boundingBox objects, returns the smallest bounding box* encompassing the two** @method combineBounds* @for renderGlobal* @param {Object} a The first bounding box* @param {Object} b The second bounding box* @return {Object} The combined bounds**/function combineBounds(a,b){var r={};r.min= new THREE.Vector3();r.max= new THREE.Vector3();r.min.x = Math.min(a.min.x,b.min.x);r.max.x= Math.max(a.max.x,b.max.x);r.min.y = Math.min(a.min.y,b.min.y);r.max.y= Math.max(a.max.y,b.max.y);r.min.z = Math.min(a.min.z,b.min.z);r.max.z= Math.max(a.max.z,b.max.z);return r;}/**** Given two threeJS boundingBox objects, returns the smallest bounding box* encompassing the two** @method getGlobBounds* @for renderGlobal* @param {Object} a The first bounding box* @param {Object} b The second bounding box* @return {Object} The combined bounds**/function getGlobBounds(partFrames){partFrames[0].Mesh.geometry.computeBoundingBox();var runningBound=partFrames[0].Mesh.geometry.boundingBox;var pos=1;var lim=partFrames.length;while(pos&lt;lim){partFrames[pos].Mesh.geometry.computeBoundingBox();runningBound=combineBounds(runningBound,partFrames[pos].Mesh.geometry.boundingBox);pos++;}return runningBound;}/**** Given an object, containing a threeJS mesh object as "Mesh", will* return the center of the mesh's bounding box** @method getPartCenter* @for renderGlobal* @param {Object} a The object containing the threeJS mesh object* @return {Object} The center of the mesh's bounding box, represented as* a threeJS Vector3 object**/function getPartCenter(part){part.Mesh.geometry.computeBoundingBox();var bound=part.Mesh.geometry.boundingBox;var center= new THREE.Vector3((bound.min.x+bound.max.x)/2,(bound.min.y+bound.max.y)/2,(bound.min.z+bound.max.z)/2);center.x+=part.Mesh.position.x;center.y+=part.Mesh.position.y;center.z+=part.Mesh.position.z;return center;}/**** Aligns the camera to look at the point at the average of the centers of all the parts bounding boxes* @method alignAssemblyCenter* @for renderGlobal* @return {Void}* */function alignAssemblyCenter(){var pos = 0;var lim = partFrames.length;var result = new THREE.Vector3(0,0,0);while(pos&lt;lim){result.add(getPartCenter(partFrames[pos]));pos++;}result.divideScalar(partFrames.length);result.sub(camera.position);result.normalize();camYaw = Math.atan2(result.x,result.z) - Math.PI;camPitch = Math.atan2(Math.pow(result.x*result.x+result.z*result.z,0.5),result.y);}/**** Given a threeJS scene object, a threeJS camera object, and an array of objects containing* threeJS mesh objects, finds the first mesh in the scene which is intersected the ray extending* through the center of the camera's field of vision. If this mesh is in the provided array of * objects, then that object is returned, otherwise null is returned instead** @method getFirstIntersect* @for renderGlobal* @param {Object} theScene The threeJS scene object in which intersections should* be tested* @param {Object} theCamera The threeJS camera object to be used to test for * ray intersections* @param {Array} partFrames An array containing a series of objects, each of which* contain a threeJS mesh object (under the property "Mesh") to be tested for intersections* @return {Object} The intersecting mesh (or null in case of no valid intersection)**/function getFirstIntersect(theScene, theCamera, partFrames){var caster= new THREE.Raycaster();var mousePos= new THREE.Vector2(0,0);caster.setFromCamera(mousePos,theCamera);var intersectList=caster.intersectObjects(theScene.children);if(intersectList.length===0){return null;}else{var pos=0;var lim=partFrames.length;var part=intersectList[0].object;while(pos&lt;lim){if(part===partFrames[pos].Mesh){return partFrames[pos];}pos++;}return null;}}/**** Given an tree representation of the movement of parts in an assembly sequence, the* parent node of that node, and a threeJS scene object, inserts a line for each subassembly* path along the path of movement** @method addLines* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Object} parentNode Used for internal use. Null should be applied for external use.* @param {Object} theScene the threeJS scene to which the line representations will be added* @return {Void}**/function addLines(movTree,parentNode,theScene,isMov){if(movTree==null){return;}else{if(parentNode!=null){var theGeo=new THREE.Geometry();var startP=new THREE.Vector3(movTree.X,movTree.Y,movTree.Z);var endP=new THREE.Vector3(parentNode.X,parentNode.Y,parentNode.Z);theGeo.vertices=[startP,endP];movTree.Line= new THREE.LineSegments(theGeo,getStdLine());theScene.add(movTree.Line);}else{movTree.Line= null;}addLines(movTree.Ref,movTree,theScene,false);addLines(movTree.Mov,movTree,theScene,true);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){if(isMov || parentNode != null){addLines(movTree.Fst[pos],parentNode,theScene,false);}else{addLines(movTree.Fst[pos],movTree,theScene,false);}pos++;}return;}}/**** Given an tree representation of the movement of parts in an assembly sequence, an * array of Objects each associating a list of keyframes with a threeJS mesh object and aLinkcolor* string, and the index of the keyframe associated with the tree's root node, displaces the movement* line points associated with that particular part of the assembly to match the displacement of the* model** @method addDisplacement* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Array} partFrames An array of Objects each associating a list of keyframes with a threeJS* mesh object and a string* @param {Object} it The index of the keyframe associated with the root node of movTree. Used internally.* For external use, apply 0.* @return {Void}**/function addDisplacement(movTree, partFrames, it){if(movTree==null){return;}else{var ref=addDisplacement(movTree.Ref,partFrames,it);if(ref!=null){var mov=addDisplacement(movTree.Mov, partFrames, ref);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){mov = addDisplacement(movTree.Fst[pos], partFrames, mov);pos++;}it=mov;}if(mov==null || ref==null){movTree.Disp=getPartCenter(partFrames[it]);it++;}else{movTree.Disp=new THREE.Vector3(0,0,0);movTree.Disp.lerpVectors(movTree.Ref.Disp,movTree.Mov.Disp,0.5);}if(movTree.Line!=null){movTree.Line.geometry.vertices[0].addVectors(movTree.Line.geometry.vertices[0],movTree.Disp);movTree.Line.geometry.vertices[1].addVectors(movTree.Line.geometry.vertices[1],movTree.Disp);}return it;}}/**** Given an tree representation of the movement of parts in an assembly sequence, the* parent node of that node, and the current time in the animation, updates the ends of the* movement lines such that the portion of lines which have already been traversed are not shown** @method updateLines* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Object} parentNode Used for internal use. Null should be applied for external use.* @param {Object} theTime the threeeJS scene to which the line representations will be added* @return {Void}**/function updateLines(movTree,parentNode,theTime, isMov){if(movTree==null){return;}else{if(movTree.Line!=null &amp;&amp; parentNode!=null){if(theTime&lt;=parentNode.Time){if(theTime&gt;=movTree.Time){var normTime=(parentNode.Time-theTime)/(parentNode.Time-movTree.Time);movTree.Line.geometry.vertices[0].x=(movTree.X+movTree.Disp.x)*(normTime)+(parentNode.X+movTree.Disp.x)*(1-normTime);movTree.Line.geometry.vertices[0].y=(movTree.Y+movTree.Disp.y)*(normTime)+(parentNode.Y+movTree.Disp.y)*(1-normTime);movTree.Line.geometry.vertices[0].z=(movTree.Z+movTree.Disp.z)*(normTime)+(parentNode.Z+movTree.Disp.z)*(1-normTime);}else{movTree.Line.geometry.vertices[0].x=movTree.X+movTree.Disp.x;movTree.Line.geometry.vertices[0].y=movTree.Y+movTree.Disp.y;movTree.Line.geometry.vertices[0].z=movTree.Z+movTree.Disp.z;}}else{movTree.Line.geometry.vertices[0]=movTree.Line.geometry.vertices[1].clone();}movTree.Line.geometry.verticesNeedUpdate=true;}updateLines(movTree.Ref,movTree,theTime,false);updateLines(movTree.Mov,movTree,theTime,true);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){if( parentNode != null ){updateLines(movTree.Fst[pos],parentNode,theTime,false);}else{updateLines(movTree.Fst[pos],movTree,theTime,false);}pos++;}return;}}/**** Initializes the axis lines for the bottom-left of the screen** @method initAxisLines* @for renderGlobal* @return {Void}**/function initAxisLines(){theXAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0xff0000, depthTest: false }));theXAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theXAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theXAxis.frustumCulled = false;theYAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x00ff00, depthTest: false }));theYAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theYAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theYAxis.frustumCulled = false;theZAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x0000ff, depthTest: false }));theZAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theZAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theZAxis.frustumCulled = false;xRet = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x000000 }));xRet.geometry.vertices.push(new THREE.Vector3(0,0,0));xRet.geometry.vertices.push(new THREE.Vector3(0,0,0));xRet.frustumCulled = false;yRet = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x000000 }));yRet.geometry.vertices.push(new THREE.Vector3(0,0,0));yRet.geometry.vertices.push(new THREE.Vector3(0,0,0));yRet.frustumCulled = false;scene.add(theXAxis);scene.add(theYAxis);scene.add(theZAxis);scene.add(xRet);scene.add(yRet);}/**** Updates the axis line dispay** @method updateAxisLines* @for renderGlobal* @return {Void}**/function updateAxisLines(){var theRot= new THREE.Quaternion(0,0,0,0);theRot.setFromEuler(camera.rotation);var theDir= new THREE.Vector3(-3,-3,-5);var retX0= new THREE.Vector3(-0.3,0,-5);var retX1= new THREE.Vector3(0.3,0,-5);var retY0= new THREE.Vector3(0,-0.08,-5);var retY1= new THREE.Vector3(0,0.08,-5);theDir.applyQuaternion(theRot);retX0.applyQuaternion(theRot);retX1.applyQuaternion(theRot);retY0.applyQuaternion(theRot);retY1.applyQuaternion(theRot);var thePosition = camera.position.clone();thePosition.add(theDir);theXAxis.geometry.vertices[0].copy(thePosition);theXAxis.geometry.vertices[0].x-=0.5;theXAxis.geometry.vertices[1].copy(thePosition);theXAxis.geometry.vertices[1].x+=1;theXAxis.geometry.verticesNeedUpdate=true;theYAxis.geometry.vertices[0].copy(thePosition);theYAxis.geometry.vertices[0].y-=0.5;theYAxis.geometry.vertices[1].copy(thePosition);theYAxis.geometry.vertices[1].y+=1;theYAxis.geometry.verticesNeedUpdate=true;theZAxis.geometry.vertices[0].copy(thePosition);theZAxis.geometry.vertices[0].z-=0.5;theZAxis.geometry.vertices[1].copy(thePosition);theZAxis.geometry.vertices[1].z+=1;theZAxis.geometry.verticesNeedUpdate=true;thePosition.copy(camera.position);thePosition.add(retX0);xRet.geometry.vertices[0].copy(thePosition);thePosition.copy(camera.position);thePosition.add(retX1);xRet.geometry.vertices[1].copy(thePosition);xRet.geometry.verticesNeedUpdate=true;thePosition.copy(camera.position);thePosition.add(retY0);yRet.geometry.vertices[0].copy(thePosition);thePosition.copy(camera.position);thePosition.add(retY1);yRet.geometry.vertices[1].copy(thePosition);yRet.geometry.verticesNeedUpdate=true;}/**** Performs a bezier curve interpolation of the control points in pointlist given * the time value T, and returns a ThreeJS Vector3 object with the interpolated coordinates.** @method interp * @for renderGlobal* @param {Vector3 Array} pointList A list of control points for use in interpolation.* @param {Float} T A normalized value for use as a time value in interpolation.* @return {Object}**/function interp (pointList, T){var pos = 0;var lim = pointList.length;var listCopy = [];while(pos&lt;lim){listCopy.push(pointList[pos].clone());pos++;}while(lim&gt;1){pos = 0;while(pos&lt;lim-1){listCopy[pos].lerpVectors(listCopy[pos],listCopy[pos+1],T);pos++;}delete listCopy[pos];lim--;}return listCopy[1];}/**** Returns a string describing the x, y, and z coordinates of theVec.** @method vecDesc * @for renderGlobal* @param {Vector3} theVec The ThreeJS Vector3 object to be described by the output string* @return {String}**/function vecDesc(theVec){return "X: "+theVec.x+" Y: "+theVec.y+" Z: "+theVec.z;}/**** Recursively adds Vector3 objects onto the Vector3 list, target, interpolating from startDisp* and endDisp in an arc centered at the Vector3 object center. Each layer of recursion* adds the midpoint of the arc from startDisp to endDisp until level = 0.** @method addArcSubDiv * @for renderGlobal * @param {Vector3 Array} target The list where the calculated Vector3 objects should be added* @param {Vector3} center The point which the generated arc should be centered on* @param {Vector3} startDisp The starting point of the arc* @param {Vector3} endDisp The ending point of the arc* @param {Int} level The desired levels of recursion in the point interpolation* @return {Void}**/function addArcSubDiv (target, center, startDisp, endDisp, level){var midVec = new THREE.Vector3(0,0,0);var midDisp = new THREE.Vector3(0,0,0);var startVec = new THREE.Vector3(0,0,0);var endVec = new THREE.Vector3(0,0,0);midDisp.add(startDisp);midDisp.add(endDisp);midDisp.normalize();midDisp.multiplyScalar((startDisp.length()+endDisp.length())/2);midVec.add(midDisp);midVec.add(center);startVec.add(startDisp);startVec.add(center);endVec.add(endDisp);endVec.add(center);if(level &lt;= 0){target.push(midVec);target.push(endVec);}else{addArcSubDiv(target,center,startDisp,midDisp, level-1);addArcSubDiv(target,center,midDisp,endDisp, level-1);}}/**** Returns a list of 2^(resolution+1) points which trace an arc beginning at startPoint,* terminating at endpoint, and centered around center** @method makeArcPointList* @for renderGlobal * @param {Vector3} startPoint The starting point of the arc* @param {Vector3} center The point which the generated arc should be centered on* @param {Vector3} endPoint The ending point of the arc* @param {Int} resolution The desired levels of recursion in the point interpolation* @return {Vector3 Array}**/function makeArcPointList(startPoint, center, endPoint, resolution){var pos = 0;var lim = 5;var result = [];var norm;var workVector = new THREE.Vector3 ( 0,0,0 );var crossVector = new THREE.Vector3 ( 0,0,0 );var startDisp = new THREE.Vector3 ( 0,0,0 );var endDisp = new THREE.Vector3 ( 0,0,0 );workVector.copy(endPoint);workVector.sub(center);startDisp.copy(startPoint);startDisp.sub(center);crossVector.clone(startDisp);endDisp.copy(endPoint);endDisp.sub(center);if(Math.abs(workVector.dot(crossVector)) &gt; 0.98){while(Math.abs(workVector.dot(crossVector)) &gt; 0.98){crossVector.set(Math.random()*100, Math.random()*100, Math.random()*100);}crossVector.cross(workVector);crossVector.normalize();crossVector.multiplyScalar((startDisp.length()+endDisp.length())/2);addArcSubDiv(result,center,endDisp,crossVector,resolution-1);addArcSubDiv(result,center,crossVector,startDisp,resolution-1);}else{delete crossVector;crossVector = null;addArcSubDiv(result,center,endDisp,startDisp,resolution);}return result;} /**** Adds keyframes onto the keyframe lists provided so that the keyframed parts begin their* animation at start location and move in an arc to their previously defined start position** @method addCurveKeyFrames* @for renderGlobal * @param {Object List} theFrameLists A list of keyframe lists describing the movement of 3d models* @param {Vector3} startLocation The desired new start location of the 3d models in the animation* @return {Void}**/function addCurveKeyFrames(theFrameLists, startLocation){var pos = 0;var lim = theFrameLists.length;var center = new THREE.Vector3(0,0,0);center.add(startLocation);center.multiplyScalar(0.5);pos = 0;lim = theFrameLists.length;var framePos;var frameLim;var startFrame;var theFrame;var interpPoints;var offSet;var resolution = 4;while(pos&lt;lim){interpPoints = [];startFrame = (theFrameLists[pos].Frames)[(theFrameLists[pos].Frames.length)-1];interpPoints = makeArcPointList( startLocation, center, startFrame.Position, resolution);framePos = 0;frameLim = interpPoints.length;while(framePos&lt;frameLim){theFrame = copyFrame(startFrame);theFrame.Position.copy(interpPoints[framePos]);theFrame.Time = startFrame.Time + framePos + 8;theFrame.Alpha = 1.0 - Math.pow((framePos+1)/frameLim,4);(theFrameLists[pos].Frames).push(theFrame);framePos++;}framePos = 0;frameLim = theFrameLists[pos].Frames.length;while(framePos&lt;frameLim){framePos++;}pos++;}return 8 + Math.pow(2,resolution+1);}/**** Adds a simple square grid of width equal to theSize and a number of lines equal to theDivs at Y=-1000** @method addGrid* @for renderGlobal * @param {Int} theSize The desired grid width* @param {Int} theDivs The desired number of lines per side of the grid* @return {Void}**/function addGrid(theSize, theDivs, theHeight, theColor){var xpos = 0;var zpos = 0;var theLine = null;var theGeo = new THREE.Geometry();while(xpos&lt;theDivs){theGeo.vertices.push(new THREE.Vector3(xpos*theSize/theDivs-theSize/2, theHeight , 0-theSize/2));theGeo.vertices.push(new THREE.Vector3(xpos*theSize/theDivs-theSize/2, theHeight , theSize/2));xpos++;}while(zpos&lt;theDivs){theGeo.vertices.push(new THREE.Vector3(0-theSize/2, theHeight, zpos*theSize/theDivs-theSize/2));theGeo.vertices.push(new THREE.Vector3(theSize/2, theHeight , zpos*theSize/theDivs-theSize/2));zpos++;}theLine = new THREE.LineSegments(theGeo,getStdLine());scene.add(theLine);}/**** Adds a simple vertical column with a radius of theRad, a base Y value of theBot, a top terminating at* theTop, an x and z position equal to theX and theZ, a line color of theColor, a number of vertical * segmentations equal to stacks, and a number of radial segmentations equal to slices** @method addGrid* @for renderGlobal * @param {Float} theRad The desired radius of the column* @param {Float} theBot The desired bottom y value of the column* @param {Float} theTop The desired top y value of the column* @param {Float} theX The desired x value of the column* @param {Float} theZ The desired z value of the column* @param {Float} slices The desired number of radial segmentations* @param {Float} stacks The desired z value of vertical segmentations* @param {Float} theColor The desired color of the column* @return {Void}**/function addCylender(theRad, theBot, theTop, theX, theZ, slices, stacks, theColor){var slicePos = 0;var stackPos;var theLine = null;var theGeo = new THREE.Geometry();while(slicePos&lt;slices){stackPos = 0;while(stackPos&lt;stacks+1){theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theBot*stackPos/stacks+theTop*(stacks-stackPos)/stacks, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*(slicePos+1)/slices), theBot*stackPos/stacks+theTop*(stacks-stackPos)/stacks, theZ+theRad*Math.sin(Math.PI*2*(slicePos+1)/slices) ));stackPos++;}theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theBot, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theTop, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));slicePos++;}theLine = new THREE.LineSegments(theGeo,getStdLine());scene.add(theLine);}</dataobject>
            </data>
        </parameter>
    </parameters>
    <relations>
        <relation type="Procedural" id="1f2fbf14-dfed-1004-8be0-58277b79f346" name="Test Relation">
            <parameters>
                <parameter id="2de11d02-dff9-1004-8053-4b6b5190a41e" name="OutputStage">
                    <currentType value="Integer"/>
                    <data>
                        <dataobject type="Integer">
                            <quantity magnitude="0" unit="No_Unit"/>
                        </dataobject>
                    </data>
                </parameter>
                <parameter id="2de11d03-dff9-1004-8053-4b6b5190a41e" name="InputStage">
                    <currentType value="Integer"/>
                    <data>
                        <dataobject type="Integer">
                            <quantity magnitude="0" unit="No_Unit"/>
                        </dataobject>
                    </data>
                </parameter>
                <parameter id="ed2f8a9b-dffc-1004-896f-4e4d575adaac" name="pageBase">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String">&lt;div&gt;&lt;style&gt;{{pageStyle}}&lt;/style&gt;&lt;div id="theBody"&gt;{{pageMain}}&lt;/div&gt;&lt;script src="https:&lt;script&gt;{{pageScript}}&lt;/script&gt;&lt;/div&gt;</dataobject>
                    </data>
                </parameter>
                <parameter id="ed2f8a9c-dffc-1004-896f-4e4d575adaac" name="pageMain">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String"></dataobject>
                    </data>
                </parameter>
                <parameter id="ed2f8a9d-dffc-1004-896f-4e4d575adaac" name="pageUnit">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String"></dataobject>
                    </data>
                </parameter>
                <parameter id="e05ae00c-e002-1004-8b78-46d8a5cbbeea" name="pageStyle">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String"></dataobject>
                    </data>
                </parameter>
                <parameter id="e05ae00d-e002-1004-8b78-46d8a5cbbeea" name="pageScript">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String"></dataobject>
                    </data>
                </parameter>
                <parameter id="5041d54a-e007-1004-88d8-84730f2d9e5d" name="jsstl">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String">/**** Converts a given block of binary stl data (as an arraybuffer) to a threeJS representation* of the geometry. Function courtesy of 'tonylukasavage' from Github, who released this to* the public domain. ** @method parseStlBinary* @for renderGlobal* @param {Arraybuffer} stl The binary stl data* @return {Object} threeJS geometry object* */var parseStlBinary = function(stl) {var geo = new THREE.Geometry();var dv = new DataView(stl, 80); var isLittleEndian = true;var triangles = dv.getUint32(0, isLittleEndian); var offset = 4;for (var i = 0; i &lt; triangles; i++) {var normal = new THREE.Vector3(dv.getFloat32(offset, isLittleEndian),dv.getFloat32(offset+4, isLittleEndian),dv.getFloat32(offset+8, isLittleEndian));offset += 12;for (var j = 0; j &lt; 3; j++) {geo.vertices.push(new THREE.Vector3(dv.getFloat32(offset, isLittleEndian),dv.getFloat32(offset+4, isLittleEndian),dv.getFloat32(offset+8, isLittleEndian)));offset += 12}offset += 2; geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));}geo.computeFaceNormals();return geo;}; /**** Processes a given string to make it parsible for parseStl and returns* the results** @method trim* @for renderGlobal* @param {String} str ASCII STL data* @return {String} processed string* */function trim (str) {str = str.replace(/^\s+/, '');for (var i = str.length - 1; i &gt;= 0; i--) {if (/\S/.test(str.charAt(i))) {str = str.substring(0, i + 1);break;}}return str;}/**** Converts an arraybuffer into a string of equivalent binary content* @method arrayToString* @for renderGlobal* @param {Arraybuffer} buf The arraybuffer* @return {String} * */function arrayToString(buf) {var pos=0;var arr=new Uint8Array(buf);var lim=arr.length;var result="";while(pos&lt;lim){result=result+String.fromCharCode(arr[pos]);pos++;}return result;}/**** Converts a given block of ASCII stl data (as an arraybuffer) to a threeJS representation* of the geometry. Function courtesy of 'tonylukasavage' from Github, who released this to* the public domain. ** @method parseStl* @for renderGlobal* @param {Arraybuffer} stl The ASCII stl data* @return {Object} threeJS geometry object* */var parseStl = function(stl) {var state = '';stl=arrayToString(stl);var lines = stl.split('\n');var geo = new THREE.Geometry();var name, parts, line, normal, done, vertices = [];var vCount = 0;stl = null;for (var len = lines.length, i = 0; i &lt; len; i++) {if (done) {break;}line = trim(lines[i]);parts = line.split(' ');switch (state) {case '':if (parts[0] !== 'solid') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "solid"');return null;} else {name = parts[1];state = 'solid';}break;case 'solid':if (parts[0] !== 'facet' || parts[1] !== 'normal') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "facet normal"');return null;} else {normal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];state = 'facet normal';}break;case 'facet normal':if (parts[0] !== 'outer' || parts[1] !== 'loop') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "outer loop"');return null;} else {state = 'vertex';}break;case 'vertex': if (parts[0] === 'vertex') {geo.vertices.push(new THREE.Vector3(parseFloat(parts[1]),parseFloat(parts[2]),parseFloat(parts[3])));} else if (parts[0] === 'endloop') {geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );vCount++;state = 'endloop';} else {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');return null;}break;case 'endloop':if (parts[0] !== 'endfacet') {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "endfacet"');return null;} else {state = 'endfacet';}break;case 'endfacet':if (parts[0] === 'endsolid') {return geo;done = true;} else if (parts[0] === 'facet' &amp;&amp; parts[1] === 'normal') {normal = [parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4])];if (vCount % 1000 === 0) {}state = 'facet normal';} else {console.error(line);console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');return null;}break;default:console.error('Invalid state "' + state + '"');break;}}};</dataobject>
                    </data>
                </parameter>
                <parameter id="5041d54b-e007-1004-88d8-84730f2d9e5d" name="treequence">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String">;/**** Given a jQuery object, returns a full list of all of its children.** @method whatsIn* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose children should be returned* @return {Array} Array of the object's children* */function whatsIn(theTree){return document.getElementById("warning").innerHTML=$(theTree).children("*");}/**** Given a jQuery object and a string, returns the first child of the given element with* a tag equivalent to the given string.** @method grab* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose child is to be returned* @param {String} theMember The name of the tag being searched* @return {jQuery Object} The first child with the given tag. If such a child does not * exist, null is returned.* */function grab(theTree,theMember){if($(theTree).children(theMember).length!=0){return $(theTree).children(theMember)[0];}else{return null;}}/**** Given a jQuery object and an integer "N", returns the Nth child of the given element with* the given tag. ** @method grabInd* @for renderGlobal* @param {jQuery Object} theTree The jQuery object whose child is to be returned* @param {String} theMember The name of the tag being searched* @param {String} theIndex The ordinal of the matching child to be returned* @return {jQuery Object} The child meeting the tag and ordinal requirement. * If such a child does not exist, null is returned.* */function grabInd(theTree,theMember, theIndex){if($(theTree).children(theMember).length&gt;theIndex){return $(theTree).children(theMember)[theIndex];}else{return null;}}/**** Given a jQuery object derived from parsing an XML document, extracts all information* relevant to part movement and composes it into an identically structured tree of * nested javascript objects which is then returned** @method getMovement* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @param {Float} myX The X position of the subassembly represented by the root node of theTree* @param {Float} myY The Y position of the subassembly represented by the root node of theTree* @param {Float} myZ The Z position of the subassembly represented by the root node of theTree* @param {Float} myTime The time value of the subassembly represented by the root node of theTree* @return {Object} The root node of the tree of extracted movement data * */function getMovement(theTree, myX, myY, myZ, myTime){if(($(theTree).children("Install").length==0)){return { Name: $(theTree).attr("Name"), X: myX, Y: myY, Z: myZ, Time: myTime, Ref: null, Mov: null, Fst: [] };}else{var childTime=parseFloat(grab(grab(theTree,"Install"),"Time").innerHTML)+myTime;var movDirection=grab(grab(theTree,"Install"),"InstallDirection");var movXDir=parseFloat(grabInd(movDirection,"double",0).innerHTML);var movYDir=parseFloat(grabInd(movDirection,"double",1).innerHTML);var movZDir=parseFloat(grabInd(movDirection,"double",2).innerHTML);var movDistance=parseFloat(grab(grab(theTree,"Install"),"InstallDistance").innerHTML);movDistance = Math.min(movDistance,800);var movX=myX-movXDir*movDistance;var movY=myY-movYDir*movDistance;var movZ=myZ-movZDir*movDistance;var ref=getMovement(getRef(theTree), myX, myY, myZ, childTime);var mov=getMovement(getMov(theTree), movX, movY, movZ, childTime);var fasteners = $(theTree).children("Secure");var theFst;var theDir;var theDist;var Fst = [];if(fasteners.length &gt;= 1){fasteners = $(fasteners[0]).children("Fasteners");if(fasteners.length &gt;= 1){fasteners = $(fasteners[0]).children("Fastener");var pos = 0;var lim = fasteners.length;while(pos&lt;lim){theDist = parseFloat($(fasteners[pos]).children("InstallDistance")[0].innerHTML);theDir = ($(fasteners[pos]).children("InstallDirection"))[0];theDir = $(theDir).children("double");theFst = { Name: "subasm-"+($(fasteners[pos]).children("Name"))[0].innerHTML, X: myX-parseFloat(theDir[0].innerHTML)*theDist, Y: myY-parseFloat(theDir[1].innerHTML)*theDist, Z: myZ-parseFloat(theDir[2].innerHTML)*theDist, Time: childTime, Ref: null, Mov: null,Fst: []};Fst.push(theFst);pos++;}}}return { Name: "", X: myX, Y: myY, Z: myZ, Time: myTime, Ref: ref, Mov: mov, Fst: Fst};}}/**** Given a jQuery Object, will return the first child with the tag "Reference" of the first child with* the tag "Install" of the object. If no such child exists, null is returned. ** @method getRef* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be accessed* @return {jQuery Object} The resulting child* */function getRef(theTree){theTree=grab(theTree,"Install");theTree=grab(theTree,"Reference");return theTree;}/**** Given a jQuery Object, will return the first child with the tag "Moving" of the first child with* the tag "Install" of the object. If no such child exists, null is returned. ** @method getMov* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be accessed* @return {jQuery Object} The resulting child* */function getMov(theTree){theTree=grab(theTree,"Install");theTree=grab(theTree,"Moving");return theTree;}/**** Given a jQuery object derived from parsing an XML document, extracts all information* relevant to installation timing and composes it into an identically structured tree of * nested javascript objects which is then returned** @method getTimes* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @param {Float} parentTime The time value of the subassembly represented by the root node of theTree* @return {Object} The root node of the tree of extracted time data * */function getTimes(theTree, parentTime){if(($(theTree).children("Install").length==0)){return { Time: parentTime, Ref: null, Mov: null };}else{var myTime=parseFloat(grab(grab(theTree,"Install"),"Time").innerHTML)+parentTime;var ref=getTimes(getRef(theTree),myTime);var mov=getTimes(getMov(theTree),myTime);return { Time: parentTime, Ref: ref, Mov: mov};}}/**** Given a tree of nested objects, returns the highest "Time" value from all the nodes** @method getLongestTime* @for renderGlobal* @param {Object} timeTree The tree of time values* @return {Object} The highest time value in the tree* */function getLongestTime(timeTree){if(timeTree==null){return 0;}return Math.max(getLongestTime(timeTree.Ref),getLongestTime(timeTree.Mov),timeTree.Time);}/**** Given a jQuery object derived from parsing an XML document, extracts all part name * information and composes it into an identically structured tree of nested javascript* objects which is then returned** @method getNames* @for renderGlobal* @param {jQuery Object} theTree The jQuery object to be parsed over* @return {Object} The root node of the tree of extracted name data * */function getNames(theTree){if(($(theTree).children("Install").length==0)){return {Name: $(theTree).attr("Name"), Ref: null, Mov: null};}else{var ref = getNames(getRef(theTree));var mov = getNames(getMov(theTree));return {Name: "", Ref: ref, Mov: mov};}}/**** Given a three trees of nested javascript objects, one holding time data, one holding* movement data, and one holding part name data** @method mergeTrees* @for renderGlobal* @param {Object} TimeTree The root node of the tree containing time data* @param {Object} SpaceTree The root node of the tree containing movement data* @param {Object} NameTree The root node of the tree containing name data* @return {Object} The root node of the resulting tree* */function mergeTrees(TimeTree,SpaceTree,NameTree){if(TimeTree==null || SpaceTree==null || NameTree==null){return null;}else{var ref=mergeTrees(TimeTree.Ref,SpaceTree.Ref,NameTree.Ref);var mov=mergeTrees(TimeTree.Mov,SpaceTree.Mov,NameTree.Mov);return {Time: TimeTree.Time, Space: SpaceTree.Space, Name: NameTree.Name, Ref: ref, Mov: mov};}}/**** Given a three trees of nested javascript objects, one holding time data, one holding* movement data, and one holding part name data** @method getNameList* @for renderGlobal* @param {Object} TimeTree The root node of the tree containing time data* @param {Object} SpaceTree The root node of the tree containing movement data* @param {Object} NameTree The root node of the tree containing name data* @return {Object} The root node of the resulting tree* */function getNameList(theTree){if(theTree==null){return [];}else{var result;if(theTree.Name===""){result=[];}else{result=[theTree.Name];}result=result.concat(getNameList(theTree.Ref));result=result.concat(getNameList(theTree.Mov));return result;}}/**** Given an array of strings, returns the first index at which at least * two of the included strings are different** @method similarityCutoff* @for renderGlobal* @param {Array} theList The list of strings to be anylized* @return {Index} The computed index* */function similarityCutoff(theList){var pos;var it=1;var lim=theList[0].length;var finish=theList.length;while(it&lt;finish &amp;&amp; lim!=0){pos=0;while(pos&lt;lim){if(theList[it][pos]!=theList[0][pos]){lim=pos;}pos=pos+1;}it=it+1;}return lim;}/**** Given a tree of nested javascript objects (each with a string attribute "Name") and an* integer "N", removes the first N characters of each Name attribute** @method cutOffNames* @for renderGlobal* @param {Object} theTree The structure containing name data* @return {Void}* */function cutOffNames(theTree,theCutOff){if(theTree==null){return;}else{if(theCutOff&lt;theTree.Name.length){theTree.Name=theTree.Name.substr(theCutOff,theTree.Name.length);}cutOffNames(theTree.Ref,theCutOff);cutOffNames(theTree.Mov,theCutOff);var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){cutOffNames(theTree.Fst[pos],theCutOff)pos++;}return;}}/**** Given a tree of nested javascript objects (each with a string attribute "Name"), and two lists,* regTreeNames and fstTreeNames, inserts all regular part names into regTreeNames and inserts all* fastener part names into fstTreeNames** @method getTreeNames* @for renderGlobal* @param {Object} tree* @param {String List} regTreeNames* @param {String List} fstTreeNames* @return {Void}* */function getTreeNames(tree,regTreeNames,fstTreeNames){if(tree===null){return;}else{if(tree.Ref===null){regTreeNames.push(tree.Name);}else{getTreeNames(tree.Ref,regTreeNames,fstTreeNames);getTreeNames(tree.Mov,regTreeNames,fstTreeNames);}var pos = 0;var lim = tree.Fst.length;while(pos&lt;lim){fstTreeNames.push(tree.Fst[pos].Name);pos++;}}}/**** Given a list of parts, returns a list of the names of each part** @method getPartNames* @for renderGlobal* @param {Part List} parts The list of part objects.* @return {String List}* */function getPartNames(parts){var result = [];var pos = 0;var lim = parts.length;while(pos&lt;lim){result.push(parts[pos].Name);pos++;}return result;}/**** Given a tree of nested javascript objects (each with a float attribute "Time") and a* float "N", sets each Time value to N minus that value** @method flipTreeTime* @for renderGlobal* @param {Object} theTree The structure containing time data* @param {Float} axis The value used to mirror the time values* @return {Void}* */function flipTreeTime(theTree,axis){if(theTree==null){return;}else{theTree.Time=axis-theTree.Time;flipTreeTime(theTree.Ref,axis);flipTreeTime(theTree.Mov,axis);var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){flipTreeTime(theTree.Fst[pos],axis);pos++;}return;}}/**** Given a tree of nested javascript objects, returns the depth of the tree** @method getDepth* @for renderGlobal* @param {Object} theTree The object structure* @return {Int} The depth of the object* */function getDepth(theTree){if(theTree==null){return 0;}return 1+Math.max(getDepth(theTree.Ref, theTree.Mov));}/**** Given a staggered array of integer pairs, returns a random UTF character with a UTF value* within one of the given integer ranges (inclusive)** @method getRandomUTF* @for renderGlobal* @param {Array} selectSpace A staggered array of integer range limits* @return {Void}* */function getRandomUTF (selectSpace){if(selectSpace.length%2==1 || selectSpace.length==0){return '?';}var pos=0;var lim=selectSpace.length/2;var spaceSize=0;while(pos&lt;lim){spaceSize=spaceSize+selectSpace[pos+1]-selectSpace[pos];pos=pos+2;}var sel=Math.random() * (spaceSize);pos=0;while(sel&gt;(selectSpace[pos+1]-selectSpace[pos])){sel=sel-(selectSpace[pos+1]-selectSpace[pos]);pos=pos+2;}var result= String.fromCharCode(selectSpace[pos] + Math.random() * (selectSpace[pos+1]-selectSpace[pos]+1));return result;}/**** Given a tree of nested javascript objects and an html element, inserts the contents* of the root node of the given tree as an html element into the given element. Returns* the name of the generated node.** @method insertTreequenceHTML* @for renderGlobal* @param {Object} theTree The tree structure* @param {HTML Element} parentElement The html element to contain the node information* @return {Void}* */function insertTreequenceHTML(theTree,parentElement){if(theTree==null){return "";}var theButton=document.createElement("BUTTON");var theName="";theButton.innerHTML="-";theButton.setAttribute("onclick","swapHiding(parentElement)");theButton.setAttribute("style","background-color: #000000;\border: none;\color: white;\padding: 2px 4px 2px 4px;\text-align: center;\text-decoration: none;\display: inline-block;\font-size: 100% ;")if(theTree.Ref!=null || theTree.Mov!=null){parentElement.appendChild(theButton);}else{theName=getRandomUTF([ /*0x03B0,0x03FF,0x0531,0x0556,0x07C0,0x07EA,0x10A0,0x10C5,0x16A0,0x16EA,0x1A00,0x1A16,0x1B83,0x1BA0,0x20A0,0x20BE,0x2C00,0x2C2E,0xA500,0xA62B*/0x2600,0x2625,0x2639,0x2668,0x2690,0x269D,0x26B3,0x23BE/*0x1F300,0x1F3FA,0x1F400,0x1F4FF,0x1F600,0x1F64F,0x1F910,0x1F91E,0x1F920,0x1F927,0x1F950,0x1F95E,0x1F980,0x1F991*/]);parentElement.appendChild(document.createTextNode(theTree.Name.substring(0,theTree.Name.length-4)+"("+theName+")"));}var movName;var refName;if(theTree.Mov!=null){var theMov=document.createElement("DIV");parentElement.appendChild(theMov);movName=insertTreequenceHTML(theTree.Mov,theMov);}if(theTree.Ref!=null){var theRef=document.createElement("DIV");parentElement.appendChild(theRef);refName=insertTreequenceHTML(theTree.Ref,theRef);}if(theTree.Ref!=null || theTree.Mov!=null){theName=movName+refName;parentElement.insertBefore(document.createTextNode(" "+theName),theMov);}hideChildren(parentElement);return theName;}/**** Given an html node containing a button, hides all child treequence elements* if the button text is not "+" and shows them if it is.** @method swapHiding* @for renderGlobal* @param {HTML Element} theNode The html element whose treequence elements are to be manipulated.* @return {Void}* */function swapHiding(theNode){var buttonState=getChildrenByTag(theNode,"BUTTON");if(buttonState==null || buttonState.length&lt;1){return;}var theButton=buttonState[0];if(theButton.innerHTML=="+"){theButton.innerHTML="-";showChildren(theNode);}else{theButton.innerHTML="+";hideChildren(theNode);}}/**** Given an HTML element, sets the style attributes of that element to display it's contents.** @method show* @for renderGlobal* @param {HTML Element} theNode The HTML element to be shown.* @return {Void}* */function show(theNode){var theText=getChildrenByTag(theNode,"TEXT");theNode.setAttribute("style","display: block; position: relative; left: 15px; border-style: solid; border-color: #000000;");}/**** Given an HTML element, sets the style attributes of that element to hide it's contents.** @method hide* @for renderGlobal* @param {HTML Element} theNode The HTML element to be hidden.* @return {Void}* */function hide(theNode){var theText=getChildrenByTag(theNode,"TEXT");/*if(!(theText==null || theText.length&lt;1)){console.log("Hiding: "+theText[0].innerHTML);}*/var buttonState=getChildrenByTag(theNode,"BUTTON");if(!(buttonState==null || buttonState.length&lt;1)){buttonState[0].innerHTML='+';}theNode.setAttribute("style","display: none;");}/**** Given an HTML element, sets the style attributes of that element's children* to display their contents.** @method showChildren* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be shown.* @return {Void}* */function showChildren(theNode){var theChildren = getChildrenByTag(theNode,"DIV");var pos=0;var lim=theChildren.length;while(pos&lt;lim){show(theChildren[pos]);hideChildren(theChildren[pos]);pos++;}}/**** Given an HTML element, sets the style attributes of that element's children* to hide their contents.** @method hideChildren* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be hidden.* @return {Void}* */function hideChildren(theNode){theNode.setAttribute("style","display: block; position: relative; left: 15px; border-left: solid #000000; padding: 10px 5px 0px 5px;");var theChildren = getChildrenByTag(theNode,"DIV");var pos=0;var lim=theChildren.length;while(pos&lt;lim){hideChildren(theChildren[pos]);hide(theChildren[pos]);pos++;}}/**** Given an HTML element and a string, returns a list containing all child elements* of the given element with a tag equivalent to the given string** @method getChildrenByTag* @for renderGlobal* @param {HTML Element} theNode The HTML element whose children are to be searched* @param {String} tag The string to be used when searching for element children* @return {Void}* */function getChildrenByTag(theNode,tag){var childs=theNode.children;var pos=0;var lim=childs.length;var result=[];while(pos&lt;lim){if(childs[pos].tagName===tag){result.push(childs[pos]);}pos++;}return result;}</dataobject>
                    </data>
                </parameter>
                <parameter id="5041d54c-e007-1004-88d8-84730f2d9e5d" name="partRender">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String">;/**** Returns a normal material for meshes if the global variable "standard" is false. If "standard"* is set to true, returns a chromadepth material instead.** @method getStdMaterial* @for renderGlobal* @return {Object}* */function getStdMaterial(){if(standard === true){return new THREE.ShaderMaterial({vertexShader: document.querySelector('#chroma-vert').textContent.trim(),fragmentShader: document.querySelector('#chroma-frag').textContent.trim(),uniforms: {cameraNear: { value: camera.near },cameraFar: { value: camera.far }}});}else{return new THREE.MeshNormalMaterial({transparent: true} );}}/**** Returns a normal material for lines if the global variable "standard" is false. If "standard"* is set to true, returns a chromadepth material instead.** @method getStdMaterial* @for renderGlobal* @return {Object}* */function getStdLine(){if(standard === true){return new THREE.ShaderMaterial({vertexShader: document.querySelector('#chroma-vert').textContent.trim(),fragmentShader: document.querySelector('#chroma-frag').textContent.trim(),uniforms: {cameraNear: { value: camera.near },cameraFar: { value: camera.far }}});}else{return new THREE.LineDashedMaterial({color: 0x333333,dashSize: 50,gapSize:50})}}/**** Accepts an array of objects containing a string property called "Name" and returns* the first index where any two "Name" properties in the array have different characters.*** @method getPartNameCutoff* @for renderGlobal* @param {Object Array} partFrames An array of objects, each of which should containin* a property called "Name" with a non-null string.* @return {Int} The first index where any two "Name" properties in the array are different.* */function getPartNameCutoff(partFrames){var pos=1;var lim=partFrames.length;var checkPos;var checkLim=partFrames[0].Name.length;while(pos&lt;lim){checkPos=0;while(checkPos&lt;checkLim){if(partFrames[pos].Name[checkPos]!=partFrames[0].Name[checkPos]){checkLim=checkPos;}checkPos++;}pos++;}return checkLim;}/**** Accepts an array of objects containing a string property called "Name" removes* the first N characters in each string, where N is the first index where any two* "Name" properties in the array have different characters.*** @method cutoffPartNames* @for renderGlobal* @param {Object Array} partFrames An array of objects, each of which should containin* a property called "Name" with a non-null string.* @return {Void}* */function cutoffPartNames(partFrames){var cut=getPartNameCutoff(partFrames);var pos=0;var lim=partFrames.length;while(pos&lt;lim){partFrames[pos].Name=partFrames[pos].Name.substr(cut,partFrames[pos].Name.length-(cut+4));pos++;}}/**** Finds the average position of all the vertices in a given threeJS Geometry model.** @method centerGeometry* @for renderGlobal* @param {threeJS Geometry Object} theGeo* @return {threeJS Vector3 Object} A 3d coordinate, with each component being the unweighted* average of the corresponding component in each vector in the provided geometry object. If nodeName* vertices are present in the object, a zeroed vector is returned.* */function centerGeometry(theGeo){var verts=theGeo.vertices;var pos=0;var lim=verts.length;var avgX=0;var avgY=0;var avgZ=0;if(lim==0){return new THREE.Vector3(avgX,avgY,avgZ);}while(pos&lt;lim){avgX+=verts[pos].x;avgY+=verts[pos].y;avgZ+=verts[pos].z;pos++;}avgX/=lim;avgY/=lim;avgZ/=lim;pos=0;while(pos&lt;lim){verts[pos].x-=avgX;verts[pos].y-=avgY;verts[pos].z-=avgZ;pos++;}return new THREE.Vector3(avgX,avgY,avgZ);}/**** Accepts a list of binary stl buffer objects and returns a corresponding list* of ThreeJS objects.** @method getGeometries* @for renderGlobal * @param {Buffer Object List} theSTLs* @return {ThreeJS Object List}* */function getGeometries(theSTLs){var result=[];var pos=0;var lim=theSTLs.length;while(pos&lt;lim){result.push(parseStlBinary(theSTLs[pos]));pos++;}return result;}/**** Combines a given array of objects (each associating an array of keyframes to name) with a * given array of objects (each associating a threeJS mesh with a name), creating an array* of objects with keyFrame arrays and threeJS meshes associated with the same name** @method bindPartsToKeyFrames* @for renderGlobal* @param {Array} theKeyFrameLists An array of objects, each containing an array of keyframe objects * called "Frames" and a string property called "Name")* @param {Array} theParts An array of objects, each containing a threeJS mesh object called "Mesh" and* a string property called "Name"* @return {Array} **/function bindPartsToKeyFrames(theKeyFrameLists, theParts){var pos=0;var searchPos;var lim=theKeyFrameLists.length;var searchLim=theParts.length;var result=[];while(pos&lt;lim){searchPos=0;while(searchPos&lt;searchLim){if(theKeyFrameLists[pos].Name===theParts[searchPos].Name || theKeyFrameLists[pos].Name+".STL"===theParts[searchPos].Name || theKeyFrameLists[pos].Name===theParts[searchPos].Name+".STL"){ break;}searchPos++;}if(searchPos==searchLim){pos++;continue;}theParts[searchPos].Mesh.material.transparent = true;console.log(theParts[searchPos].Mesh);result.push({Name: theKeyFrameLists[pos].Name,Frames: theKeyFrameLists[pos].Frames,Mesh: theParts[searchPos].Mesh});/*console.log({Name: theKeyFrameLists[pos].Name,Frames: theKeyFrameLists[pos].Frames,Mesh: theParts[searchPos].Mesh});*/pos++;}flipTheTimes(result);return result;}/**** Combines a jagged array of objects, each object at least possessing a numeric* property called "Time", returns the value of the greatest "Time" property** @method longestTimeFromFrames* @for renderGlobal* @param {Array} partFrames The jagged array* @return {Int} The greatest "Time" value in the jagged array**/function longestTimeFromFrames(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var best=0;while(x&lt;xLim){y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){best=Math.max(best,partFrames[x].Frames[y].Time);y++;}x++;}return best;}/**** Given a jagged array of objects, each object at least possessing a numeric* property called "Time", sets each Time property to the greatest Time value in* the jagged array minus the origional value, thus effectively reversing the* temporal order of each object** @method flipTheTimes* @for renderGlobal* @param {Array} partFrames The jagged array* @return {Int} The greatest "Time" value in the jagged array**/function flipTheTimes(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var tFlip=longestTimeFromFrames(partFrames);while(x&lt;xLim){y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){partFrames[x].Frames[y].Time=tFlip-partFrames[x].Frames[y].Time;y++;}partFrames[x].Frames.reverse();x++;}return;}/**** Logs the contents of the given jagged array of keyFrame objects, each containing numeric properties "X",* "Y", "Z", and "Time", to the console as a string.** @method showFrames* @for renderGlobal* @param {Array} partFrames A jagged array of keyframe objects* @return {Void}**/function showFrames(partFrames){var x=0;var y;var xLim=partFrames.length;var yLim;var tFlip=longestTimeFromFrames(partFrames);var timeList;var listList=[];while(x&lt;xLim){timeList=[];y=0;yLim=partFrames[x].Frames.length;while(y&lt;yLim){theFrame=partFrames[x].Frames[y];timeList.push("X: "+theFrame.Position.x+" Y: "+theFrame.Position.y+" Z: "+theFrame.Position.z+" Time: "+theFrame.Time);y++;}listList.push(timeList);x++;}return;}/**** Logs the contents of a given keyFrame object, containing numeric properties "X",* "Y", "Z", and "Time", to the console as a string.** @method showFrame* @for renderGlobal* @param {Array} theFrame the keyFrame object to be logged* @return {Void}**/function sayFrame(theFrame){console.log("X: "+theFrame.Position.x+" Y: "+theFrame.Position.y+" Z: "+theFrame.Position.z+" Time: "+theFrame.Time);}/**** Returns true if any position component of the given keyframe object is NaN** @method hasNaN* @for renderGlobal* @param {Object} theFrame A keyFrame object* @return {Boolean}**/function hasNaN(theFrame){return (isNaN(theFrame.Position.x) || isNaN(theFrame.Position.y) || isNaN(theFrame.Position.z));}/**** Returns a copy of the provided keyframe object** @method copyFrame* @for renderGlobal* @param {Object} theFrame A keyFrame object* @return {Object} The copy**/function copyFrame(theFrame){var result={Quat: new THREE.Quaternion(0,0,0,0),Position: null,Time: null,Alpha: 1.0}result.Quat.copy(theFrame.Quat);result.Position=theFrame.Position.clone();result.Time=theFrame.Time;result.Alpha = theFrame.Alpha;return result;}/**** Returns a copy of the provided array of keyframe objects** @method copyFrameList* @for renderGlobal* @param {Array} partFrames A keyFrame object array* @return {Array} The copy**/function copyFrameList (theFrameList){var pos=0;var lim=theFrameList.length;var result=[];while(pos&lt;lim){result.push(copyFrame(theFrameList[pos]));pos++;}return result;}/**** Creates a keyframe list for the given fastener object and adds it to currentFrameList** @method makeFastenerKeyFrames* @for renderGlobal * @param {Object} theFst The object representation of the fastener being keyframed* @param {Object List} runningList The current running list of keyframes* @param {Object List} currentFrameList The list of part-keyframe list objects* @return {Void}* */function makeFastenerKeyFrames(theFst,runningList,currentFrameList){var newQuat= new THREE.Quaternion();newQuat.setFromEuler(new THREE.Euler(0,0,0,'XYZ'));var presentFrame={Quat: newQuat, Position: new THREE.Vector3(theFst.X,theFst.Y,theFst.Z),Time: theFst.Time};runningList.push(presentFrame);var copiedList= copyFrameList(runningList);if(copiedList.length===1){copiedList.length = 2;copiedList[1] = copiedList[0];copiedList[0] = {Quat: newQuat, Position: new THREE.Vector3(0.0,0.0,0.0),Time: 0.00};}currentFrameList.push({Name: theFst.Name, Frames: copiedList});console.log({Name: theFst.Name, Frames: copiedList});runningList.pop();return;}/**** Given a tree representation of the assembly process through nested javascript objects, returns an array* of keyframe array objects, with each keyframe array object being a representation of the movement of each part * in the tree representation throughout the assembly proceess, with a list of keyframe objects and a given part name** @method makeKeyFrames* @for renderGlobal* @param {Object} theTree Tree representation of the assembly process through nested javascript objects* @param {Array} runningList Internally used variable. Should be an empty array for outside use.* @param {Array} currentFrameList Internally used variable. Should be an empty array for outside use.* @return {Array} The jagged array of keyFrame objects**/function makeKeyFrames(theTree, runningList, currentFrameList){var isRoot=0;if(runningList.length==0){isRoot=1;/*console.log("ROOT");console.log(theTree);*/}var newQuat= new THREE.Quaternion();newQuat.setFromEuler(new THREE.Euler(0,0,0,'XYZ'));var presentFrame = {Quat: newQuat, Position: new THREE.Vector3(theTree.X,theTree.Y,theTree.Z),Time: theTree.Time,Alpha: 1.0};runningList.push(presentFrame);if(theTree.Ref === null){var copiedList= copyFrameList(runningList);currentFrameList.push({Name: theTree.Name, Frames: copiedList});runningList.pop();}else{makeKeyFrames(theTree.Ref,runningList,currentFrameList);makeKeyFrames(theTree.Mov,runningList,currentFrameList);runningList.pop();}var pos = 0;var lim = theTree.Fst.length;while(pos&lt;lim){makeFastenerKeyFrames(theTree.Fst[pos],runningList,currentFrameList);pos++;}if(isRoot===1){return currentFrameList;}return;}/**** Given two keyFrames and a normalized float "proportion", returns an interpolation* between the two keyframes with a weight towards the second keyframe proportional* to "proportion"** @method interpolate* @for renderGlobal* @param {Object} keyFrame1 The earlier keyFrame* @param {Object} keyFrame2 The later keyFrame* @param {Float} proportion A normalized value representing what proportion of the path of* interpolation is between the result and the earlier keyFrame* @return {Object} The jagged array of keyFrame objects**/function interpolate(keyFrame1, keyFrame2, proportion){var result={ Quat: new THREE.Quaternion(), Position: new THREE.Vector3(0,0,0), Time: null, Alpha: 1.0 };THREE.Quaternion.slerp (keyFrame1.Quat, keyFrame2.Quat, result.Quat, proportion);result.Position.x=keyFrame1.Position.x*(1-proportion)+keyFrame2.Position.x*proportion;result.Position.y=keyFrame1.Position.y*(1-proportion)+keyFrame2.Position.y*proportion;result.Position.z=keyFrame1.Position.z*(1-proportion)+keyFrame2.Position.z*proportion;result.Time=keyFrame1.Time*(1-proportion)+keyFrame2.Time*proportion;result.Alpha=keyFrame1.Alpha*(1-proportion)+keyFrame2.Alpha*proportion;/*if(hasNaN(result)){console.log("vvvvvvvvvvvv");console.log("Prop: "+proportion);sayFrame(keyFrame1);sayFrame(keyFrame2);sayFrame(result);console.log("^^^^^^^^^^^^");}*/return result;}/**** Given a list of keyframes and a time quantity, returns a keyframe object interpolating* between the two temporally closest keyframes. In cases where the provide time is beyond the* range of times represented by the list, returns the closest keyframe** @method grabInterp* @for renderGlobal* @param {Array} frameList A list of keyframes. Must be organized from least time value to greatest time value* @param {Float} time Floating-point representation of what time in the keyframe progression the interpolation* should occur* @return {Object} The interpolated keyframe**/function grabInterp(frameList, time){var pos=0;var lim=frameList.length;while((pos&lt;lim) &amp;&amp; (time&gt;frameList[pos].Time)){pos++; }/*if(pos&lt;lim){timeReport=timeReport+" -&gt; "+time+" &lt;- "+frameList[pos].Time.toString();}else{timeReport=timeReport+" -&gt; "+frameList[lim-1].Time.toString()+" -&gt; "+time;}console.log(timeReport);*/if(pos==0){var theResult= copyFrame(frameList[0]);}else if(pos==lim){var theResult= copyFrame(frameList[lim-1]);}else{var prop=(time-frameList[pos-1].Time)/(frameList[pos].Time-frameList[pos-1].Time);var theResult=interpolate(frameList[pos-1],frameList[pos],prop);}return theResult;}/**** Given an array of objects (each containing a threeJS mesh object and an array of * keyFrame objects), and two floating points "time" and "timeWarp", will animate each* mesh in the array along the keyframes in their associate objects according to the * given "time" and returns the new time as given by the standard time step multiplied* by "timeWarp" ** @method animate* @for renderGlobal* @param {Array} partFrames List of objects relating threeJS mesh objects with their * respective keyframe arrays * @param {Float} time The time to be used when interpolating keyFrames for the models* @param {Float} timeWarp The coefficeint to be applied to the timestep in the* animation* @return {Float} The new value of time in the animation**/function animate(partFrames, time, timeWarp){var pos=0;var lim=partFrames.length;var interp;var eul= new THREE.Euler();var delt=new THREE.Vector3();while(pos&lt;lim){interp=grabInterp(partFrames[pos].Frames,time,partFrames[pos].Mesh.position);eul.setFromQuaternion(interp.Quat);partFrames[pos].Mesh.rotation.x=eul.x;partFrames[pos].Mesh.rotation.y=eul.y;partFrames[pos].Mesh.rotation.z=eul.z;partFrames[pos].Mesh.position.x=interp.Position.x;partFrames[pos].Mesh.position.y=interp.Position.y;partFrames[pos].Mesh.position.z=interp.Position.z;partFrames[pos].Mesh.material.opacity = interp.Alpha;pos++;}var timeStep=timeWarp/60;time+=timeStep;return time;}/**** Given two threeJS boundingBox objects, returns the smallest bounding box* encompassing the two** @method combineBounds* @for renderGlobal* @param {Object} a The first bounding box* @param {Object} b The second bounding box* @return {Object} The combined bounds**/function combineBounds(a,b){var r={};r.min= new THREE.Vector3();r.max= new THREE.Vector3();r.min.x = Math.min(a.min.x,b.min.x);r.max.x= Math.max(a.max.x,b.max.x);r.min.y = Math.min(a.min.y,b.min.y);r.max.y= Math.max(a.max.y,b.max.y);r.min.z = Math.min(a.min.z,b.min.z);r.max.z= Math.max(a.max.z,b.max.z);return r;}/**** Given two threeJS boundingBox objects, returns the smallest bounding box* encompassing the two** @method getGlobBounds* @for renderGlobal* @param {Object} a The first bounding box* @param {Object} b The second bounding box* @return {Object} The combined bounds**/function getGlobBounds(partFrames){partFrames[0].Mesh.geometry.computeBoundingBox();var runningBound=partFrames[0].Mesh.geometry.boundingBox;var pos=1;var lim=partFrames.length;while(pos&lt;lim){partFrames[pos].Mesh.geometry.computeBoundingBox();runningBound=combineBounds(runningBound,partFrames[pos].Mesh.geometry.boundingBox);pos++;}return runningBound;}/**** Given an object, containing a threeJS mesh object as "Mesh", will* return the center of the mesh's bounding box** @method getPartCenter* @for renderGlobal* @param {Object} a The object containing the threeJS mesh object* @return {Object} The center of the mesh's bounding box, represented as* a threeJS Vector3 object**/function getPartCenter(part){part.Mesh.geometry.computeBoundingBox();var bound=part.Mesh.geometry.boundingBox;var center= new THREE.Vector3((bound.min.x+bound.max.x)/2,(bound.min.y+bound.max.y)/2,(bound.min.z+bound.max.z)/2);center.x+=part.Mesh.position.x;center.y+=part.Mesh.position.y;center.z+=part.Mesh.position.z;return center;}/**** Aligns the camera to look at the point at the average of the centers of all the parts bounding boxes* @method alignAssemblyCenter* @for renderGlobal* @return {Void}* */function alignAssemblyCenter(){var pos = 0;var lim = partFrames.length;var result = new THREE.Vector3(0,0,0);while(pos&lt;lim){result.add(getPartCenter(partFrames[pos]));pos++;}result.divideScalar(partFrames.length);result.sub(camera.position);result.normalize();camYaw = Math.atan2(result.x,result.z) - Math.PI;camPitch = Math.atan2(Math.pow(result.x*result.x+result.z*result.z,0.5),result.y);}/**** Given a threeJS scene object, a threeJS camera object, and an array of objects containing* threeJS mesh objects, finds the first mesh in the scene which is intersected the ray extending* through the center of the camera's field of vision. If this mesh is in the provided array of * objects, then that object is returned, otherwise null is returned instead** @method getFirstIntersect* @for renderGlobal* @param {Object} theScene The threeJS scene object in which intersections should* be tested* @param {Object} theCamera The threeJS camera object to be used to test for * ray intersections* @param {Array} partFrames An array containing a series of objects, each of which* contain a threeJS mesh object (under the property "Mesh") to be tested for intersections* @return {Object} The intersecting mesh (or null in case of no valid intersection)**/function getFirstIntersect(theScene, theCamera, partFrames){var caster= new THREE.Raycaster();var mousePos= new THREE.Vector2(0,0);caster.setFromCamera(mousePos,theCamera);var intersectList=caster.intersectObjects(theScene.children);if(intersectList.length===0){return null;}else{var pos=0;var lim=partFrames.length;var part=intersectList[0].object;while(pos&lt;lim){if(part===partFrames[pos].Mesh){return partFrames[pos];}pos++;}return null;}}/**** Given an tree representation of the movement of parts in an assembly sequence, the* parent node of that node, and a threeJS scene object, inserts a line for each subassembly* path along the path of movement** @method addLines* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Object} parentNode Used for internal use. Null should be applied for external use.* @param {Object} theScene the threeJS scene to which the line representations will be added* @return {Void}**/function addLines(movTree,parentNode,theScene,isMov){if(movTree==null){return;}else{if(parentNode!=null){var theGeo=new THREE.Geometry();var startP=new THREE.Vector3(movTree.X,movTree.Y,movTree.Z);var endP=new THREE.Vector3(parentNode.X,parentNode.Y,parentNode.Z);theGeo.vertices=[startP,endP];movTree.Line= new THREE.LineSegments(theGeo,getStdLine());theScene.add(movTree.Line);}else{movTree.Line= null;}addLines(movTree.Ref,movTree,theScene,false);addLines(movTree.Mov,movTree,theScene,true);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){if(isMov || parentNode != null){addLines(movTree.Fst[pos],parentNode,theScene,false);}else{addLines(movTree.Fst[pos],movTree,theScene,false);}pos++;}return;}}/**** Given an tree representation of the movement of parts in an assembly sequence, an * array of Objects each associating a list of keyframes with a threeJS mesh object and aLinkcolor* string, and the index of the keyframe associated with the tree's root node, displaces the movement* line points associated with that particular part of the assembly to match the displacement of the* model** @method addDisplacement* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Array} partFrames An array of Objects each associating a list of keyframes with a threeJS* mesh object and a string* @param {Object} it The index of the keyframe associated with the root node of movTree. Used internally.* For external use, apply 0.* @return {Void}**/function addDisplacement(movTree, partFrames, it){if(movTree==null){return;}else{var ref=addDisplacement(movTree.Ref,partFrames,it);if(ref!=null){var mov=addDisplacement(movTree.Mov, partFrames, ref);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){mov = addDisplacement(movTree.Fst[pos], partFrames, mov);pos++;}it=mov;}if(mov==null || ref==null){movTree.Disp=getPartCenter(partFrames[it]);it++;}else{movTree.Disp=new THREE.Vector3(0,0,0);movTree.Disp.lerpVectors(movTree.Ref.Disp,movTree.Mov.Disp,0.5);}if(movTree.Line!=null){movTree.Line.geometry.vertices[0].addVectors(movTree.Line.geometry.vertices[0],movTree.Disp);movTree.Line.geometry.vertices[1].addVectors(movTree.Line.geometry.vertices[1],movTree.Disp);}return it;}}/**** Given an tree representation of the movement of parts in an assembly sequence, the* parent node of that node, and the current time in the animation, updates the ends of the* movement lines such that the portion of lines which have already been traversed are not shown** @method updateLines* @for renderGlobal* @param {Object} movTree Tree of nested objects representing the movement of each subassembly* in it's assembly sequence* @param {Object} parentNode Used for internal use. Null should be applied for external use.* @param {Object} theTime the threeeJS scene to which the line representations will be added* @return {Void}**/function updateLines(movTree,parentNode,theTime, isMov){if(movTree==null){return;}else{if(movTree.Line!=null &amp;&amp; parentNode!=null){if(theTime&lt;=parentNode.Time){if(theTime&gt;=movTree.Time){var normTime=(parentNode.Time-theTime)/(parentNode.Time-movTree.Time);movTree.Line.geometry.vertices[0].x=(movTree.X+movTree.Disp.x)*(normTime)+(parentNode.X+movTree.Disp.x)*(1-normTime);movTree.Line.geometry.vertices[0].y=(movTree.Y+movTree.Disp.y)*(normTime)+(parentNode.Y+movTree.Disp.y)*(1-normTime);movTree.Line.geometry.vertices[0].z=(movTree.Z+movTree.Disp.z)*(normTime)+(parentNode.Z+movTree.Disp.z)*(1-normTime);}else{movTree.Line.geometry.vertices[0].x=movTree.X+movTree.Disp.x;movTree.Line.geometry.vertices[0].y=movTree.Y+movTree.Disp.y;movTree.Line.geometry.vertices[0].z=movTree.Z+movTree.Disp.z;}}else{movTree.Line.geometry.vertices[0]=movTree.Line.geometry.vertices[1].clone();}movTree.Line.geometry.verticesNeedUpdate=true;}updateLines(movTree.Ref,movTree,theTime,false);updateLines(movTree.Mov,movTree,theTime,true);var pos = 0;var lim = movTree.Fst.length;while(pos&lt;lim){if( parentNode != null ){updateLines(movTree.Fst[pos],parentNode,theTime,false);}else{updateLines(movTree.Fst[pos],movTree,theTime,false);}pos++;}return;}}/**** Initializes the axis lines for the bottom-left of the screen** @method initAxisLines* @for renderGlobal* @return {Void}**/function initAxisLines(){theXAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0xff0000, depthTest: false }));theXAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theXAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theXAxis.frustumCulled = false;theYAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x00ff00, depthTest: false }));theYAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theYAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theYAxis.frustumCulled = false;theZAxis = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x0000ff, depthTest: false }));theZAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theZAxis.geometry.vertices.push(new THREE.Vector3(0,0,0));theZAxis.frustumCulled = false;xRet = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x000000 }));xRet.geometry.vertices.push(new THREE.Vector3(0,0,0));xRet.geometry.vertices.push(new THREE.Vector3(0,0,0));xRet.frustumCulled = false;yRet = new THREE.Line( new THREE.Geometry(), new THREE.LineBasicMaterial({color: 0x000000 }));yRet.geometry.vertices.push(new THREE.Vector3(0,0,0));yRet.geometry.vertices.push(new THREE.Vector3(0,0,0));yRet.frustumCulled = false;scene.add(theXAxis);scene.add(theYAxis);scene.add(theZAxis);scene.add(xRet);scene.add(yRet);}/**** Updates the axis line dispay** @method updateAxisLines* @for renderGlobal* @return {Void}**/function updateAxisLines(){var theRot= new THREE.Quaternion(0,0,0,0);theRot.setFromEuler(camera.rotation);var theDir= new THREE.Vector3(-3,-3,-5);var retX0= new THREE.Vector3(-0.3,0,-5);var retX1= new THREE.Vector3(0.3,0,-5);var retY0= new THREE.Vector3(0,-0.08,-5);var retY1= new THREE.Vector3(0,0.08,-5);theDir.applyQuaternion(theRot);retX0.applyQuaternion(theRot);retX1.applyQuaternion(theRot);retY0.applyQuaternion(theRot);retY1.applyQuaternion(theRot);var thePosition = camera.position.clone();thePosition.add(theDir);theXAxis.geometry.vertices[0].copy(thePosition);theXAxis.geometry.vertices[0].x-=0.5;theXAxis.geometry.vertices[1].copy(thePosition);theXAxis.geometry.vertices[1].x+=1;theXAxis.geometry.verticesNeedUpdate=true;theYAxis.geometry.vertices[0].copy(thePosition);theYAxis.geometry.vertices[0].y-=0.5;theYAxis.geometry.vertices[1].copy(thePosition);theYAxis.geometry.vertices[1].y+=1;theYAxis.geometry.verticesNeedUpdate=true;theZAxis.geometry.vertices[0].copy(thePosition);theZAxis.geometry.vertices[0].z-=0.5;theZAxis.geometry.vertices[1].copy(thePosition);theZAxis.geometry.vertices[1].z+=1;theZAxis.geometry.verticesNeedUpdate=true;thePosition.copy(camera.position);thePosition.add(retX0);xRet.geometry.vertices[0].copy(thePosition);thePosition.copy(camera.position);thePosition.add(retX1);xRet.geometry.vertices[1].copy(thePosition);xRet.geometry.verticesNeedUpdate=true;thePosition.copy(camera.position);thePosition.add(retY0);yRet.geometry.vertices[0].copy(thePosition);thePosition.copy(camera.position);thePosition.add(retY1);yRet.geometry.vertices[1].copy(thePosition);yRet.geometry.verticesNeedUpdate=true;}/**** Performs a bezier curve interpolation of the control points in pointlist given * the time value T, and returns a ThreeJS Vector3 object with the interpolated coordinates.** @method interp * @for renderGlobal* @param {Vector3 Array} pointList A list of control points for use in interpolation.* @param {Float} T A normalized value for use as a time value in interpolation.* @return {Object}**/function interp (pointList, T){var pos = 0;var lim = pointList.length;var listCopy = [];while(pos&lt;lim){listCopy.push(pointList[pos].clone());pos++;}while(lim&gt;1){pos = 0;while(pos&lt;lim-1){listCopy[pos].lerpVectors(listCopy[pos],listCopy[pos+1],T);pos++;}delete listCopy[pos];lim--;}return listCopy[1];}/**** Returns a string describing the x, y, and z coordinates of theVec.** @method vecDesc * @for renderGlobal* @param {Vector3} theVec The ThreeJS Vector3 object to be described by the output string* @return {String}**/function vecDesc(theVec){return "X: "+theVec.x+" Y: "+theVec.y+" Z: "+theVec.z;}/**** Recursively adds Vector3 objects onto the Vector3 list, target, interpolating from startDisp* and endDisp in an arc centered at the Vector3 object center. Each layer of recursion* adds the midpoint of the arc from startDisp to endDisp until level = 0.** @method addArcSubDiv * @for renderGlobal * @param {Vector3 Array} target The list where the calculated Vector3 objects should be added* @param {Vector3} center The point which the generated arc should be centered on* @param {Vector3} startDisp The starting point of the arc* @param {Vector3} endDisp The ending point of the arc* @param {Int} level The desired levels of recursion in the point interpolation* @return {Void}**/function addArcSubDiv (target, center, startDisp, endDisp, level){var midVec = new THREE.Vector3(0,0,0);var midDisp = new THREE.Vector3(0,0,0);var startVec = new THREE.Vector3(0,0,0);var endVec = new THREE.Vector3(0,0,0);midDisp.add(startDisp);midDisp.add(endDisp);midDisp.normalize();midDisp.multiplyScalar((startDisp.length()+endDisp.length())/2);midVec.add(midDisp);midVec.add(center);startVec.add(startDisp);startVec.add(center);endVec.add(endDisp);endVec.add(center);if(level &lt;= 0){target.push(midVec);target.push(endVec);}else{addArcSubDiv(target,center,startDisp,midDisp, level-1);addArcSubDiv(target,center,midDisp,endDisp, level-1);}}/**** Returns a list of 2^(resolution+1) points which trace an arc beginning at startPoint,* terminating at endpoint, and centered around center** @method makeArcPointList* @for renderGlobal * @param {Vector3} startPoint The starting point of the arc* @param {Vector3} center The point which the generated arc should be centered on* @param {Vector3} endPoint The ending point of the arc* @param {Int} resolution The desired levels of recursion in the point interpolation* @return {Vector3 Array}**/function makeArcPointList(startPoint, center, endPoint, resolution){var pos = 0;var lim = 5;var result = [];var norm;var workVector = new THREE.Vector3 ( 0,0,0 );var crossVector = new THREE.Vector3 ( 0,0,0 );var startDisp = new THREE.Vector3 ( 0,0,0 );var endDisp = new THREE.Vector3 ( 0,0,0 );workVector.copy(endPoint);workVector.sub(center);startDisp.copy(startPoint);startDisp.sub(center);crossVector.clone(startDisp);endDisp.copy(endPoint);endDisp.sub(center);if(Math.abs(workVector.dot(crossVector)) &gt; 0.98){while(Math.abs(workVector.dot(crossVector)) &gt; 0.98){crossVector.set(Math.random()*100, Math.random()*100, Math.random()*100);}crossVector.cross(workVector);crossVector.normalize();crossVector.multiplyScalar((startDisp.length()+endDisp.length())/2);addArcSubDiv(result,center,endDisp,crossVector,resolution-1);addArcSubDiv(result,center,crossVector,startDisp,resolution-1);}else{delete crossVector;crossVector = null;addArcSubDiv(result,center,endDisp,startDisp,resolution);}return result;} /**** Adds keyframes onto the keyframe lists provided so that the keyframed parts begin their* animation at start location and move in an arc to their previously defined start position** @method addCurveKeyFrames* @for renderGlobal * @param {Object List} theFrameLists A list of keyframe lists describing the movement of 3d models* @param {Vector3} startLocation The desired new start location of the 3d models in the animation* @return {Void}**/function addCurveKeyFrames(theFrameLists, startLocation){var pos = 0;var lim = theFrameLists.length;var center = new THREE.Vector3(0,0,0);center.add(startLocation);center.multiplyScalar(0.5);pos = 0;lim = theFrameLists.length;var framePos;var frameLim;var startFrame;var theFrame;var interpPoints;var offSet;var resolution = 4;while(pos&lt;lim){interpPoints = [];startFrame = (theFrameLists[pos].Frames)[(theFrameLists[pos].Frames.length)-1];interpPoints = makeArcPointList( startLocation, center, startFrame.Position, resolution);framePos = 0;frameLim = interpPoints.length;while(framePos&lt;frameLim){theFrame = copyFrame(startFrame);theFrame.Position.copy(interpPoints[framePos]);theFrame.Time = startFrame.Time + framePos + 8;theFrame.Alpha = 1.0 - Math.pow((framePos+1)/frameLim,4);(theFrameLists[pos].Frames).push(theFrame);framePos++;}framePos = 0;frameLim = theFrameLists[pos].Frames.length;while(framePos&lt;frameLim){framePos++;}pos++;}return 8 + Math.pow(2,resolution+1);}/**** Adds a simple square grid of width equal to theSize and a number of lines equal to theDivs at Y=-1000** @method addGrid* @for renderGlobal * @param {Int} theSize The desired grid width* @param {Int} theDivs The desired number of lines per side of the grid* @return {Void}**/function addGrid(theSize, theDivs, theHeight, theColor){var xpos = 0;var zpos = 0;var theLine = null;var theGeo = new THREE.Geometry();while(xpos&lt;theDivs){theGeo.vertices.push(new THREE.Vector3(xpos*theSize/theDivs-theSize/2, theHeight , 0-theSize/2));theGeo.vertices.push(new THREE.Vector3(xpos*theSize/theDivs-theSize/2, theHeight , theSize/2));xpos++;}while(zpos&lt;theDivs){theGeo.vertices.push(new THREE.Vector3(0-theSize/2, theHeight, zpos*theSize/theDivs-theSize/2));theGeo.vertices.push(new THREE.Vector3(theSize/2, theHeight , zpos*theSize/theDivs-theSize/2));zpos++;}theLine = new THREE.LineSegments(theGeo,getStdLine());scene.add(theLine);}/**** Adds a simple vertical column with a radius of theRad, a base Y value of theBot, a top terminating at* theTop, an x and z position equal to theX and theZ, a line color of theColor, a number of vertical * segmentations equal to stacks, and a number of radial segmentations equal to slices** @method addGrid* @for renderGlobal * @param {Float} theRad The desired radius of the column* @param {Float} theBot The desired bottom y value of the column* @param {Float} theTop The desired top y value of the column* @param {Float} theX The desired x value of the column* @param {Float} theZ The desired z value of the column* @param {Float} slices The desired number of radial segmentations* @param {Float} stacks The desired z value of vertical segmentations* @param {Float} theColor The desired color of the column* @return {Void}**/function addCylender(theRad, theBot, theTop, theX, theZ, slices, stacks, theColor){var slicePos = 0;var stackPos;var theLine = null;var theGeo = new THREE.Geometry();while(slicePos&lt;slices){stackPos = 0;while(stackPos&lt;stacks+1){theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theBot*stackPos/stacks+theTop*(stacks-stackPos)/stacks, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*(slicePos+1)/slices), theBot*stackPos/stacks+theTop*(stacks-stackPos)/stacks, theZ+theRad*Math.sin(Math.PI*2*(slicePos+1)/slices) ));stackPos++;}theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theBot, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));theGeo.vertices.push(new THREE.Vector3( theX+theRad*Math.cos(Math.PI*2*slicePos/slices), theTop, theZ+theRad*Math.sin(Math.PI*2*slicePos/slices) ));slicePos++;}theLine = new THREE.LineSegments(theGeo,getStdLine());scene.add(theLine);}</dataobject>
                    </data>
                </parameter>
                <parameter id="e911d9a8-e008-1004-83dc-e6b0efb3e06a" name="outputTemplate">
                    <currentType value="String"/>
                    <data>
                        <dataobject type="String">&lt;div&gt;&lt;style&gt;{{pageStyle}}&lt;/style&gt;&lt;div id="theBody"&gt;{{pageMain}}&lt;/div&gt;&lt;script src="https:&lt;script&gt;{{pageScript}}&lt;/script&gt;&lt;/div&gt;</dataobject>
                    </data>
                </parameter>
            </parameters>
            <body><![CDATA[import sys;
import subprocess;
import os;
import string;

manFile = open("./../../workspace/bin/templates/manifest.txt","r");
manText = manFile.read();
manFile.close();
itemList = manText.splitlines();
temps = {};
for i in itemList:
	thePair = i.split(":")
	if len(thePair) != 2 :
		continue;
	theName = thePair[0];
	valFile = open("./../../workspace/bin/templates/"+thePair[1],"r");
	theVal = valFile.read();
	valFile.close();
	temps[theName] = theVal;

_jsstl = temps["jsstl"];
_treequence = temps["treequence"];
_partRender = temps["partRender"];


if InputStage == 0:
	_pageBase = temps["pageBase"];
	_pageMain = temps["uploadMain"];
	_pageUnit = "";
	_pageStyle = "";
	_pageScript = "";
	OutputStage = 0;



if InputStage == 1:
	subprocess.call("rm ./../../workspace/bin/intermediate/*",shell=True);
	subprocess.call(["./../../workspace/FastenerDetection.exe", "./../../workspace", "y", "1", "0.5", "y", "y"]);
	_pageBase = temps["pageBase"];
	_pageMain = temps["partPropMain"];
	_pageUnit = temps["partEntry"];
	_pageStyle = temps["partStyle"];
	_pageScript = temps["partScript"];
	OutputStage = 2;

if InputStage == 2:
	subprocess.call(["./../../workspace/DisassemblyDirections.exe", "./../../workspace", "y", "1", "0.5", "y", "y"]);
	_pageBase = temps["pageBase"];
	_pageMain = temps["dirConMain"];
	_pageUnit = temps["dirPair"];
	_pageStyle = temps["dirStyle"];
	_pageScript = temps["dirScript"];
	OutputStage = 3;

if InputStage == 3:
	val = subprocess.call(["./../../workspace/Verification.exe", "./../../workspace", "y", "1", "0.5", "y", "y"]);
	if val == 0:
		OutputStage = 4;
	else:
		OutputStage = 2;

if InputStage == 4:
	subprocess.call(["./../../workspace/AssemblyPlanning.exe", "./../../workspace", "y", "1", "0.5", "y", "y"]);
	_pageBase = temps["pageBase"];
	_pageMain = temps["renderMain"];
	_pageUnit = temps["renderPart"];
	_pageStyle = temps["renderStyle"];
	_pageScript = temps["renderScript"];
	OutputStage = 5;

def sanitize(s):
	lim = len(s);
	result = "";
	line = "";
	comment = False;
	slash = False;
	for i in range(0,lim):

		if( (s[i] == '\n') or (s[i] == '\r') ):
			if( len(line) > 0):
				result = result + line;
				line = "";
			comment = False;
			continue;
		
		if( (s[i] == '\t')  or  (s[i] == '\0') ):
			continue;

		if(s[i] == '/'):
			if(slash == True):
				comment = True;
				if(len(line) > 0):
					result = result + line;
					line = "";
			slash = True;		
		else:
			if(comment == False):
				if(slash == True):
					line = line + '/';
				line = line + s[i];
			slash = False;
	result = result + line;
	return result;

		
		

_pageBase = sanitize(_pageBase);
_pageMain = sanitize(_pageMain);
_pageUnit = sanitize(_pageUnit);
_pageStyle = sanitize(_pageStyle);
_jsstl = sanitize(_jsstl);
_treequence = sanitize(_treequence);
_partRender = sanitize(_partRender);
_pageScript = sanitize(_pageScript);



pageBase.value = str(_pageBase).decode('utf-8');
jsstl.value = str(_jsstl).decode('utf-8');
treequence.value = str(_treequence).decode('utf-8');
partRender.value = str(_partRender).decode('utf-8');
pageMain.value = str(_pageMain).decode('utf-8');
pageUnit.value = str(_pageUnit).decode('utf-8');
pageStyle.value = str(_pageStyle).decode('utf-8');
pageScript.value = str(_pageScript).decode('utf-8');
outputTemplate.value = str(_pageBase).decode('utf-8');]]></body>
            <dependencies>
                <dependency idRef="ed2f8a9b-dffc-1004-896f-4e4d575adaac">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="ed2f8a9c-dffc-1004-896f-4e4d575adaac">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="e911d9a8-e008-1004-83dc-e6b0efb3e06a">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="e05ae00c-e002-1004-8b78-46d8a5cbbeea">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="5041d54a-e007-1004-88d8-84730f2d9e5d">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="5041d54b-e007-1004-88d8-84730f2d9e5d">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="e05ae00d-e002-1004-8b78-46d8a5cbbeea">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="2de11d02-dff9-1004-8053-4b6b5190a41e">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="5041d54c-e007-1004-88d8-84730f2d9e5d">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
                <dependency idRef="ed2f8a9d-dffc-1004-896f-4e4d575adaac">
                    <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                </dependency>
            </dependencies>
        </relation>
    </relations>
    <visualizations/>
    <contexts>
        <context id="BUILD_CXT" name="Build View">
            <modelobjects>
                <relation name="Test Relation" idRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
                <parameter name="partRender" idRef="5041d546-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="treequence" idRef="5041d543-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="jsstl" idRef="5041d540-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="InputStage" idRef="2de11cfb-dff9-1004-8053-4b6b5190a41e" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="OutputStage" idRef="2de11cff-dff9-1004-8053-4b6b5190a41e" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="pageBase" idRef="ed2f8a8a-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="pageMain" idRef="ed2f8a8d-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="pageUnit" idRef="ed2f8a90-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="outputTemplate" idRef="ed2f8a97-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="pageStyle" idRef="e05ae006-e002-1004-8b78-46d8a5cbbeea" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
                <parameter name="pageScript" idRef="e05ae009-e002-1004-8b78-46d8a5cbbeea" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </modelobjects>
        </context>
        <context id="FILE_CXT" name="Files"/>
    </contexts>
    <mappings>
        <modelMappings>
            <mappedParameter name="pageBase" idRef="ed2f8a9b-dffc-1004-896f-4e4d575adaac" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="pageBase" idRef="ed2f8a8a-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="pageMain" idRef="ed2f8a9c-dffc-1004-896f-4e4d575adaac" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="pageMain" idRef="ed2f8a8d-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="InputStage" idRef="2de11cfb-dff9-1004-8053-4b6b5190a41e" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065">
                <parameter name="InputStage" idRef="2de11d03-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
            </mappedParameter>
            <mappedParameter name="outputTemplate" idRef="e911d9a8-e008-1004-83dc-e6b0efb3e06a" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="outputTemplate" idRef="ed2f8a97-dffc-1004-896f-4e4d575adaac" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="pageScript" idRef="e05ae009-e002-1004-8b78-46d8a5cbbeea" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065">
                <parameter name="pageScript" idRef="e05ae00d-e002-1004-8b78-46d8a5cbbeea" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
            </mappedParameter>
            <mappedParameter name="jsstl" idRef="5041d54a-e007-1004-88d8-84730f2d9e5d" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="jsstl" idRef="5041d540-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="pageStyle" idRef="e05ae00c-e002-1004-8b78-46d8a5cbbeea" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="pageStyle" idRef="e05ae006-e002-1004-8b78-46d8a5cbbeea" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="treequence" idRef="5041d54b-e007-1004-88d8-84730f2d9e5d" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="treequence" idRef="5041d543-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
            <mappedParameter name="OutputStage" idRef="2de11cff-dff9-1004-8053-4b6b5190a41e" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065">
                <parameter name="OutputStage" idRef="2de11d02-dff9-1004-8053-4b6b5190a41e" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346"/>
            </mappedParameter>
            <mappedParameter name="partRender" idRef="5041d54c-e007-1004-88d8-84730f2d9e5d" idRelationRef="1f2fbf14-dfed-1004-8be0-58277b79f346">
                <parameter name="partRender" idRef="5041d546-e007-1004-88d8-84730f2d9e5d" idModelRef="e903010b-dffa-1004-8ab4-1037084ba065"/>
            </mappedParameter>
        </modelMappings>
    </mappings>
    <auxfiles/>
</model>
