<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>workspace\templates\datatables.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-elements">Elements</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/DataTable.Api.html">DataTable.Api</a></li>
                                <li><a href="../classes/directionConfirmGlobal.html">directionConfirmGlobal</a></li>
                                <li><a href="../classes/partTableGlobal.html">partTableGlobal</a></li>
                                <li><a href="../classes/renderGlobal.html">renderGlobal</a></li>
                            </ul>
                
                                <ul id="api-elements" class="apis elements">
                                    <li><a href="../elements/inputState.html">&lt;inputState&gt;</a></li>
                                </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: workspace\templates\datatables.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * This combined file was created by the DataTables downloader builder:
 *   https://datatables.net/download
 *
 * To rebuild or modify this file with the latest versions of the included
 * software please visit:
 *   https://datatables.net/download/#dt/dt-1.10.16
 *
 * Included libraries:
 *   DataTables 1.10.16
 */

/*! DataTables 1.10.16
 * Â©2008-2017 SpryMedia Ltd - datatables.net/license
 */

/**
 * @summary     DataTables
 * @description Paginate, search and order HTML tables
 * @version     1.10.16
 * @file        jquery.dataTables.js
 * @author      SpryMedia Ltd
 * @contact     www.datatables.net
 * @copyright   Copyright 2008-2017 SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/

(function( factory ) {
	&quot;use strict&quot;;

	if ( typeof define === &#x27;function&#x27; &amp;&amp; define.amd ) {
		// AMD
		define( [&#x27;jquery&#x27;], function ( $ ) {
			return factory( $, window, document );
		} );
	}
	else if ( typeof exports === &#x27;object&#x27; ) {
		// CommonJS
		module.exports = function (root, $) {
			if ( ! root ) {
				// CommonJS environments without a window global must pass a
				// root. This will give an error otherwise
				root = window;
			}

			if ( ! $ ) {
				$ = typeof window !== &#x27;undefined&#x27; ? // jQuery&#x27;s factory checks for a global window
					require(&#x27;jquery&#x27;) :
					require(&#x27;jquery&#x27;)( root );
			}

			return factory( $, root, root.document );
		};
	}
	else {
		// Browser
		factory( jQuery, window, document );
	}
}
(function( $, window, document, undefined ) {
	&quot;use strict&quot;;

	/**
	 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	 * flexible tool, based upon the foundations of progressive enhancement,
	 * which will add advanced interaction controls to any HTML table. For a
	 * full list of features please refer to
	 * [DataTables.net](href=&quot;http://datatables.net).
	 *
	 * Note that the &#x60;DataTable&#x60; object is not a global variable but is aliased
	 * to &#x60;jQuery.fn.DataTable&#x60; and &#x60;jQuery.fn.dataTable&#x60; through which it may
	 * be  accessed.
	 *
	 *  @class
	 *  @param {object} [init={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.7+
	 *
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $(&#x27;#example&#x27;).dataTable();
	 *    } );
	 *
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $(&#x27;#example&#x27;).dataTable( {
	 *        &quot;paginate&quot;: false,
	 *        &quot;sort&quot;: false
	 *      } );
	 *    } );
	 */
	var DataTable = function ( options )
	{
		/**
		 * Perform a jQuery selector action on the table&#x27;s TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion (&quot;applied&quot;) or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either &#x27;current&#x27;, whereby the current sorting of the table is used, or
		 *    &#x27;original&#x27; whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    (&quot;current&quot;) or not (&quot;all&quot;). If &#x27;current&#x27; is given, then order is assumed to be
		 *    &#x27;current&#x27; and filter is &#x27;applied&#x27;, regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$(&#x27;tr:odd&#x27;).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;);
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Filter to rows with &#x27;Webkit&#x27; in them, add a background colour and then
		 *      // remove the filter, thus highlighting the &#x27;Webkit&#x27; rows only.
		 *      oTable.fnFilter(&#x27;Webkit&#x27;);
		 *      oTable.$(&#x27;tr&#x27;, {&quot;search&quot;: &quot;applied&quot;}).css(&#x27;backgroundColor&#x27;, &#x27;blue&#x27;);
		 *      oTable.fnFilter(&#x27;&#x27;);
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			return this.api(true).$( sSelector, oOpts );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any descendants, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful in-combination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion (&quot;applied&quot;) or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either &#x27;current&#x27;, whereby the current sorting of the table is used, or
		 *    &#x27;original&#x27; whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    (&quot;current&quot;) or not (&quot;all&quot;). If &#x27;current&#x27; is given, then order is assumed to be
		 *    &#x27;current&#x27; and filter is &#x27;applied&#x27;, regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
		 *    entry in the array.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._(&#x27;tr:first&#x27;);
		 *
		 *      // Do something useful with the data
		 *      alert( &quot;First cell is: &quot;+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Filter to &#x27;Webkit&#x27; and get all data for
		 *      oTable.fnFilter(&#x27;Webkit&#x27;);
		 *      var data = oTable._(&#x27;tr&#x27;, {&quot;search&quot;: &quot;applied&quot;});
		 *
		 *      // Do something with the data
		 *      alert( data.length+&quot; rows matched the search&quot; );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			return this.api(true).rows( sSelector, oOpts ).data();
		};
		
		
		/**
		 * Create a DataTables Api instance, with the currently selected tables for
		 * the Api&#x27;s context.
		 * @param {boolean} [traditional=false] Set the API instance&#x27;s context to be
		 *   only the table referred to by the &#x60;DataTable.ext.iApiIndex&#x60; option, as was
		 *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
		 *   or if all tables captured in the jQuery object should be used.
		 * @return {DataTables.Api}
		 */
		this.api = function ( traditional )
		{
			return traditional ?
				new _Api(
					_fnSettingsFromNode( this[ _ext.iApiIndex ] )
				) :
				new _Api( this );
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using
		 * server-side processing (i.e. &quot;bServerSide&quot;: true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} data The data to be added to the table. This can be:
		 *    &lt;ul&gt;
		 *      &lt;li&gt;1D array of data - add a single row with the data provided&lt;/li&gt;
		 *      &lt;li&gt;2D array of arrays - add multiple rows in a single call&lt;/li&gt;
		 *      &lt;li&gt;object - data object when using &lt;i&gt;mData&lt;/i&gt;&lt;/li&gt;
		 *      &lt;li&gt;array of objects - multiple data objects when using &lt;i&gt;mData&lt;/i&gt;&lt;/li&gt;
		 *    &lt;/ul&gt;
		 *  @param {bool} [redraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in
		 *    &lt;i&gt;aoData&lt;/i&gt; ({@link DataTable.models.oSettings}) that have been added to
		 *    the table.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *
		 *    $(document).ready(function() {
		 *      $(&#x27;#example&#x27;).dataTable();
		 *    } );
		 *
		 *    function fnClickAddRow() {
		 *      $(&#x27;#example&#x27;).dataTable().fnAddData( [
		 *        giCount+&quot;.1&quot;,
		 *        giCount+&quot;.2&quot;,
		 *        giCount+&quot;.3&quot;,
		 *        giCount+&quot;.4&quot; ]
		 *      );
		 *
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( data, redraw )
		{
			var api = this.api( true );
		
			/* Check if we want to add multiple rows or not */
			var rows = $.isArray(data) &amp;&amp; ( $.isArray(data[0]) || $.isPlainObject(data[0]) ) ?
				api.rows.add( data ) :
				api.row.add( data );
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return rows.flatten().toArray();
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or
		 * through the sWidth parameter). This can be useful when the width of the table&#x27;s
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;sScrollY&quot;: &quot;200px&quot;,
		 *        &quot;bPaginate&quot;: false
		 *      } );
		 *
		 *      $(window).on(&#x27;resize&#x27;, function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var api = this.api( true ).columns.adjust();
			var settings = api.settings()[0];
			var scroll = settings.oScroll;
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw( false );
			}
			else if ( scroll.sX !== &quot;&quot; || scroll.sY !== &quot;&quot; ) {
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				_fnScrollDraw( settings );
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Immediately &#x27;nuke&#x27; the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			var api = this.api( true ).clear();
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
		};
		
		
		/**
		 * The exact opposite of &#x27;opening&#x27; a row, this function will close any rows which
		 * are currently &#x27;open&#x27;.
		 *  @param {node} nTr the table row to &#x27;close&#x27;
		 *  @returns {int} 0 on success, or 1 if failed (can&#x27;t find the row)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // &#x27;open&#x27; an information row when a row is clicked on
		 *      $(&#x27;#example tbody tr&#x27;).click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
		 *        }
		 *      } );
		 *
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			this.api( true ).row( nTr ).child.hide();
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} target The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [callBack] Callback function
		 *  @param {bool} [redraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( target, callback, redraw )
		{
			var api = this.api( true );
			var rows = api.rows( target );
			var settings = rows.settings()[0];
			var data = settings.aoData[ rows[0][0] ];
		
			rows.remove();
		
			if ( callback ) {
				callback.call( this, settings, data );
			}
		
			if ( redraw === undefined || redraw ) {
				api.draw();
			}
		
			return data;
		};
		
		
		/**
		 * Restore the table to it&#x27;s original state in the DOM by removing all of DataTables
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [remove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( remove )
		{
			this.api( true ).destroy( remove );
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Re-draw the table - you wouldn&#x27;t want to do it here, but it&#x27;s an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( complete )
		{
			// Note that this isn&#x27;t an exact match to the old call to _fnDraw - it takes
			// into account the new data, but can hold position.
			this.api( true ).draw( complete );
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it&#x27;s input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( &#x27;test string&#x27; );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var api = this.api( true );
		
			if ( iColumn === null || iColumn === undefined ) {
				api.search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
			else {
				api.column( iColumn ).search( sInput, bRegex, bSmart, bCaseInsensitive );
			}
		
			api.draw();
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the
		 * provided parameters.
		 *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [col] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      oTable.$(&#x27;tr&#x27;).click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      oTable.$(&#x27;td&#x27;).click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( &#x27;The cell clicked on had the value of &#x27;+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( src, col )
		{
			var api = this.api( true );
		
			if ( src !== undefined ) {
				var type = src.nodeName ? src.nodeName.toLowerCase() : &#x27;&#x27;;
		
				return col !== undefined || type == &#x27;td&#x27; || type == &#x27;th&#x27; ?
					api.cell( src, col ).data() :
					api.row( src ).data() || null;
			}
		
			return api.data().toArray();
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table&#x27;s body. Note that you will
		 * typically want to use the &#x27;$&#x27; API method in preference to this as it is more
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table&#x27;s body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var api = this.api( true );
		
			return iRow !== undefined ?
				api.row( iRow ).node() :
				api.rows().nodes().flatten().toArray();
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it&#x27;s DOM element
		 * and column index including hidden columns
		 *  @param {node} node this can either be a TR, TD or TH in the table&#x27;s body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible),
		 *    column index (all)] is given.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $(&#x27;#example tbody td&#x27;).click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = &#x27;clicked&#x27;;
		 *        this.innerHTML = &#x27;clicked&#x27;;
		 *      } );
		 *
		 *      // Init DataTables
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( node )
		{
			var api = this.api( true );
			var nodeName = node.nodeName.toUpperCase();
		
			if ( nodeName == &#x27;TR&#x27; ) {
				return api.row( node ).index();
			}
			else if ( nodeName == &#x27;TD&#x27; || nodeName == &#x27;TH&#x27; ) {
				var cell = api.cell( node ).index();
		
				return [
					cell.row,
					cell.columnVisible,
					cell.column
				];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is &#x27;open&#x27; or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // &#x27;open&#x27; an information row when a row is clicked on
		 *      $(&#x27;#example tbody tr&#x27;).click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
		 *        }
		 *      } );
		 *
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			return this.api( true ).row( nTr ).child.isShown();
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently
		 * on display on the page, with the HTML contents that is passed into the
		 * function. This can be used, for example, to ask for confirmation that a
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to &#x27;open&#x27;
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *
		 *      // &#x27;open&#x27; an information row when a row is clicked on
		 *      $(&#x27;#example tbody tr&#x27;).click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, &quot;Temporary row opened&quot;, &quot;info_row&quot; );
		 *        }
		 *      } );
		 *
		 *      oTable = $(&#x27;#example&#x27;).dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			return this.api( true )
				.row( nTr )
				.child( mHtml, sClass )
				.show()
				.child()[0];
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API
		 * function. With this function you can have a DataTables table go to the next,
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: &quot;first&quot;, &quot;previous&quot;, &quot;next&quot; or &quot;last&quot;
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *      oTable.fnPageChange( &#x27;next&#x27; );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var api = this.api( true ).page( mAction );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw(false);
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var api = this.api( true ).column( iCol ).visible( bShow );
		
			if ( bRedraw === undefined || bRedraw ) {
				api.columns.adjust().draw();
			}
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[_ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular column
		 *  @param {int} iCol the data index to sort on. Note that this will not match the
		 *    &#x27;display index&#x27; if you have hidden data entries
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,&#x27;asc&#x27;], [1,&#x27;asc&#x27;] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			this.api( true ).order( aaSort ).draw();
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *
		 *      // Sort on column 1, when &#x27;sorter&#x27; is clicked on
		 *      oTable.fnSortListener( document.getElementById(&#x27;sorter&#x27;), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			this.api( true ).order.listener( nNode, iColumn, fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update, give as null or undefined to
		 *    update a whole row.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform pre-draw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *      oTable.fnUpdate( &#x27;Example update&#x27;, 0, 0 ); // Single cell
		 *      oTable.fnUpdate( [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], $(&#x27;tbody tr&#x27;)[0] ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var api = this.api( true );
		
			if ( iColumn === undefined || iColumn === null ) {
				api.row( mRow ).data( mData );
			}
			else {
				api.cell( mRow, iColumn ).data( mData );
			}
		
			if ( bAction === undefined || bAction ) {
				api.columns.adjust();
			}
		
			if ( bRedraw === undefined || bRedraw ) {
				api.draw();
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format &quot;X.Y.Z&quot;. Note that the
		 *    formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *  @deprecated Since v1.10
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $(&#x27;#example&#x27;).dataTable();
		 *      alert( oTable.fnVersionCheck( &#x27;1.9.0&#x27; ) );
		 *    } );
		 */
		this.fnVersionCheck = _ext.fnVersionCheck;
		

		var _that = this;
		var emptyInit = options === undefined;
		var len = this.length;

		if ( emptyInit ) {
			options = {};
		}

		this.oApi = this.internal = _ext.internal;

		// Extend with old style plug-in API methods
		for ( var fn in DataTable.ext.internal ) {
			if ( fn ) {
				this[fn] = _fnExternApiFunc(fn);
			}
		}

		this.each(function() {
			// For each initialisation we want to give it a clean initialisation
			// object that can be bashed around
			var o = {};
			var oInit = len &gt; 1 ? // optimisation for single table case
				_fnExtend( o, options, true ) :
				options;

			/*global oInit,_that,emptyInit*/
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( &#x27;id&#x27; );
			var bInitHandedOff = false;
			var defaults = DataTable.defaults;
			var $this = $(this);
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != &#x27;table&#x27; )
			{
				_fnLog( null, 0, &#x27;Non-table node initialisation (&#x27;+this.nodeName+&#x27;)&#x27;, 2 );
				return;
			}
			
			/* Backwards compatibility for the defaults */
			_fnCompatOpts( defaults );
			_fnCompatCols( defaults.column );
			
			/* Convert the camel-case defaults to Hungarian */
			_fnCamelToHungarian( defaults, defaults, true );
			_fnCamelToHungarian( defaults.column, defaults.column, true );
			
			/* Setting up the initialisation object */
			_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ) );
			
			
			
			/* Check to see if we are re-initialising a table */
			var allSettings = DataTable.settings;
			for ( i=0, iLen=allSettings.length ; i&lt;iLen ; i++ )
			{
				var s = allSettings[i];
			
				/* Base check on table node */
				if ( s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot &amp;&amp; s.nTFoot.parentNode == this) )
				{
					var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
					var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
			
					if ( emptyInit || bRetrieve )
					{
						return s.oInstance;
					}
					else if ( bDestroy )
					{
						s.oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( s, 0, &#x27;Cannot reinitialise DataTable&#x27;, 3 );
						return;
					}
				}
			
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don&#x27;t match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( s.sTableId == this.id )
				{
					allSettings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null || sId === &quot;&quot; )
			{
				sId = &quot;DataTables_Table_&quot;+(DataTable.ext._unique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				&quot;sDestroyWidth&quot;: $this[0].style.width,
				&quot;sInstance&quot;:     sId,
				&quot;sTableId&quot;:      sId
			} );
			oSettings.nTable = this;
			oSettings.oApi   = _that.internal;
			oSettings.oInit  = oInit;
			
			allSettings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
			
			// Backwards compatibility, before we apply all the defaults
			_fnCompatOpts( oInit );
			
			if ( oInit.oLanguage )
			{
				_fnLanguageCompat( oInit.oLanguage );
			}
			
			// If the length menu is given, but the init display length is not, use the length menu
			if ( oInit.aLengthMenu &amp;&amp; ! oInit.iDisplayLength )
			{
				oInit.iDisplayLength = $.isArray( oInit.aLengthMenu[0] ) ?
					oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
			}
			
			// Apply the defaults and init options to make a single init object will all
			// options defined from defaults and instance options.
			oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
			
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, [
				&quot;bPaginate&quot;,
				&quot;bLengthChange&quot;,
				&quot;bFilter&quot;,
				&quot;bSort&quot;,
				&quot;bSortMulti&quot;,
				&quot;bInfo&quot;,
				&quot;bProcessing&quot;,
				&quot;bAutoWidth&quot;,
				&quot;bSortClasses&quot;,
				&quot;bServerSide&quot;,
				&quot;bDeferRender&quot;
			] );
			_fnMap( oSettings, oInit, [
				&quot;asStripeClasses&quot;,
				&quot;ajax&quot;,
				&quot;fnServerData&quot;,
				&quot;fnFormatNumber&quot;,
				&quot;sServerMethod&quot;,
				&quot;aaSorting&quot;,
				&quot;aaSortingFixed&quot;,
				&quot;aLengthMenu&quot;,
				&quot;sPaginationType&quot;,
				&quot;sAjaxSource&quot;,
				&quot;sAjaxDataProp&quot;,
				&quot;iStateDuration&quot;,
				&quot;sDom&quot;,
				&quot;bSortCellsTop&quot;,
				&quot;iTabIndex&quot;,
				&quot;fnStateLoadCallback&quot;,
				&quot;fnStateSaveCallback&quot;,
				&quot;renderer&quot;,
				&quot;searchDelay&quot;,
				&quot;rowId&quot;,
				[ &quot;iCookieDuration&quot;, &quot;iStateDuration&quot; ], // backwards compat
				[ &quot;oSearch&quot;, &quot;oPreviousSearch&quot; ],
				[ &quot;aoSearchCols&quot;, &quot;aoPreSearchCols&quot; ],
				[ &quot;iDisplayLength&quot;, &quot;_iDisplayLength&quot; ]
			] );
			_fnMap( oSettings.oScroll, oInit, [
				[ &quot;sScrollX&quot;, &quot;sX&quot; ],
				[ &quot;sScrollXInner&quot;, &quot;sXInner&quot; ],
				[ &quot;sScrollY&quot;, &quot;sY&quot; ],
				[ &quot;bScrollCollapse&quot;, &quot;bCollapse&quot; ]
			] );
			_fnMap( oSettings.oLanguage, oInit, &quot;fnInfoCallback&quot; );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, &#x27;aoDrawCallback&#x27;,       oInit.fnDrawCallback,      &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoServerParams&#x27;,       oInit.fnServerParams,      &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoStateSaveParams&#x27;,    oInit.fnStateSaveParams,   &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoStateLoadParams&#x27;,    oInit.fnStateLoadParams,   &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoStateLoaded&#x27;,        oInit.fnStateLoaded,       &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoRowCallback&#x27;,        oInit.fnRowCallback,       &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoRowCreatedCallback&#x27;, oInit.fnCreatedRow,        &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoHeaderCallback&#x27;,     oInit.fnHeaderCallback,    &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoFooterCallback&#x27;,     oInit.fnFooterCallback,    &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoInitComplete&#x27;,       oInit.fnInitComplete,      &#x27;user&#x27; );
			_fnCallbackReg( oSettings, &#x27;aoPreDrawCallback&#x27;,    oInit.fnPreDrawCallback,   &#x27;user&#x27; );
			
			oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
			
			/* Browser support detection */
			_fnBrowserDetect( oSettings );
			
			var oClasses = oSettings.oClasses;
			
			$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
			$this.addClass( oClasses.sTable );
			
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				var tmp = $.isArray( oInit.iDeferLoading );
				oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
				oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
			}
			
			/* Language definitions */
			var oLanguage = oSettings.oLanguage;
			$.extend( true, oLanguage, oInit.oLanguage );
			
			if ( oLanguage.sUrl )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				$.ajax( {
					dataType: &#x27;json&#x27;,
					url: oLanguage.sUrl,
					success: function ( json ) {
						_fnLanguageCompat( json );
						_fnCamelToHungarian( defaults.oLanguage, json );
						$.extend( true, oLanguage, json );
						_fnInitialise( oSettings );
					},
					error: function () {
						// Error occurred loading language file, continue on as best we can
						_fnInitialise( oSettings );
					}
				} );
				bInitHandedOff = true;
			}
			
			/*
			 * Stripes
			 */
			if ( oInit.asStripeClasses === null )
			{
				oSettings.asStripeClasses =[
					oClasses.sStripeOdd,
					oClasses.sStripeEven
				];
			}
			
			/* Remove row stripe classes if they are already on the table row */
			var stripeClasses = oSettings.asStripeClasses;
			var rowOne = $this.children(&#x27;tbody&#x27;).find(&#x27;tr&#x27;).eq(0);
			if ( $.inArray( true, $.map( stripeClasses, function(el, i) {
				return rowOne.hasClass(el);
			} ) ) !== -1 ) {
				$(&#x27;tbody tr&#x27;, this).removeClass( stripeClasses.join(&#x27; &#x27;) );
				oSettings.asDestroyStripes = stripeClasses.slice();
			}
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName(&#x27;thead&#x27;);
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i&lt;iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i&lt;iLen ; i++ )
			{
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			/* HTML5 attribute detection - build an mData object automatically if the
			 * attributes are found
			 */
			if ( rowOne.length ) {
				var a = function ( cell, name ) {
					return cell.getAttribute( &#x27;data-&#x27;+name ) !== null ? name : null;
				};
			
				$( rowOne[0] ).children(&#x27;th, td&#x27;).each( function (i, cell) {
					var col = oSettings.aoColumns[i];
			
					if ( col.mData === i ) {
						var sort = a( cell, &#x27;sort&#x27; ) || a( cell, &#x27;order&#x27; );
						var filter = a( cell, &#x27;filter&#x27; ) || a( cell, &#x27;search&#x27; );
			
						if ( sort !== null || filter !== null ) {
							col.mData = {
								_:      i+&#x27;.display&#x27;,
								sort:   sort !== null   ? i+&#x27;.@data-&#x27;+sort   : undefined,
								type:   sort !== null   ? i+&#x27;.@data-&#x27;+sort   : undefined,
								filter: filter !== null ? i+&#x27;.@data-&#x27;+filter : undefined
							};
			
							_fnColumnOptions( oSettings, i );
						}
					}
				} );
			}
			
			var features = oSettings.oFeatures;
			var loadedInit = function () {
				/*
				 * Sorting
				 * @todo For modularisation (1.11) this needs to do into a sort start up handler
				 */
			
				// If aaSorting is not defined, then we use the first indicator in asSorting
				// in case that has been altered, so the default sort reflects that option
				if ( oInit.aaSorting === undefined ) {
					var sorting = oSettings.aaSorting;
					for ( i=0, iLen=sorting.length ; i&lt;iLen ; i++ ) {
						sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
					}
				}
			
				/* Do a first pass on the sorting classes (allows any size changes to be taken into
				 * account, and also will apply sorting disabled classes if disabled
				 */
				_fnSortingClasses( oSettings );
			
				if ( features.bSort ) {
					_fnCallbackReg( oSettings, &#x27;aoDrawCallback&#x27;, function () {
						if ( oSettings.bSorted ) {
							var aSort = _fnSortFlatten( oSettings );
							var sortedColumns = {};
			
							$.each( aSort, function (i, val) {
								sortedColumns[ val.src ] = val.dir;
							} );
			
							_fnCallbackFire( oSettings, null, &#x27;order&#x27;, [oSettings, aSort, sortedColumns] );
							_fnSortAria( oSettings );
						}
					} );
				}
			
				_fnCallbackReg( oSettings, &#x27;aoDrawCallback&#x27;, function () {
					if ( oSettings.bSorted || _fnDataSource( oSettings ) === &#x27;ssp&#x27; || features.bDeferRender ) {
						_fnSortingClasses( oSettings );
					}
				}, &#x27;sc&#x27; );
			
			
				/*
				 * Final init
				 * Cache the header, body and footer as required, creating them if needed
				 */
			
				// Work around for Webkit bug 83867 - store the caption-side before removing from doc
				var captions = $this.children(&#x27;caption&#x27;).each( function () {
					this._captionSide = $(this).css(&#x27;caption-side&#x27;);
				} );
			
				var thead = $this.children(&#x27;thead&#x27;);
				if ( thead.length === 0 ) {
					thead = $(&#x27;&lt;thead/&gt;&#x27;).appendTo($this);
				}
				oSettings.nTHead = thead[0];
			
				var tbody = $this.children(&#x27;tbody&#x27;);
				if ( tbody.length === 0 ) {
					tbody = $(&#x27;&lt;tbody/&gt;&#x27;).appendTo($this);
				}
				oSettings.nTBody = tbody[0];
			
				var tfoot = $this.children(&#x27;tfoot&#x27;);
				if ( tfoot.length === 0 &amp;&amp; captions.length &gt; 0 &amp;&amp; (oSettings.oScroll.sX !== &quot;&quot; || oSettings.oScroll.sY !== &quot;&quot;) ) {
					// If we are a scrolling table, and no footer has been given, then we need to create
					// a tfoot element for the caption element to be appended to
					tfoot = $(&#x27;&lt;tfoot/&gt;&#x27;).appendTo($this);
				}
			
				if ( tfoot.length === 0 || tfoot.children().length === 0 ) {
					$this.addClass( oClasses.sNoFooter );
				}
				else if ( tfoot.length &gt; 0 ) {
					oSettings.nTFoot = tfoot[0];
					_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
				}
			
				/* Check if there is data passing into the constructor */
				if ( oInit.aaData ) {
					for ( i=0 ; i&lt;oInit.aaData.length ; i++ ) {
						_fnAddData( oSettings, oInit.aaData[ i ] );
					}
				}
				else if ( oSettings.bDeferLoading || _fnDataSource( oSettings ) == &#x27;dom&#x27; ) {
					/* Grab the data from the page - only do this when deferred loading or no Ajax
					 * source since there is no point in reading the DOM data if we are then going
					 * to replace it with Ajax data
					 */
					_fnAddTr( oSettings, $(oSettings.nTBody).children(&#x27;tr&#x27;) );
				}
			
				/* Copy the data index array */
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
				/* Initialisation complete - table can be drawn */
				oSettings.bInitialised = true;
			
				/* Check if we need to initialise the table (it might not have been handed off to the
				 * language processor)
				 */
				if ( bInitHandedOff === false ) {
					_fnInitialise( oSettings );
				}
			};
			
			/* Must be done after everything which can be overridden by the state saving! */
			if ( oInit.bStateSave )
			{
				features.bStateSave = true;
				_fnCallbackReg( oSettings, &#x27;aoDrawCallback&#x27;, _fnSaveState, &#x27;state_save&#x27; );
				_fnLoadState( oSettings, oInit, loadedInit );
			}
			else {
				loadedInit();
			}
			
		} );
		_that = null;
		return this;
	};

	
	/*
	 * It is useful to have variables which are scoped locally so only the
	 * DataTables functions can access them and they don&#x27;t leak into global space.
	 * At the same time these functions are often useful over multiple files in the
	 * core and API, so we list, or at least document, all variables which are used
	 * by DataTables as private variables here. This also ensures that there is no
	 * clashing of variable names and that they can easily referenced for reuse.
	 */
	
	
	// Defined else where
	//  _selector_run
	//  _selector_opts
	//  _selector_first
	//  _selector_row_indexes
	
	var _ext; // DataTable.ext
	var _Api; // DataTable.Api
	var _api_register; // DataTable.Api.register
	var _api_registerPlural; // DataTable.Api.registerPlural
	
	var _re_dic = {};
	var _re_new_lines = /[\r\n]/g;
	var _re_html = /&lt;.*?&gt;/g;
	
	// This is not strict ISO8601 - Date.parse() is quite lax, although
	// implementations differ between browsers.
	var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
	
	// Escape regular expression special characters
	var _re_escape_regex = new RegExp( &#x27;(\\&#x27; + [ &#x27;/&#x27;, &#x27;.&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;?&#x27;, &#x27;|&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;{&#x27;, &#x27;}&#x27;, &#x27;\\&#x27;, &#x27;$&#x27;, &#x27;^&#x27;, &#x27;-&#x27; ].join(&#x27;|\\&#x27;) + &#x27;)&#x27;, &#x27;g&#x27; );
	
	// http://en.wikipedia.org/wiki/Foreign_exchange_market
	// - \u20BD - Russian ruble.
	// - \u20a9 - South Korean Won
	// - \u20BA - Turkish Lira
	// - \u20B9 - Indian Rupee
	// - R - Brazil (R$) and South Africa
	// - fr - Swiss Franc
	// - kr - Swedish krona, Norwegian krone and Danish krone
	// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	//   standards as thousands separators.
	var _re_formatted_numeric = /[&#x27;,$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
	
	
	var _empty = function ( d ) {
		return !d || d === true || d === &#x27;-&#x27; ? true : false;
	};
	
	
	var _intVal = function ( s ) {
		var integer = parseInt( s, 10 );
		return !isNaN(integer) &amp;&amp; isFinite(s) ? integer : null;
	};
	
	// Convert from a formatted number with characters other than &#x60;.&#x60; as the
	// decimal place, to a Javascript number
	var _numToDecimal = function ( num, decimalPoint ) {
		// Cache created regular expressions for speed as this function is called often
		if ( ! _re_dic[ decimalPoint ] ) {
			_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), &#x27;g&#x27; );
		}
		return typeof num === &#x27;string&#x27; &amp;&amp; decimalPoint !== &#x27;.&#x27; ?
			num.replace( /\./g, &#x27;&#x27; ).replace( _re_dic[ decimalPoint ], &#x27;.&#x27; ) :
			num;
	};
	
	
	var _isNumber = function ( d, decimalPoint, formatted ) {
		var strType = typeof d === &#x27;string&#x27;;
	
		// If empty return immediately so there must be a number if it is a
		// formatted string (this stops the string &quot;k&quot;, or &quot;kr&quot;, etc being detected
		// as a formatted number for currency
		if ( _empty( d ) ) {
			return true;
		}
	
		if ( decimalPoint &amp;&amp; strType ) {
			d = _numToDecimal( d, decimalPoint );
		}
	
		if ( formatted &amp;&amp; strType ) {
			d = d.replace( _re_formatted_numeric, &#x27;&#x27; );
		}
	
		return !isNaN( parseFloat(d) ) &amp;&amp; isFinite( d );
	};
	
	
	// A string without HTML in it can be considered to be HTML still
	var _isHtml = function ( d ) {
		return _empty( d ) || typeof d === &#x27;string&#x27;;
	};
	
	
	var _htmlNumeric = function ( d, decimalPoint, formatted ) {
		if ( _empty( d ) ) {
			return true;
		}
	
		var html = _isHtml( d );
		return ! html ?
			null :
			_isNumber( _stripHtml( d ), decimalPoint, formatted ) ?
				true :
				null;
	};
	
	
	var _pluck = function ( a, prop, prop2 ) {
		var out = [];
		var i=0, ien=a.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i&lt;ien ; i++ ) {
				if ( a[i] &amp;&amp; a[i][ prop ] ) {
					out.push( a[i][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i&lt;ien ; i++ ) {
				if ( a[i] ) {
					out.push( a[i][ prop ] );
				}
			}
		}
	
		return out;
	};
	
	
	// Basically the same as _pluck, but rather than looping over &#x60;a&#x60; we use &#x60;order&#x60;
	// as the indexes to pick from &#x60;a&#x60;
	var _pluck_order = function ( a, order, prop, prop2 )
	{
		var out = [];
		var i=0, ien=order.length;
	
		// Could have the test in the loop for slightly smaller code, but speed
		// is essential here
		if ( prop2 !== undefined ) {
			for ( ; i&lt;ien ; i++ ) {
				if ( a[ order[i] ][ prop ] ) {
					out.push( a[ order[i] ][ prop ][ prop2 ] );
				}
			}
		}
		else {
			for ( ; i&lt;ien ; i++ ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	
		return out;
	};
	
	
	var _range = function ( len, start )
	{
		var out = [];
		var end;
	
		if ( start === undefined ) {
			start = 0;
			end = len;
		}
		else {
			end = start;
			start = len;
		}
	
		for ( var i=start ; i&lt;end ; i++ ) {
			out.push( i );
		}
	
		return out;
	};
	
	
	var _removeEmpty = function ( a )
	{
		var out = [];
	
		for ( var i=0, ien=a.length ; i&lt;ien ; i++ ) {
			if ( a[i] ) { // careful - will remove all falsy values!
				out.push( a[i] );
			}
		}
	
		return out;
	};
	
	
	var _stripHtml = function ( d ) {
		return d.replace( _re_html, &#x27;&#x27; );
	};
	
	
	/**
	 * Determine if all values in the array are unique. This means we can short
	 * cut the _unique method at the cost of a single loop. A sorted array is used
	 * to easily check the values.
	 *
	 * @param  {array} src Source array
	 * @return {boolean} true if all unique, false otherwise
	 * @ignore
	 */
	var _areAllUnique = function ( src ) {
		if ( src.length &lt; 2 ) {
			return true;
		}
	
		var sorted = src.slice().sort();
		var last = sorted[0];
	
		for ( var i=1, ien=sorted.length ; i&lt;ien ; i++ ) {
			if ( sorted[i] === last ) {
				return false;
			}
	
			last = sorted[i];
		}
	
		return true;
	};
	
	
	/**
	 * Find the unique elements in a source array.
	 *
	 * @param  {array} src Source array
	 * @return {array} Array of unique items
	 * @ignore
	 */
	var _unique = function ( src )
	{
		if ( _areAllUnique( src ) ) {
			return src.slice();
		}
	
		// A faster unique method is to use object keys to identify used values,
		// but this doesn&#x27;t work with arrays or objects, which we must also
		// consider. See jsperf.com/compare-array-unique-versions/4 for more
		// information.
		var
			out = [],
			val,
			i, ien=src.length,
			j, k=0;
	
		again: for ( i=0 ; i&lt;ien ; i++ ) {
			val = src[i];
	
			for ( j=0 ; j&lt;k ; j++ ) {
				if ( out[j] === val ) {
					continue again;
				}
			}
	
			out.push( val );
			k++;
		}
	
		return out;
	};
	
	
	/**
	 * DataTables utility methods
	 * 
	 * This namespace provides helper methods that DataTables uses internally to
	 * create a DataTable, but which are not exclusively used only for DataTables.
	 * These methods can be used by extension authors to save the duplication of
	 * code.
	 *
	 *  @namespace
	 */
	DataTable.util = {
		/**
		 * Throttle the calls to a function. Arguments and context are maintained
		 * for the throttled function.
		 *
		 * @param {function} fn Function to be called
		 * @param {integer} freq Call frequency in mS
		 * @return {function} Wrapped function
		 */
		throttle: function ( fn, freq ) {
			var
				frequency = freq !== undefined ? freq : 200,
				last,
				timer;
	
			return function () {
				var
					that = this,
					now  = +new Date(),
					args = arguments;
	
				if ( last &amp;&amp; now &lt; last + frequency ) {
					clearTimeout( timer );
	
					timer = setTimeout( function () {
						last = undefined;
						fn.apply( that, args );
					}, frequency );
				}
				else {
					last = now;
					fn.apply( that, args );
				}
			};
		},
	
	
		/**
		 * Escape a string such that it can be used in a regular expression
		 *
		 *  @param {string} val string to escape
		 *  @returns {string} escaped string
		 */
		escapeRegex: function ( val ) {
			return val.replace( _re_escape_regex, &#x27;\\$1&#x27; );
		}
	};
	
	
	
	/**
	 * Create a mapping object that allows camel case parameters to be looked up
	 * for their Hungarian counterparts. The mapping is stored in a private
	 * parameter called &#x60;_hungarianMap&#x60; which can be accessed on the source object.
	 *  @param {object} o
	 *  @memberof DataTable#oApi
	 */
	function _fnHungarianMap ( o )
	{
		var
			hungarian = &#x27;a aa ai ao as b fn i m o s &#x27;,
			match,
			newKey,
			map = {};
	
		$.each( o, function (key, val) {
			match = key.match(/^([^A-Z]+?)([A-Z])/);
	
			if ( match &amp;&amp; hungarian.indexOf(match[1]+&#x27; &#x27;) !== -1 )
			{
				newKey = key.replace( match[0], match[2].toLowerCase() );
				map[ newKey ] = key;
	
				if ( match[1] === &#x27;o&#x27; )
				{
					_fnHungarianMap( o[key] );
				}
			}
		} );
	
		o._hungarianMap = map;
	}
	
	
	/**
	 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	 * created by _fnHungarianMap.
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to &#x60;true&#x60;, properties which already have a
	 *    Hungarian value in the &#x60;user&#x60; object will be overwritten. Otherwise they
	 *    won&#x27;t be.
	 *  @memberof DataTable#oApi
	 */
	function _fnCamelToHungarian ( src, user, force )
	{
		if ( ! src._hungarianMap ) {
			_fnHungarianMap( src );
		}
	
		var hungarianKey;
	
		$.each( user, function (key, val) {
			hungarianKey = src._hungarianMap[ key ];
	
			if ( hungarianKey !== undefined &amp;&amp; (force || user[hungarianKey] === undefined) )
			{
				// For objects, we need to buzz down into the object to copy parameters
				if ( hungarianKey.charAt(0) === &#x27;o&#x27; )
				{
					// Copy the camelCase options over to the hungarian
					if ( ! user[ hungarianKey ] ) {
						user[ hungarianKey ] = {};
					}
					$.extend( true, user[hungarianKey], user[key] );
	
					_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
				}
				else {
					user[hungarianKey] = user[ key ];
				}
			}
		} );
	}
	
	
	/**
	 * Language compatibility - when certain options are given, and others aren&#x27;t, we
	 * need to duplicate the values over, in order to provide backwards compatibility
	 * with older language files.
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnLanguageCompat( lang )
	{
		var defaults = DataTable.defaults.oLanguage;
		var zeroRecords = lang.sZeroRecords;
	
		/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
		 * sZeroRecords - assuming that is given.
		 */
		if ( ! lang.sEmptyTable &amp;&amp; zeroRecords &amp;&amp;
			defaults.sEmptyTable === &quot;No data available in table&quot; )
		{
			_fnMap( lang, lang, &#x27;sZeroRecords&#x27;, &#x27;sEmptyTable&#x27; );
		}
	
		/* Likewise with loading records */
		if ( ! lang.sLoadingRecords &amp;&amp; zeroRecords &amp;&amp;
			defaults.sLoadingRecords === &quot;Loading...&quot; )
		{
			_fnMap( lang, lang, &#x27;sZeroRecords&#x27;, &#x27;sLoadingRecords&#x27; );
		}
	
		// Old parameter name of the thousands separator mapped onto the new
		if ( lang.sInfoThousands ) {
			lang.sThousands = lang.sInfoThousands;
		}
	
		var decimal = lang.sDecimal;
		if ( decimal ) {
			_addNumericSort( decimal );
		}
	}
	
	
	/**
	 * Map one parameter onto another
	 *  @param {object} o Object to map
	 *  @param {*} knew The new parameter name
	 *  @param {*} old The old parameter name
	 */
	var _fnCompatMap = function ( o, knew, old ) {
		if ( o[ knew ] !== undefined ) {
			o[ old ] = o[ knew ];
		}
	};
	
	
	/**
	 * Provide backwards compatibility for the main DT options. Note that the new
	 * options are mapped onto the old parameters, so this is an external interface
	 * change only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatOpts ( init )
	{
		_fnCompatMap( init, &#x27;ordering&#x27;,      &#x27;bSort&#x27; );
		_fnCompatMap( init, &#x27;orderMulti&#x27;,    &#x27;bSortMulti&#x27; );
		_fnCompatMap( init, &#x27;orderClasses&#x27;,  &#x27;bSortClasses&#x27; );
		_fnCompatMap( init, &#x27;orderCellsTop&#x27;, &#x27;bSortCellsTop&#x27; );
		_fnCompatMap( init, &#x27;order&#x27;,         &#x27;aaSorting&#x27; );
		_fnCompatMap( init, &#x27;orderFixed&#x27;,    &#x27;aaSortingFixed&#x27; );
		_fnCompatMap( init, &#x27;paging&#x27;,        &#x27;bPaginate&#x27; );
		_fnCompatMap( init, &#x27;pagingType&#x27;,    &#x27;sPaginationType&#x27; );
		_fnCompatMap( init, &#x27;pageLength&#x27;,    &#x27;iDisplayLength&#x27; );
		_fnCompatMap( init, &#x27;searching&#x27;,     &#x27;bFilter&#x27; );
	
		// Boolean initialisation of x-scrolling
		if ( typeof init.sScrollX === &#x27;boolean&#x27; ) {
			init.sScrollX = init.sScrollX ? &#x27;100%&#x27; : &#x27;&#x27;;
		}
		if ( typeof init.scrollX === &#x27;boolean&#x27; ) {
			init.scrollX = init.scrollX ? &#x27;100%&#x27; : &#x27;&#x27;;
		}
	
		// Column search objects are in an array, so it needs to be converted
		// element by element
		var searchCols = init.aoSearchCols;
	
		if ( searchCols ) {
			for ( var i=0, ien=searchCols.length ; i&lt;ien ; i++ ) {
				if ( searchCols[i] ) {
					_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
				}
			}
		}
	}
	
	
	/**
	 * Provide backwards compatibility for column options. Note that the new options
	 * are mapped onto the old parameters, so this is an external interface change
	 * only.
	 *  @param {object} init Object to map
	 */
	function _fnCompatCols ( init )
	{
		_fnCompatMap( init, &#x27;orderable&#x27;,     &#x27;bSortable&#x27; );
		_fnCompatMap( init, &#x27;orderData&#x27;,     &#x27;aDataSort&#x27; );
		_fnCompatMap( init, &#x27;orderSequence&#x27;, &#x27;asSorting&#x27; );
		_fnCompatMap( init, &#x27;orderDataType&#x27;, &#x27;sortDataType&#x27; );
	
		// orderData can be given as an integer
		var dataSort = init.aDataSort;
		if ( typeof dataSort === &#x27;number&#x27; &amp;&amp; ! $.isArray( dataSort ) ) {
			init.aDataSort = [ dataSort ];
		}
	}
	
	
	/**
	 * Browser feature detection for capabilities, quirks
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBrowserDetect( settings )
	{
		// We don&#x27;t need to do this every time DataTables is constructed, the values
		// calculated are specific to the browser and OS configuration which we
		// don&#x27;t expect to change between initialisations
		if ( ! DataTable.__browser ) {
			var browser = {};
			DataTable.__browser = browser;
	
			// Scrolling feature / quirks detection
			var n = $(&#x27;&lt;div/&gt;&#x27;)
				.css( {
					position: &#x27;fixed&#x27;,
					top: 0,
					left: $(window).scrollLeft()*-1, // allow for scrolling
					height: 1,
					width: 1,
					overflow: &#x27;hidden&#x27;
				} )
				.append(
					$(&#x27;&lt;div/&gt;&#x27;)
						.css( {
							position: &#x27;absolute&#x27;,
							top: 1,
							left: 1,
							width: 100,
							overflow: &#x27;scroll&#x27;
						} )
						.append(
							$(&#x27;&lt;div/&gt;&#x27;)
								.css( {
									width: &#x27;100%&#x27;,
									height: 10
								} )
						)
				)
				.appendTo( &#x27;body&#x27; );
	
			var outer = n.children();
			var inner = outer.children();
	
			// Numbers below, in order, are:
			// inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth
			//
			// IE6 XP:                           100 100 100  83
			// IE7 Vista:                        100 100 100  83
			// IE 8+ Windows:                     83  83 100  83
			// Evergreen Windows:                 83  83 100  83
			// Evergreen Mac with scrollbars:     85  85 100  85
			// Evergreen Mac without scrollbars: 100 100 100 100
	
			// Get scrollbar width
			browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
	
			// IE6/7 will oversize a width 100% element inside a scrolling element, to
			// include the width of the scrollbar, while other browsers ensure the inner
			// element is contained without forcing scrolling
			browser.bScrollOversize = inner[0].offsetWidth === 100 &amp;&amp; outer[0].clientWidth !== 100;
	
			// In rtl text layout, some browsers (most, but not all) will place the
			// scrollbar on the left, rather than the right.
			browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;
	
			// IE8- don&#x27;t provide height and width for getBoundingClientRect
			browser.bBounding = n[0].getBoundingClientRect().width ? true : false;
	
			n.remove();
		}
	
		$.extend( settings.oBrowser, DataTable.__browser );
		settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
	}
	
	
	/**
	 * Array.prototype reduce[Right] method, used for browsers which don&#x27;t support
	 * JS 1.6. Done this way to reduce code size, since we iterate either way
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnReduce ( that, fn, init, start, end, inc )
	{
		var
			i = start,
			value,
			isSet = false;
	
		if ( init !== undefined ) {
			value = init;
			isSet = true;
		}
	
		while ( i !== end ) {
			if ( ! that.hasOwnProperty(i) ) {
				continue;
			}
	
			value = isSet ?
				fn( value, that[i], i, that ) :
				that[i];
	
			isSet = true;
			i += inc;
		}
	
		return value;
	}
	
	/**
	 * Add a column to the list used for the table with default values
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nTh The th element for this column
	 *  @memberof DataTable#oApi
	 */
	function _fnAddColumn( oSettings, nTh )
	{
		// Add column to aoColumns array
		var oDefaults = DataTable.defaults.column;
		var iCol = oSettings.aoColumns.length;
		var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
			&quot;nTh&quot;: nTh ? nTh : document.createElement(&#x27;th&#x27;),
			&quot;sTitle&quot;:    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : &#x27;&#x27;,
			&quot;aDataSort&quot;: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
			&quot;mData&quot;: oDefaults.mData ? oDefaults.mData : iCol,
			idx: iCol
		} );
		oSettings.aoColumns.push( oCol );
	
		// Add search object for column specific search. Note that the &#x60;searchCols[ iCol ]&#x60;
		// passed into extend can be undefined. This allows the user to give a default
		// with only some of the parameters defined, and also not give a default
		var searchCols = oSettings.aoPreSearchCols;
		searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
	
		// Use the default column options function to initialise classes etc
		_fnColumnOptions( oSettings, iCol, $(nTh).data() );
	}
	
	
	/**
	 * Apply options for a column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iCol column index to consider
	 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnOptions( oSettings, iCol, oOptions )
	{
		var oCol = oSettings.aoColumns[ iCol ];
		var oClasses = oSettings.oClasses;
		var th = $(oCol.nTh);
	
		// Try to get width information from the DOM. We can&#x27;t get it from CSS
		// as we&#x27;d need to parse the CSS stylesheet. &#x60;width&#x60; option can override
		if ( ! oCol.sWidthOrig ) {
			// Width attribute
			oCol.sWidthOrig = th.attr(&#x27;width&#x27;) || null;
	
			// Style attribute
			var t = (th.attr(&#x27;style&#x27;) || &#x27;&#x27;).match(/width:\s*(\d+[pxem%]+)/);
			if ( t ) {
				oCol.sWidthOrig = t[1];
			}
		}
	
		/* User specified column options */
		if ( oOptions !== undefined &amp;&amp; oOptions !== null )
		{
			// Backwards compatibility
			_fnCompatCols( oOptions );
	
			// Map camel case parameters to their Hungarian counterparts
			_fnCamelToHungarian( DataTable.defaults.column, oOptions );
	
			/* Backwards compatibility for mDataProp */
			if ( oOptions.mDataProp !== undefined &amp;&amp; !oOptions.mData )
			{
				oOptions.mData = oOptions.mDataProp;
			}
	
			if ( oOptions.sType )
			{
				oCol._sManualType = oOptions.sType;
			}
	
			// &#x60;class&#x60; is a reserved word in Javascript, so we need to provide
			// the ability to use a valid name for the camel case input
			if ( oOptions.className &amp;&amp; ! oOptions.sClass )
			{
				oOptions.sClass = oOptions.className;
			}
			if ( oOptions.sClass ) {
				th.addClass( oOptions.sClass );
			}
	
			$.extend( oCol, oOptions );
			_fnMap( oCol, oOptions, &quot;sWidth&quot;, &quot;sWidthOrig&quot; );
	
			/* iDataSort to be applied (backwards compatibility), but aDataSort will take
			 * priority if defined
			 */
			if ( oOptions.iDataSort !== undefined )
			{
				oCol.aDataSort = [ oOptions.iDataSort ];
			}
			_fnMap( oCol, oOptions, &quot;aDataSort&quot; );
		}
	
		/* Cache the data get and set functions for speed */
		var mDataSrc = oCol.mData;
		var mData = _fnGetObjectDataFn( mDataSrc );
		var mRender = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;
	
		var attrTest = function( src ) {
			return typeof src === &#x27;string&#x27; &amp;&amp; src.indexOf(&#x27;@&#x27;) !== -1;
		};
		oCol._bAttrSrc = $.isPlainObject( mDataSrc ) &amp;&amp; (
			attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
		);
		oCol._setter = null;
	
		oCol.fnGetData = function (rowData, type, meta) {
			var innerData = mData( rowData, type, undefined, meta );
	
			return mRender &amp;&amp; type ?
				mRender( innerData, type, rowData, meta ) :
				innerData;
		};
		oCol.fnSetData = function ( rowData, val, meta ) {
			return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
		};
	
		// Indicate if DataTables should read DOM data as an object or array
		// Used in _fnGetRowElements
		if ( typeof mDataSrc !== &#x27;number&#x27; ) {
			oSettings._rowReadObject = true;
		}
	
		/* Feature sorting overrides column specific when off */
		if ( !oSettings.oFeatures.bSort )
		{
			oCol.bSortable = false;
			th.addClass( oClasses.sSortableNone ); // Have to add class here as order event isn&#x27;t called
		}
	
		/* Check that the class assignment is correct for sorting */
		var bAsc = $.inArray(&#x27;asc&#x27;, oCol.asSorting) !== -1;
		var bDesc = $.inArray(&#x27;desc&#x27;, oCol.asSorting) !== -1;
		if ( !oCol.bSortable || (!bAsc &amp;&amp; !bDesc) )
		{
			oCol.sSortingClass = oClasses.sSortableNone;
			oCol.sSortingClassJUI = &quot;&quot;;
		}
		else if ( bAsc &amp;&amp; !bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableAsc;
			oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
		}
		else if ( !bAsc &amp;&amp; bDesc )
		{
			oCol.sSortingClass = oClasses.sSortableDesc;
			oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
		}
		else
		{
			oCol.sSortingClass = oClasses.sSortable;
			oCol.sSortingClassJUI = oClasses.sSortJUI;
		}
	}
	
	
	/**
	 * Adjust the table column widths for new data. Note: you would probably want to
	 * do a redraw after calling this function!
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAdjustColumnSizing ( settings )
	{
		/* Not interested in doing column width calculation if auto-width is disabled */
		if ( settings.oFeatures.bAutoWidth !== false )
		{
			var columns = settings.aoColumns;
	
			_fnCalculateColumnWidths( settings );
			for ( var i=0 , iLen=columns.length ; i&lt;iLen ; i++ )
			{
				columns[i].nTh.style.width = columns[i].sWidth;
			}
		}
	
		var scroll = settings.oScroll;
		if ( scroll.sY !== &#x27;&#x27; || scroll.sX !== &#x27;&#x27;)
		{
			_fnScrollDraw( settings );
		}
	
		_fnCallbackFire( settings, null, &#x27;column-sizing&#x27;, [settings] );
	}
	
	
	/**
	 * Covert the index of a visible column to the index in the data array (take account
	 * of hidden columns)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iMatch Visible column index to lookup
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnVisibleToColumnIndex( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, &#x27;bVisible&#x27; );
	
		return typeof aiVis[iMatch] === &#x27;number&#x27; ?
			aiVis[iMatch] :
			null;
	}
	
	
	/**
	 * Covert the index of an index in the data array and convert it to the visible
	 *   column index (take account of hidden columns)
	 *  @param {int} iMatch Column index to lookup
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the data index
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnIndexToVisible( oSettings, iMatch )
	{
		var aiVis = _fnGetColumns( oSettings, &#x27;bVisible&#x27; );
		var iPos = $.inArray( iMatch, aiVis );
	
		return iPos !== -1 ? iPos : null;
	}
	
	
	/**
	 * Get the number of visible columns
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {int} i the number of visible columns
	 *  @memberof DataTable#oApi
	 */
	function _fnVisbleColumns( oSettings )
	{
		var vis = 0;
	
		// No reduce in IE8, use a loop for now
		$.each( oSettings.aoColumns, function ( i, col ) {
			if ( col.bVisible &amp;&amp; $(col.nTh).css(&#x27;display&#x27;) !== &#x27;none&#x27; ) {
				vis++;
			}
		} );
	
		return vis;
	}
	
	
	/**
	 * Get an array of column indexes that match a given property
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sParam Parameter in aoColumns to look for - typically
	 *    bVisible or bSearchable
	 *  @returns {array} Array of indexes with matched properties
	 *  @memberof DataTable#oApi
	 */
	function _fnGetColumns( oSettings, sParam )
	{
		var a = [];
	
		$.map( oSettings.aoColumns, function(val, i) {
			if ( val[sParam] ) {
				a.push( i );
			}
		} );
	
		return a;
	}
	
	
	/**
	 * Calculate the &#x27;type&#x27; of a column
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnColumnTypes ( settings )
	{
		var columns = settings.aoColumns;
		var data = settings.aoData;
		var types = DataTable.ext.type.detect;
		var i, ien, j, jen, k, ken;
		var col, cell, detectedType, cache;
	
		// For each column, spin over the 
		for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
			col = columns[i];
			cache = [];
	
			if ( ! col.sType &amp;&amp; col._sManualType ) {
				col.sType = col._sManualType;
			}
			else if ( ! col.sType ) {
				for ( j=0, jen=types.length ; j&lt;jen ; j++ ) {
					for ( k=0, ken=data.length ; k&lt;ken ; k++ ) {
						// Use a cache array so we only need to get the type data
						// from the formatter once (when using multiple detectors)
						if ( cache[k] === undefined ) {
							cache[k] = _fnGetCellData( settings, k, i, &#x27;type&#x27; );
						}
	
						detectedType = types[j]( cache[k], settings );
	
						// If null, then this type can&#x27;t apply to this column, so
						// rather than testing all cells, break out. There is an
						// exception for the last type which is &#x60;html&#x60;. We need to
						// scan all rows since it is possible to mix string and HTML
						// types
						if ( ! detectedType &amp;&amp; j !== types.length-1 ) {
							break;
						}
	
						// Only a single match is needed for html type since it is
						// bottom of the pile and very similar to string
						if ( detectedType === &#x27;html&#x27; ) {
							break;
						}
					}
	
					// Type is valid for all data points in the column - use this
					// type
					if ( detectedType ) {
						col.sType = detectedType;
						break;
					}
				}
	
				// Fall back - if no type was detected, always use string
				if ( ! col.sType ) {
					col.sType = &#x27;string&#x27;;
				}
			}
		}
	}
	
	
	/**
	 * Take the column definitions and static columns arrays and calculate how
	 * they relate to column indexes. The callback function will then apply the
	 * definition found for a column to a suitable configuration object.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	 *  @param {array} aoCols The aoColumns array that defines columns individually
	 *  @param {function} fn Callback function - takes two parameters, the calculated
	 *    column index and the definition for that column.
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
	{
		var i, iLen, j, jLen, k, kLen, def;
		var columns = oSettings.aoColumns;
	
		// Column definitions with aTargets
		if ( aoColDefs )
		{
			/* Loop over the definitions array - loop in reverse so first instance has priority */
			for ( i=aoColDefs.length-1 ; i&gt;=0 ; i-- )
			{
				def = aoColDefs[i];
	
				/* Each definition can target multiple columns, as it is an array */
				var aTargets = def.targets !== undefined ?
					def.targets :
					def.aTargets;
	
				if ( ! $.isArray( aTargets ) )
				{
					aTargets = [ aTargets ];
				}
	
				for ( j=0, jLen=aTargets.length ; j&lt;jLen ; j++ )
				{
					if ( typeof aTargets[j] === &#x27;number&#x27; &amp;&amp; aTargets[j] &gt;= 0 )
					{
						/* Add columns that we don&#x27;t yet know about */
						while( columns.length &lt;= aTargets[j] )
						{
							_fnAddColumn( oSettings );
						}
	
						/* Integer, basic index */
						fn( aTargets[j], def );
					}
					else if ( typeof aTargets[j] === &#x27;number&#x27; &amp;&amp; aTargets[j] &lt; 0 )
					{
						/* Negative integer, right to left column counting */
						fn( columns.length+aTargets[j], def );
					}
					else if ( typeof aTargets[j] === &#x27;string&#x27; )
					{
						/* Class name matching on TH element */
						for ( k=0, kLen=columns.length ; k&lt;kLen ; k++ )
						{
							if ( aTargets[j] == &quot;_all&quot; ||
							     $(columns[k].nTh).hasClass( aTargets[j] ) )
							{
								fn( k, def );
							}
						}
					}
				}
			}
		}
	
		// Statically defined columns array
		if ( aoCols )
		{
			for ( i=0, iLen=aoCols.length ; i&lt;iLen ; i++ )
			{
				fn( i, aoCols[i] );
			}
		}
	}
	
	/**
	 * Add a data array to the table, creating DOM node etc. This is the parallel to
	 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	 * DOM source.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {array} aData data array to be added
	 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @returns {int} &gt;=0 if successful (index of new aoData entry), -1 if failed
	 *  @memberof DataTable#oApi
	 */
	function _fnAddData ( oSettings, aDataIn, nTr, anTds )
	{
		/* Create the object for storing information about this new row */
		var iRow = oSettings.aoData.length;
		var oData = $.extend( true, {}, DataTable.models.oRow, {
			src: nTr ? &#x27;dom&#x27; : &#x27;data&#x27;,
			idx: iRow
		} );
	
		oData._aData = aDataIn;
		oSettings.aoData.push( oData );
	
		/* Create the cells */
		var nTd, sThisType;
		var columns = oSettings.aoColumns;
	
		// Invalidate the column types as the new data needs to be revalidated
		for ( var i=0, iLen=columns.length ; i&lt;iLen ; i++ )
		{
			columns[i].sType = null;
		}
	
		/* Add to the display array */
		oSettings.aiDisplayMaster.push( iRow );
	
		var id = oSettings.rowIdFn( aDataIn );
		if ( id !== undefined ) {
			oSettings.aIds[ id ] = oData;
		}
	
		/* Create the DOM information, or register it if already present */
		if ( nTr || ! oSettings.oFeatures.bDeferRender )
		{
			_fnCreateTr( oSettings, iRow, nTr, anTds );
		}
	
		return iRow;
	}
	
	
	/**
	 * Add one or more TR elements to the table. Generally we&#x27;d expect to
	 * use this for reading data from a DOM sourced table, but it could be
	 * used for an TR element. Note that if a TR is given, it is used (i.e.
	 * it is not cloned).
	 *  @param {object} settings dataTables settings object
	 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	 *  @returns {array} Array of indexes for the added rows
	 *  @memberof DataTable#oApi
	 */
	function _fnAddTr( settings, trs )
	{
		var row;
	
		// Allow an individual node to be passed in
		if ( ! (trs instanceof $) ) {
			trs = $(trs);
		}
	
		return trs.map( function (i, el) {
			row = _fnGetRowElements( settings, el );
			return _fnAddData( settings, row.data, el, row.cells );
		} );
	}
	
	
	/**
	 * Take a TR element and convert it to an index in aoData
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} n the TR element to find
	 *  @returns {int} index if the node is found, null if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToDataIndex( oSettings, n )
	{
		return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
	}
	
	
	/**
	 * Take a TD element and convert it into a column data index (not the visible index)
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow The row number the TD/TH can be found in
	 *  @param {node} n The TD/TH element to find
	 *  @returns {int} index if the node is found, -1 if not
	 *  @memberof DataTable#oApi
	 */
	function _fnNodeToColumnIndex( oSettings, iRow, n )
	{
		return $.inArray( n, oSettings.aoData[ iRow ].anCells );
	}
	
	
	/**
	 * Get the data for a given cell from the internal cache, taking into account data mapping
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {string} type data get type (&#x27;display&#x27;, &#x27;type&#x27; &#x27;filter&#x27; &#x27;sort&#x27;)
	 *  @returns {*} Cell data
	 *  @memberof DataTable#oApi
	 */
	function _fnGetCellData( settings, rowIdx, colIdx, type )
	{
		var draw           = settings.iDraw;
		var col            = settings.aoColumns[colIdx];
		var rowData        = settings.aoData[rowIdx]._aData;
		var defaultContent = col.sDefaultContent;
		var cellData       = col.fnGetData( rowData, type, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		} );
	
		if ( cellData === undefined ) {
			if ( settings.iDrawError != draw &amp;&amp; defaultContent === null ) {
				_fnLog( settings, 0, &quot;Requested unknown parameter &quot;+
					(typeof col.mData==&#x27;function&#x27; ? &#x27;{function}&#x27; : &quot;&#x27;&quot;+col.mData+&quot;&#x27;&quot;)+
					&quot; for row &quot;+rowIdx+&quot;, column &quot;+colIdx, 4 );
				settings.iDrawError = draw;
			}
			return defaultContent;
		}
	
		// When the data source is null and a specific data type is requested (i.e.
		// not the original data), we can use default column data
		if ( (cellData === rowData || cellData === null) &amp;&amp; defaultContent !== null &amp;&amp; type !== undefined ) {
			cellData = defaultContent;
		}
		else if ( typeof cellData === &#x27;function&#x27; ) {
			// If the data source is a function, then we run it and use the return,
			// executing in the scope of the data object (for instances)
			return cellData.call( rowData );
		}
	
		if ( cellData === null &amp;&amp; type == &#x27;display&#x27; ) {
			return &#x27;&#x27;;
		}
		return cellData;
	}
	
	
	/**
	 * Set the value for a specific cell, into the internal data cache
	 *  @param {object} settings dataTables settings object
	 *  @param {int} rowIdx aoData row id
	 *  @param {int} colIdx Column index
	 *  @param {*} val Value to set
	 *  @memberof DataTable#oApi
	 */
	function _fnSetCellData( settings, rowIdx, colIdx, val )
	{
		var col     = settings.aoColumns[colIdx];
		var rowData = settings.aoData[rowIdx]._aData;
	
		col.fnSetData( rowData, val, {
			settings: settings,
			row:      rowIdx,
			col:      colIdx
		}  );
	}
	
	
	// Private variable that is used to match action syntax in the data property object
	var __reArray = /\[.*?\]$/;
	var __reFn = /\(\)$/;
	
	/**
	 * Split string on periods, taking into account escaped periods
	 * @param  {string} str String to split
	 * @return {array} Split string
	 */
	function _fnSplitObjNotation( str )
	{
		return $.map( str.match(/(\\.|[^\.])+/g) || [&#x27;&#x27;], function ( s ) {
			return s.replace(/\\\./g, &#x27;.&#x27;);
		} );
	}
	
	
	/**
	 * Return a function that can be used to get data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data get function
	 *  @memberof DataTable#oApi
	 */
	function _fnGetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Build an object of get functions, and wrap them in a single call */
			var o = {};
			$.each( mSource, function (key, val) {
				if ( val ) {
					o[key] = _fnGetObjectDataFn( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( mSource === null )
		{
			/* Give an empty string for rendering / sorting etc */
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof mSource === &#x27;function&#x27; )
		{
			return function (data, type, row, meta) {
				return mSource( data, type, row, meta );
			};
		}
		else if ( typeof mSource === &#x27;string&#x27; &amp;&amp; (mSource.indexOf(&#x27;.&#x27;) !== -1 ||
			      mSource.indexOf(&#x27;[&#x27;) !== -1 || mSource.indexOf(&#x27;(&#x27;) !== -1) )
		{
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== &quot;&quot; )
				{
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i&lt;iLen ; i++ )
					{
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation )
						{
							// Array notation
							a[i] = a[i].replace(__reArray, &#x27;&#x27;);
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== &quot;&quot; ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join(&#x27;.&#x27;);
	
							// Traverse each entry in the array getting the properties requested
							if ( $.isArray( data ) ) {
								for ( var j=0, jLen=data.length ; j&lt;jLen ; j++ ) {
									out.push( fetchData( data[j], type, innerSrc ) );
								}
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join===&quot;&quot;) ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation )
						{
							// Function call
							a[i] = a[i].replace(__reFn, &#x27;&#x27;);
							data = data[ a[i] ]();
							continue;
						}
	
						if ( data === null || data[ a[i] ] === undefined )
						{
							return undefined;
						}
						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, type) { // row and meta also passed, but not used
				return data[mSource];
			};
		}
	}
	
	
	/**
	 * Return a function that can be used to set data from a source object, taking
	 * into account the ability to use nested objects as a source
	 *  @param {string|int|function} mSource The data source for the object
	 *  @returns {function} Data set function
	 *  @memberof DataTable#oApi
	 */
	function _fnSetObjectDataFn( mSource )
	{
		if ( $.isPlainObject( mSource ) )
		{
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don&#x27;t know the type here. This is why an object
			 * option is not documented for &#x60;mData&#x60; (which is read/write), but it is
			 * for &#x60;mRender&#x60; which is read only.
			 */
			return _fnSetObjectDataFn( mSource._ );
		}
		else if ( mSource === null )
		{
			/* Nothing to do when the data source is null */
			return function () {};
		}
		else if ( typeof mSource === &#x27;function&#x27; )
		{
			return function (data, val, meta) {
				mSource( data, &#x27;set&#x27;, val, meta );
			};
		}
		else if ( typeof mSource === &#x27;string&#x27; &amp;&amp; (mSource.indexOf(&#x27;.&#x27;) !== -1 ||
			      mSource.indexOf(&#x27;[&#x27;) !== -1 || mSource.indexOf(&#x27;(&#x27;) !== -1) )
		{
			/* Like the get, we need to get data from a nested object */
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i&lt;iLen ; i++ )
				{
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation )
					{
						a[i] = a[i].replace(__reArray, &#x27;&#x27;);
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join(&#x27;.&#x27;);
	
						// Traverse each entry in the array setting the properties requested
						if ( $.isArray( val ) )
						{
							for ( var j=0, jLen=val.length ; j&lt;jLen ; j++ )
							{
								o = {};
								setData( o, val[j], innerSrc );
								data[ a[i] ].push( o );
							}
						}
						else
						{
							// We&#x27;ve been asked to save data to an array, but it
							// isn&#x27;t array data to be saved. Best that can be done
							// is to just save the value.
							data[ a[i] ] = val;
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation )
					{
						// Function call
						a[i] = a[i].replace(__reFn, &#x27;&#x27;);
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn&#x27;t currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined )
					{
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) )
				{
					// Function call
					data = data[ aLast.replace(__reFn, &#x27;&#x27;) ]( val );
				}
				else
				{
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn&#x27;t used, then we get the result we want anyway
					data[ aLast.replace(__reArray, &#x27;&#x27;) ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, mSource );
			};
		}
		else
		{
			/* Array or flat object mapping */
			return function (data, val) { // meta is also passed in, but not used
				data[mSource] = val;
			};
		}
	}
	
	
	/**
	 * Return an array with the full table data
	 *  @param {object} oSettings dataTables settings object
	 *  @returns array {array} aData Master data array
	 *  @memberof DataTable#oApi
	 */
	function _fnGetDataMaster ( settings )
	{
		return _pluck( settings.aoData, &#x27;_aData&#x27; );
	}
	
	
	/**
	 * Nuke the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnClearTable( settings )
	{
		settings.aoData.length = 0;
		settings.aiDisplayMaster.length = 0;
		settings.aiDisplay.length = 0;
		settings.aIds = {};
	}
	
	
	 /**
	 * Take an array of integers (index array) and remove a target integer (value - not
	 * the key!)
	 *  @param {array} a Index array to target
	 *  @param {int} iTarget value to find
	 *  @memberof DataTable#oApi
	 */
	function _fnDeleteIndex( a, iTarget, splice )
	{
		var iTargetIndex = -1;
	
		for ( var i=0, iLen=a.length ; i&lt;iLen ; i++ )
		{
			if ( a[i] == iTarget )
			{
				iTargetIndex = i;
			}
			else if ( a[i] &gt; iTarget )
			{
				a[i]--;
			}
		}
	
		if ( iTargetIndex != -1 &amp;&amp; splice === undefined )
		{
			a.splice( iTargetIndex, 1 );
		}
	}
	
	
	/**
	 * Mark cached data as invalid such that a re-read of the data will occur when
	 * the cached data is next requested. Also update from the data source object.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {int}    rowIdx   Row index to invalidate
	 * @param {string} [src]    Source to invalidate from: undefined, &#x27;auto&#x27;, &#x27;dom&#x27;
	 *     or &#x27;data&#x27;
	 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	 *     row will be invalidated
	 * @memberof DataTable#oApi
	 *
	 * @todo For the modularisation of v1.11 this will need to become a callback, so
	 *   the sort and filter methods can subscribe to it. That will required
	 *   initialisation options for sorting, which is why it is not already baked in
	 */
	function _fnInvalidate( settings, rowIdx, src, colIdx )
	{
		var row = settings.aoData[ rowIdx ];
		var i, ien;
		var cellWrite = function ( cell, col ) {
			// This is very frustrating, but in IE if you just write directly
			// to innerHTML, and elements that are overwritten are GC&#x27;ed,
			// even if there is a reference to them elsewhere
			while ( cell.childNodes.length ) {
				cell.removeChild( cell.firstChild );
			}
	
			cell.innerHTML = _fnGetCellData( settings, rowIdx, col, &#x27;display&#x27; );
		};
	
		// Are we reading last data from DOM or the data object?
		if ( src === &#x27;dom&#x27; || ((! src || src === &#x27;auto&#x27;) &amp;&amp; row.src === &#x27;dom&#x27;) ) {
			// Read the data from the DOM
			row._aData = _fnGetRowElements(
					settings, row, colIdx, colIdx === undefined ? undefined : row._aData
				)
				.data;
		}
		else {
			// Reading from data object, update the DOM
			var cells = row.anCells;
	
			if ( cells ) {
				if ( colIdx !== undefined ) {
					cellWrite( cells[colIdx], colIdx );
				}
				else {
					for ( i=0, ien=cells.length ; i&lt;ien ; i++ ) {
						cellWrite( cells[i], i );
					}
				}
			}
		}
	
		// For both row and cell invalidation, the cached data for sorting and
		// filtering is nulled out
		row._aSortData = null;
		row._aFilterData = null;
	
		// Invalidate the type for a specific column (if given) or all columns since
		// the data might have changed
		var cols = settings.aoColumns;
		if ( colIdx !== undefined ) {
			cols[ colIdx ].sType = null;
		}
		else {
			for ( i=0, ien=cols.length ; i&lt;ien ; i++ ) {
				cols[i].sType = null;
			}
	
			// Update DataTables special &#x60;DT_*&#x60; attributes for the row
			_fnRowAttributes( settings, row );
		}
	}
	
	
	/**
	 * Build a data source object from an HTML row, reading the contents of the
	 * cells that are in the row.
	 *
	 * @param {object} settings DataTables settings object
	 * @param {node|object} TR element from which to read data or existing row
	 *   object from which to re-read the data from the cells
	 * @param {int} [colIdx] Optional column index
	 * @param {array|object} [d] Data source object. If &#x60;colIdx&#x60; is given then this
	 *   parameter should also be given and will be used to write the data into.
	 *   Only the column in question will be written
	 * @returns {object} Object with two parameters: &#x60;data&#x60; the data read, in
	 *   document order, and &#x60;cells&#x60; and array of nodes (they can be useful to the
	 *   caller, so rather than needing a second traversal to get them, just return
	 *   them from here).
	 * @memberof DataTable#oApi
	 */
	function _fnGetRowElements( settings, row, colIdx, d )
	{
		var
			tds = [],
			td = row.firstChild,
			name, col, o, i=0, contents,
			columns = settings.aoColumns,
			objectRead = settings._rowReadObject;
	
		// Allow the data object to be passed in, or construct
		d = d !== undefined ?
			d :
			objectRead ?
				{} :
				[];
	
		var attr = function ( str, td  ) {
			if ( typeof str === &#x27;string&#x27; ) {
				var idx = str.indexOf(&#x27;@&#x27;);
	
				if ( idx !== -1 ) {
					var attr = str.substring( idx+1 );
					var setter = _fnSetObjectDataFn( str );
					setter( d, td.getAttribute( attr ) );
				}
			}
		};
	
		// Read data from a cell and store into the data object
		var cellProcess = function ( cell ) {
			if ( colIdx === undefined || colIdx === i ) {
				col = columns[i];
				contents = $.trim(cell.innerHTML);
	
				if ( col &amp;&amp; col._bAttrSrc ) {
					var setter = _fnSetObjectDataFn( col.mData._ );
					setter( d, contents );
	
					attr( col.mData.sort, cell );
					attr( col.mData.type, cell );
					attr( col.mData.filter, cell );
				}
				else {
					// Depending on the &#x60;data&#x60; option for the columns the data can
					// be read to either an object or an array.
					if ( objectRead ) {
						if ( ! col._setter ) {
							// Cache the setter function
							col._setter = _fnSetObjectDataFn( col.mData );
						}
						col._setter( d, contents );
					}
					else {
						d[i] = contents;
					}
				}
			}
	
			i++;
		};
	
		if ( td ) {
			// &#x60;tr&#x60; element was passed in
			while ( td ) {
				name = td.nodeName.toUpperCase();
	
				if ( name == &quot;TD&quot; || name == &quot;TH&quot; ) {
					cellProcess( td );
					tds.push( td );
				}
	
				td = td.nextSibling;
			}
		}
		else {
			// Existing row object passed in
			tds = row.anCells;
	
			for ( var j=0, jen=tds.length ; j&lt;jen ; j++ ) {
				cellProcess( tds[j] );
			}
		}
	
		// Read the ID from the DOM if present
		var rowNode = row.firstChild ? row : row.nTr;
	
		if ( rowNode ) {
			var id = rowNode.getAttribute( &#x27;id&#x27; );
	
			if ( id ) {
				_fnSetObjectDataFn( settings.rowId )( d, id );
			}
		}
	
		return {
			data: d,
			cells: tds
		};
	}
	/**
	 * Create a new TR element (and it&#x27;s TD children) for a row
	 *  @param {object} oSettings dataTables settings object
	 *  @param {int} iRow Row to consider
	 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	 *    DataTables will create a row automatically
	 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	 *    if nTr is.
	 *  @memberof DataTable#oApi
	 */
	function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
	{
		var
			row = oSettings.aoData[iRow],
			rowData = row._aData,
			cells = [],
			nTr, nTd, oCol,
			i, iLen;
	
		if ( row.nTr === null )
		{
			nTr = nTrIn || document.createElement(&#x27;tr&#x27;);
	
			row.nTr = nTr;
			row.anCells = cells;
	
			/* Use a private property on the node to allow reserve mapping from the node
			 * to the aoData array for fast look up
			 */
			nTr._DT_RowIndex = iRow;
	
			/* Special parameters can be given by the data source to be used on the row */
			_fnRowAttributes( oSettings, row );
	
			/* Process each column */
			for ( i=0, iLen=oSettings.aoColumns.length ; i&lt;iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
	
				nTd = nTrIn ? anTds[i] : document.createElement( oCol.sCellType );
				nTd._DT_CellIndex = {
					row: iRow,
					column: i
				};
				
				cells.push( nTd );
	
				// Need to create the HTML if new, or if a rendering function is defined
				if ( (!nTrIn || oCol.mRender || oCol.mData !== i) &amp;&amp;
					 (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+&#x27;.display&#x27;)
				) {
					nTd.innerHTML = _fnGetCellData( oSettings, iRow, i, &#x27;display&#x27; );
				}
	
				/* Add user defined class */
				if ( oCol.sClass )
				{
					nTd.className += &#x27; &#x27;+oCol.sClass;
				}
	
				// Visibility - add or remove as required
				if ( oCol.bVisible &amp;&amp; ! nTrIn )
				{
					nTr.appendChild( nTd );
				}
				else if ( ! oCol.bVisible &amp;&amp; nTrIn )
				{
					nTd.parentNode.removeChild( nTd );
				}
	
				if ( oCol.fnCreatedCell )
				{
					oCol.fnCreatedCell.call( oSettings.oInstance,
						nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
					);
				}
			}
	
			_fnCallbackFire( oSettings, &#x27;aoRowCreatedCallback&#x27;, null, [nTr, rowData, iRow] );
		}
	
		// Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
		// and deployed
		row.nTr.setAttribute( &#x27;role&#x27;, &#x27;row&#x27; );
	}
	
	
	/**
	 * Add attributes to a row based on the special &#x60;DT_*&#x60; parameters in a data
	 * source object.
	 *  @param {object} settings DataTables settings object
	 *  @param {object} DataTables row object for the row to be modified
	 *  @memberof DataTable#oApi
	 */
	function _fnRowAttributes( settings, row )
	{
		var tr = row.nTr;
		var data = row._aData;
	
		if ( tr ) {
			var id = settings.rowIdFn( data );
	
			if ( id ) {
				tr.id = id;
			}
	
			if ( data.DT_RowClass ) {
				// Remove any classes added by DT_RowClass before
				var a = data.DT_RowClass.split(&#x27; &#x27;);
				row.__rowc = row.__rowc ?
					_unique( row.__rowc.concat( a ) ) :
					a;
	
				$(tr)
					.removeClass( row.__rowc.join(&#x27; &#x27;) )
					.addClass( data.DT_RowClass );
			}
	
			if ( data.DT_RowAttr ) {
				$(tr).attr( data.DT_RowAttr );
			}
	
			if ( data.DT_RowData ) {
				$(tr).data( data.DT_RowData );
			}
		}
	}
	
	
	/**
	 * Create the HTML header for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnBuildHead( oSettings )
	{
		var i, ien, cell, row, column;
		var thead = oSettings.nTHead;
		var tfoot = oSettings.nTFoot;
		var createHeader = $(&#x27;th, td&#x27;, thead).length === 0;
		var classes = oSettings.oClasses;
		var columns = oSettings.aoColumns;
	
		if ( createHeader ) {
			row = $(&#x27;&lt;tr/&gt;&#x27;).appendTo( thead );
		}
	
		for ( i=0, ien=columns.length ; i&lt;ien ; i++ ) {
			column = columns[i];
			cell = $( column.nTh ).addClass( column.sClass );
	
			if ( createHeader ) {
				cell.appendTo( row );
			}
	
			// 1.11 move into sorting
			if ( oSettings.oFeatures.bSort ) {
				cell.addClass( column.sSortingClass );
	
				if ( column.bSortable !== false ) {
					cell
						.attr( &#x27;tabindex&#x27;, oSettings.iTabIndex )
						.attr( &#x27;aria-controls&#x27;, oSettings.sTableId );
	
					_fnSortAttachListener( oSettings, column.nTh, i );
				}
			}
	
			if ( column.sTitle != cell[0].innerHTML ) {
				cell.html( column.sTitle );
			}
	
			_fnRenderer( oSettings, &#x27;header&#x27; )(
				oSettings, cell, column, classes
			);
		}
	
		if ( createHeader ) {
			_fnDetectHeader( oSettings.aoHeader, thead );
		}
		
		/* ARIA role for the rows */
	 	$(thead).find(&#x27;&gt;tr&#x27;).attr(&#x27;role&#x27;, &#x27;row&#x27;);
	
		/* Deal with the footer - add classes if required */
		$(thead).find(&#x27;&gt;tr&gt;th, &gt;tr&gt;td&#x27;).addClass( classes.sHeaderTH );
		$(tfoot).find(&#x27;&gt;tr&gt;th, &gt;tr&gt;td&#x27;).addClass( classes.sFooterTH );
	
		// Cache the footer cells. Note that we only take the cells from the first
		// row in the footer. If there is more than one row the user wants to
		// interact with, they need to use the table().foot() method. Note also this
		// allows cells to be used for multiple columns using colspan
		if ( tfoot !== null ) {
			var cells = oSettings.aoFooter[0];
	
			for ( i=0, ien=cells.length ; i&lt;ien ; i++ ) {
				column = columns[i];
				column.nTf = cells[i].cell;
	
				if ( column.sClass ) {
					$(column.nTf).addClass( column.sClass );
				}
			}
		}
	}
	
	
	/**
	 * Draw the header (or footer) element based on the column visibility states. The
	 * methodology here is to use the layout array from _fnDetectHeader, modified for
	 * the instantaneous column visibility, to construct the new layout. The grid is
	 * traversed over cell at a time in a rows x columns grid fashion, although each
	 * cell insert can cover multiple elements in the grid - which is tracks using the
	 * aApplied array. Cell inserts in the grid will only occur where there isn&#x27;t
	 * already a cell in that position.
	 *  @param {object} oSettings dataTables settings object
	 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	 *  @memberof DataTable#oApi
	 */
	function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
	{
		var i, iLen, j, jLen, k, kLen, n, nLocalTr;
		var aoLocal = [];
		var aApplied = [];
		var iColumns = oSettings.aoColumns.length;
		var iRowspan, iColspan;
	
		if ( ! aoSource )
		{
			return;
		}
	
		if (  bIncludeHidden === undefined )
		{
			bIncludeHidden = false;
		}
	
		/* Make a copy of the master layout array, but without the visible columns in it */
		for ( i=0, iLen=aoSource.length ; i&lt;iLen ; i++ )
		{
			aoLocal[i] = aoSource[i].slice();
			aoLocal[i].nTr = aoSource[i].nTr;
	
			/* Remove any columns which are currently hidden */
			for ( j=iColumns-1 ; j&gt;=0 ; j-- )
			{
				if ( !oSettings.aoColumns[j].bVisible &amp;&amp; !bIncludeHidden )
				{
					aoLocal[i].splice( j, 1 );
				}
			}
	
			/* Prep the applied array - it needs an element for each row */
			aApplied.push( [] );
		}
	
		for ( i=0, iLen=aoLocal.length ; i&lt;iLen ; i++ )
		{
			nLocalTr = aoLocal[i].nTr;
	
			/* All cells are going to be replaced, so empty out the row */
			if ( nLocalTr )
			{
				while( (n = nLocalTr.firstChild) )
				{
					nLocalTr.removeChild( n );
				}
			}
	
			for ( j=0, jLen=aoLocal[i].length ; j&lt;jLen ; j++ )
			{
				iRowspan = 1;
				iColspan = 1;
	
				/* Check to see if there is already a cell (row/colspan) covering our target
				 * insert point. If there is, then there is nothing to do.
				 */
				if ( aApplied[i][j] === undefined )
				{
					nLocalTr.appendChild( aoLocal[i][j].cell );
					aApplied[i][j] = 1;
	
					/* Expand the cell to cover as many rows as needed */
					while ( aoLocal[i+iRowspan] !== undefined &amp;&amp;
					        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
					{
						aApplied[i+iRowspan][j] = 1;
						iRowspan++;
					}
	
					/* Expand the cell to cover as many columns as needed */
					while ( aoLocal[i][j+iColspan] !== undefined &amp;&amp;
					        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
					{
						/* Must update the applied array over the rows for the columns */
						for ( k=0 ; k&lt;iRowspan ; k++ )
						{
							aApplied[i+k][j+iColspan] = 1;
						}
						iColspan++;
					}
	
					/* Do the actual expansion in the DOM */
					$(aoLocal[i][j].cell)
						.attr(&#x27;rowspan&#x27;, iRowspan)
						.attr(&#x27;colspan&#x27;, iColspan);
				}
			}
		}
	}
	
	
	/**
	 * Insert the required TR nodes into the table for display
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnDraw( oSettings )
	{
		/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
		var aPreDraw = _fnCallbackFire( oSettings, &#x27;aoPreDrawCallback&#x27;, &#x27;preDraw&#x27;, [oSettings] );
		if ( $.inArray( false, aPreDraw ) !== -1 )
		{
			_fnProcessingDisplay( oSettings, false );
			return;
		}
	
		var i, iLen, n;
		var anRows = [];
		var iRowCount = 0;
		var asStripeClasses = oSettings.asStripeClasses;
		var iStripes = asStripeClasses.length;
		var iOpenRows = oSettings.aoOpenRows.length;
		var oLang = oSettings.oLanguage;
		var iInitDisplayStart = oSettings.iInitDisplayStart;
		var bServerSide = _fnDataSource( oSettings ) == &#x27;ssp&#x27;;
		var aiDisplay = oSettings.aiDisplay;
	
		oSettings.bDrawing = true;
	
		/* Check and see if we have an initial draw position from state saving */
		if ( iInitDisplayStart !== undefined &amp;&amp; iInitDisplayStart !== -1 )
		{
			oSettings._iDisplayStart = bServerSide ?
				iInitDisplayStart :
				iInitDisplayStart &gt;= oSettings.fnRecordsDisplay() ?
					0 :
					iInitDisplayStart;
	
			oSettings.iInitDisplayStart = -1;
		}
	
		var iDisplayStart = oSettings._iDisplayStart;
		var iDisplayEnd = oSettings.fnDisplayEnd();
	
		/* Server-side processing draw intercept */
		if ( oSettings.bDeferLoading )
		{
			oSettings.bDeferLoading = false;
			oSettings.iDraw++;
			_fnProcessingDisplay( oSettings, false );
		}
		else if ( !bServerSide )
		{
			oSettings.iDraw++;
		}
		else if ( !oSettings.bDestroying &amp;&amp; !_fnAjaxUpdate( oSettings ) )
		{
			return;
		}
	
		if ( aiDisplay.length !== 0 )
		{
			var iStart = bServerSide ? 0 : iDisplayStart;
			var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
	
			for ( var j=iStart ; j&lt;iEnd ; j++ )
			{
				var iDataIndex = aiDisplay[j];
				var aoData = oSettings.aoData[ iDataIndex ];
				if ( aoData.nTr === null )
				{
					_fnCreateTr( oSettings, iDataIndex );
				}
	
				var nRow = aoData.nTr;
	
				/* Remove the old striping classes and then add the new one */
				if ( iStripes !== 0 )
				{
					var sStripe = asStripeClasses[ iRowCount % iStripes ];
					if ( aoData._sRowStripe != sStripe )
					{
						$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
						aoData._sRowStripe = sStripe;
					}
				}
	
				// Row callback functions - might want to manipulate the row
				// iRowCount and j are not currently documented. Are they at all
				// useful?
				_fnCallbackFire( oSettings, &#x27;aoRowCallback&#x27;, null,
					[nRow, aoData._aData, iRowCount, j] );
	
				anRows.push( nRow );
				iRowCount++;
			}
		}
		else
		{
			/* Table is empty - create a row with an empty message in it */
			var sZero = oLang.sZeroRecords;
			if ( oSettings.iDraw == 1 &amp;&amp;  _fnDataSource( oSettings ) == &#x27;ajax&#x27; )
			{
				sZero = oLang.sLoadingRecords;
			}
			else if ( oLang.sEmptyTable &amp;&amp; oSettings.fnRecordsTotal() === 0 )
			{
				sZero = oLang.sEmptyTable;
			}
	
			anRows[ 0 ] = $( &#x27;&lt;tr/&gt;&#x27;, { &#x27;class&#x27;: iStripes ? asStripeClasses[0] : &#x27;&#x27; } )
				.append( $(&#x27;&lt;td /&gt;&#x27;, {
					&#x27;valign&#x27;:  &#x27;top&#x27;,
					&#x27;colSpan&#x27;: _fnVisbleColumns( oSettings ),
					&#x27;class&#x27;:   oSettings.oClasses.sRowEmpty
				} ).html( sZero ) )[0];
		}
	
		/* Header and footer callbacks */
		_fnCallbackFire( oSettings, &#x27;aoHeaderCallback&#x27;, &#x27;header&#x27;, [ $(oSettings.nTHead).children(&#x27;tr&#x27;)[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		_fnCallbackFire( oSettings, &#x27;aoFooterCallback&#x27;, &#x27;footer&#x27;, [ $(oSettings.nTFoot).children(&#x27;tr&#x27;)[0],
			_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );
	
		var body = $(oSettings.nTBody);
	
		body.children().detach();
		body.append( $(anRows) );
	
		/* Call all required callback functions for the end of a draw */
		_fnCallbackFire( oSettings, &#x27;aoDrawCallback&#x27;, &#x27;draw&#x27;, [oSettings] );
	
		/* Draw is complete, sorting and filtering must be as well */
		oSettings.bSorted = false;
		oSettings.bFiltered = false;
		oSettings.bDrawing = false;
	}
	
	
	/**
	 * Redraw the table - taking account of the various features which are enabled
	 *  @param {object} oSettings dataTables settings object
	 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	 *    the paging is reset to the first page
	 *  @memberof DataTable#oApi
	 */
	function _fnReDraw( settings, holdPosition )
	{
		var
			features = settings.oFeatures,
			sort     = features.bSort,
			filter   = features.bFilter;
	
		if ( sort ) {
			_fnSort( settings );
		}
	
		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	
		if ( holdPosition !== true ) {
			settings._iDisplayStart = 0;
		}
	
		// Let any modules know about the draw hold position state (used by
		// scrolling internally)
		settings._drawHold = holdPosition;
	
		_fnDraw( settings );
	
		settings._drawHold = false;
	}
	
	
	/**
	 * Add the options to the page HTML for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnAddOptionsHtml ( oSettings )
	{
		var classes = oSettings.oClasses;
		var table = $(oSettings.nTable);
		var holding = $(&#x27;&lt;div/&gt;&#x27;).insertBefore( table ); // Holding element for speed
		var features = oSettings.oFeatures;
	
		// All DataTables are wrapped in a div
		var insert = $(&#x27;&lt;div/&gt;&#x27;, {
			id:      oSettings.sTableId+&#x27;_wrapper&#x27;,
			&#x27;class&#x27;: classes.sWrapper + (oSettings.nTFoot ? &#x27;&#x27; : &#x27; &#x27;+classes.sNoFooter)
		} );
	
		oSettings.nHolding = holding[0];
		oSettings.nTableWrapper = insert[0];
		oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
	
		/* Loop over the user set positioning and place the elements as needed */
		var aDom = oSettings.sDom.split(&#x27;&#x27;);
		var featureNode, cOption, nNewNode, cNext, sAttr, j;
		for ( var i=0 ; i&lt;aDom.length ; i++ )
		{
			featureNode = null;
			cOption = aDom[i];
	
			if ( cOption == &#x27;&lt;&#x27; )
			{
				/* New container div */
				nNewNode = $(&#x27;&lt;div/&gt;&#x27;)[0];
	
				/* Check to see if we should append an id and/or a class name to the container */
				cNext = aDom[i+1];
				if ( cNext == &quot;&#x27;&quot; || cNext == &#x27;&quot;&#x27; )
				{
					sAttr = &quot;&quot;;
					j = 2;
					while ( aDom[i+j] != cNext )
					{
						sAttr += aDom[i+j];
						j++;
					}
	
					/* Replace jQuery UI constants @todo depreciated */
					if ( sAttr == &quot;H&quot; )
					{
						sAttr = classes.sJUIHeader;
					}
					else if ( sAttr == &quot;F&quot; )
					{
						sAttr = classes.sJUIFooter;
					}
	
					/* The attribute can be in the format of &quot;#id.class&quot;, &quot;#id&quot; or &quot;class&quot; This logic
					 * breaks the string into parts and applies them as needed
					 */
					if ( sAttr.indexOf(&#x27;.&#x27;) != -1 )
					{
						var aSplit = sAttr.split(&#x27;.&#x27;);
						nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
						nNewNode.className = aSplit[1];
					}
					else if ( sAttr.charAt(0) == &quot;#&quot; )
					{
						nNewNode.id = sAttr.substr(1, sAttr.length-1);
					}
					else
					{
						nNewNode.className = sAttr;
					}
	
					i += j; /* Move along the position array */
				}
	
				insert.append( nNewNode );
				insert = $(nNewNode);
			}
			else if ( cOption == &#x27;&gt;&#x27; )
			{
				/* End container div */
				insert = insert.parent();
			}
			// @todo Move options into their own plugins?
			else if ( cOption == &#x27;l&#x27; &amp;&amp; features.bPaginate &amp;&amp; features.bLengthChange )
			{
				/* Length */
				featureNode = _fnFeatureHtmlLength( oSettings );
			}
			else if ( cOption == &#x27;f&#x27; &amp;&amp; features.bFilter )
			{
				/* Filter */
				featureNode = _fnFeatureHtmlFilter( oSettings );
			}
			else if ( cOption == &#x27;r&#x27; &amp;&amp; features.bProcessing )
			{
				/* pRocessing */
				featureNode = _fnFeatureHtmlProcessing( oSettings );
			}
			else if ( cOption == &#x27;t&#x27; )
			{
				/* Table */
				featureNode = _fnFeatureHtmlTable( oSettings );
			}
			else if ( cOption ==  &#x27;i&#x27; &amp;&amp; features.bInfo )
			{
				/* Info */
				featureNode = _fnFeatureHtmlInfo( oSettings );
			}
			else if ( cOption == &#x27;p&#x27; &amp;&amp; features.bPaginate )
			{
				/* Pagination */
				featureNode = _fnFeatureHtmlPaginate( oSettings );
			}
			else if ( DataTable.ext.feature.length !== 0 )
			{
				/* Plug-in features */
				var aoFeatures = DataTable.ext.feature;
				for ( var k=0, kLen=aoFeatures.length ; k&lt;kLen ; k++ )
				{
					if ( cOption == aoFeatures[k].cFeature )
					{
						featureNode = aoFeatures[k].fnInit( oSettings );
						break;
					}
				}
			}
	
			/* Add to the 2D features array */
			if ( featureNode )
			{
				var aanFeatures = oSettings.aanFeatures;
	
				if ( ! aanFeatures[cOption] )
				{
					aanFeatures[cOption] = [];
				}
	
				aanFeatures[cOption].push( featureNode );
				insert.append( featureNode );
			}
		}
	
		/* Built our DOM structure - replace the holding div with what we want */
		holding.replaceWith( insert );
		oSettings.nHolding = null;
	}
	
	
	/**
	 * Use the DOM source to create up an array of header cells. The idea here is to
	 * create a layout grid (array) of rows x columns, which contains a reference
	 * to the cell that that point in the grid (regardless of col/rowspan), such that
	 * any column / row could be removed and the new grid constructed
	 *  @param array {object} aLayout Array to store the calculated layout in
	 *  @param {node} nThead The header/footer element for the table
	 *  @memberof DataTable#oApi
	 */
	function _fnDetectHeader ( aLayout, nThead )
	{
		var nTrs = $(nThead).children(&#x27;tr&#x27;);
		var nTr, nCell;
		var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
		var bUnique;
		var fnShiftCol = function ( a, i, j ) {
			var k = a[i];
	                while ( k[j] ) {
				j++;
			}
			return j;
		};
	
		aLayout.splice( 0, aLayout.length );
	
		/* We know how many rows there are in the layout - so prep it */
		for ( i=0, iLen=nTrs.length ; i&lt;iLen ; i++ )
		{
			aLayout.push( [] );
		}
	
		/* Calculate a layout array */
		for ( i=0, iLen=nTrs.length ; i&lt;iLen ; i++ )
		{
			nTr = nTrs[i];
			iColumn = 0;
	
			/* For every cell in the row... */
			nCell = nTr.firstChild;
			while ( nCell ) {
				if ( nCell.nodeName.toUpperCase() == &quot;TD&quot; ||
				     nCell.nodeName.toUpperCase() == &quot;TH&quot; )
				{
					/* Get the col and rowspan attributes from the DOM and sanitise them */
					iColspan = nCell.getAttribute(&#x27;colspan&#x27;) * 1;
					iRowspan = nCell.getAttribute(&#x27;rowspan&#x27;) * 1;
					iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
					iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
	
					/* There might be colspan cells already in this row, so shift our target
					 * accordingly
					 */
					iColShifted = fnShiftCol( aLayout, i, iColumn );
	
					/* Cache calculation for unique columns */
					bUnique = iColspan === 1 ? true : false;
	
					/* If there is col / rowspan, copy the information into the layout grid */
					for ( l=0 ; l&lt;iColspan ; l++ )
					{
						for ( k=0 ; k&lt;iRowspan ; k++ )
						{
							aLayout[i+k][iColShifted+l] = {
								&quot;cell&quot;: nCell,
								&quot;unique&quot;: bUnique
							};
							aLayout[i+k].nTr = nTr;
						}
					}
				}
				nCell = nCell.nextSibling;
			}
		}
	}
	
	
	/**
	 * Get an array of unique th elements, one for each column
	 *  @param {object} oSettings dataTables settings object
	 *  @param {node} nHeader automatically detect the layout from this node - optional
	 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	 *  @returns array {node} aReturn list of unique th&#x27;s
	 *  @memberof DataTable#oApi
	 */
	function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
	{
		var aReturn = [];
		if ( !aLayout )
		{
			aLayout = oSettings.aoHeader;
			if ( nHeader )
			{
				aLayout = [];
				_fnDetectHeader( aLayout, nHeader );
			}
		}
	
		for ( var i=0, iLen=aLayout.length ; i&lt;iLen ; i++ )
		{
			for ( var j=0, jLen=aLayout[i].length ; j&lt;jLen ; j++ )
			{
				if ( aLayout[i][j].unique &amp;&amp;
					 (!aReturn[j] || !oSettings.bSortCellsTop) )
				{
					aReturn[j] = aLayout[i][j].cell;
				}
			}
		}
	
		return aReturn;
	}
	
	/**
	 * Create an Ajax call based on the table&#x27;s settings, taking into account that
	 * parameters can have multiple forms, and backwards compatibility.
	 *
	 * @param {object} oSettings dataTables settings object
	 * @param {array} data Data to send to the server, required by
	 *     DataTables - may be augmented by developer callbacks
	 * @param {function} fn Callback function to run when data is obtained
	 */
	function _fnBuildAjax( oSettings, data, fn )
	{
		// Compatibility with 1.9-, allow fnServerData and event to manipulate
		_fnCallbackFire( oSettings, &#x27;aoServerParams&#x27;, &#x27;serverParams&#x27;, [data] );
	
		// Convert to object based for 1.10+ if using the old array scheme which can
		// come from server-side processing or serverParams
		if ( data &amp;&amp; $.isArray(data) ) {
			var tmp = {};
			var rbracket = /(.*?)\[\]$/;
	
			$.each( data, function (key, val) {
				var match = val.name.match(rbracket);
	
				if ( match ) {
					// Support for arrays
					var name = match[0];
	
					if ( ! tmp[ name ] ) {
						tmp[ name ] = [];
					}
					tmp[ name ].push( val.value );
				}
				else {
					tmp[val.name] = val.value;
				}
			} );
			data = tmp;
		}
	
		var ajaxData;
		var ajax = oSettings.ajax;
		var instance = oSettings.oInstance;
		var callback = function ( json ) {
			_fnCallbackFire( oSettings, null, &#x27;xhr&#x27;, [oSettings, json, oSettings.jqXHR] );
			fn( json );
		};
	
		if ( $.isPlainObject( ajax ) &amp;&amp; ajax.data )
		{
			ajaxData = ajax.data;
	
			var newData = $.isFunction( ajaxData ) ?
				ajaxData( data, oSettings ) :  // fn can manipulate data or return
				ajaxData;                      // an object object or array to merge
	
			// If the function returned something, use that alone
			data = $.isFunction( ajaxData ) &amp;&amp; newData ?
				newData :
				$.extend( true, data, newData );
	
			// Remove the data property as we&#x27;ve resolved it already and don&#x27;t want
			// jQuery to do it again (it is restored at the end of the function)
			delete ajax.data;
		}
	
		var baseAjax = {
			&quot;data&quot;: data,
			&quot;success&quot;: function (json) {
				var error = json.error || json.sError;
				if ( error ) {
					_fnLog( oSettings, 0, error );
				}
	
				oSettings.json = json;
				callback( json );
			},
			&quot;dataType&quot;: &quot;json&quot;,
			&quot;cache&quot;: false,
			&quot;type&quot;: oSettings.sServerMethod,
			&quot;error&quot;: function (xhr, error, thrown) {
				var ret = _fnCallbackFire( oSettings, null, &#x27;xhr&#x27;, [oSettings, null, oSettings.jqXHR] );
	
				if ( $.inArray( true, ret ) === -1 ) {
					if ( error == &quot;parsererror&quot; ) {
						_fnLog( oSettings, 0, &#x27;Invalid JSON response&#x27;, 1 );
					}
					else if ( xhr.readyState === 4 ) {
						_fnLog( oSettings, 0, &#x27;Ajax error&#x27;, 7 );
					}
				}
	
				_fnProcessingDisplay( oSettings, false );
			}
		};
	
		// Store the data submitted for the API
		oSettings.oAjaxData = data;
	
		// Allow plug-ins and external processes to modify the data
		_fnCallbackFire( oSettings, null, &#x27;preXhr&#x27;, [oSettings, data] );
	
		if ( oSettings.fnServerData )
		{
			// DataTables 1.9- compatibility
			oSettings.fnServerData.call( instance,
				oSettings.sAjaxSource,
				$.map( data, function (val, key) { // Need to convert back to 1.9 trad format
					return { name: key, value: val };
				} ),
				callback,
				oSettings
			);
		}
		else if ( oSettings.sAjaxSource || typeof ajax === &#x27;string&#x27; )
		{
			// DataTables 1.9- compatibility
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, {
				url: ajax || oSettings.sAjaxSource
			} ) );
		}
		else if ( $.isFunction( ajax ) )
		{
			// Is a function - let the caller define what needs to be done
			oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
		}
		else
		{
			// Object to extend the base settings
			oSettings.jqXHR = $.ajax( $.extend( baseAjax, ajax ) );
	
			// Restore for next time around
			ajax.data = ajaxData;
		}
	}
	
	
	/**
	 * Update the table using an Ajax call
	 *  @param {object} settings dataTables settings object
	 *  @returns {boolean} Block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdate( settings )
	{
		if ( settings.bAjaxDataGet ) {
			settings.iDraw++;
			_fnProcessingDisplay( settings, true );
	
			_fnBuildAjax(
				settings,
				_fnAjaxParameters( settings ),
				function(json) {
					_fnAjaxUpdateDraw( settings, json );
				}
			);
	
			return false;
		}
		return true;
	}
	
	
	/**
	 * Build up the parameters in an object needed for a server-side processing
	 * request. Note that this is basically done twice, is different ways - a modern
	 * method which is used by default in DataTables 1.10 which uses objects and
	 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	 * option is set.
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {bool} block the table drawing or not
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxParameters( settings )
	{
		var
			columns = settings.aoColumns,
			columnCount = columns.length,
			features = settings.oFeatures,
			preSearch = settings.oPreviousSearch,
			preColSearch = settings.aoPreSearchCols,
			i, data = [], dataProp, column, columnSearch,
			sort = _fnSortFlatten( settings ),
			displayStart = settings._iDisplayStart,
			displayLength = features.bPaginate !== false ?
				settings._iDisplayLength :
				-1;
	
		var param = function ( name, value ) {
			data.push( { &#x27;name&#x27;: name, &#x27;value&#x27;: value } );
		};
	
		// DataTables 1.9- compatible method
		param( &#x27;sEcho&#x27;,          settings.iDraw );
		param( &#x27;iColumns&#x27;,       columnCount );
		param( &#x27;sColumns&#x27;,       _pluck( columns, &#x27;sName&#x27; ).join(&#x27;,&#x27;) );
		param( &#x27;iDisplayStart&#x27;,  displayStart );
		param( &#x27;iDisplayLength&#x27;, displayLength );
	
		// DataTables 1.10+ method
		var d = {
			draw:    settings.iDraw,
			columns: [],
			order:   [],
			start:   displayStart,
			length:  displayLength,
			search:  {
				value: preSearch.sSearch,
				regex: preSearch.bRegex
			}
		};
	
		for ( i=0 ; i&lt;columnCount ; i++ ) {
			column = columns[i];
			columnSearch = preColSearch[i];
			dataProp = typeof column.mData==&quot;function&quot; ? &#x27;function&#x27; : column.mData ;
	
			d.columns.push( {
				data:       dataProp,
				name:       column.sName,
				searchable: column.bSearchable,
				orderable:  column.bSortable,
				search:     {
					value: columnSearch.sSearch,
					regex: columnSearch.bRegex
				}
			} );
	
			param( &quot;mDataProp_&quot;+i, dataProp );
	
			if ( features.bFilter ) {
				param( &#x27;sSearch_&#x27;+i,     columnSearch.sSearch );
				param( &#x27;bRegex_&#x27;+i,      columnSearch.bRegex );
				param( &#x27;bSearchable_&#x27;+i, column.bSearchable );
			}
	
			if ( features.bSort ) {
				param( &#x27;bSortable_&#x27;+i, column.bSortable );
			}
		}
	
		if ( features.bFilter ) {
			param( &#x27;sSearch&#x27;, preSearch.sSearch );
			param( &#x27;bRegex&#x27;, preSearch.bRegex );
		}
	
		if ( features.bSort ) {
			$.each( sort, function ( i, val ) {
				d.order.push( { column: val.col, dir: val.dir } );
	
				param( &#x27;iSortCol_&#x27;+i, val.col );
				param( &#x27;sSortDir_&#x27;+i, val.dir );
			} );
	
			param( &#x27;iSortingCols&#x27;, sort.length );
		}
	
		// If the legacy.ajax parameter is null, then we automatically decide which
		// form to use, based on sAjaxSource
		var legacy = DataTable.ext.legacy.ajax;
		if ( legacy === null ) {
			return settings.sAjaxSource ? data : d;
		}
	
		// Otherwise, if legacy has been specified then we use that to decide on the
		// form
		return legacy ? data : d;
	}
	
	
	/**
	 * Data the data from the server (nuking the old) and redraw the table
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} json json data return from the server.
	 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	 *  @param {array} json.aaData The data to display on this page
	 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	 *  @memberof DataTable#oApi
	 */
	function _fnAjaxUpdateDraw ( settings, json )
	{
		// v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
		// Support both
		var compat = function ( old, modern ) {
			return json[old] !== undefined ? json[old] : json[modern];
		};
	
		var data = _fnAjaxDataSrc( settings, json );
		var draw            = compat( &#x27;sEcho&#x27;,                &#x27;draw&#x27; );
		var recordsTotal    = compat( &#x27;iTotalRecords&#x27;,        &#x27;recordsTotal&#x27; );
		var recordsFiltered = compat( &#x27;iTotalDisplayRecords&#x27;, &#x27;recordsFiltered&#x27; );
	
		if ( draw ) {
			// Protect against out of sequence returns
			if ( draw*1 &lt; settings.iDraw ) {
				return;
			}
			settings.iDraw = draw * 1;
		}
	
		_fnClearTable( settings );
		settings._iRecordsTotal   = parseInt(recordsTotal, 10);
		settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
	
		for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
			_fnAddData( settings, data[i] );
		}
		settings.aiDisplay = settings.aiDisplayMaster.slice();
	
		settings.bAjaxDataGet = false;
		_fnDraw( settings );
	
		if ( ! settings._bInitComplete ) {
			_fnInitComplete( settings, json );
		}
	
		settings.bAjaxDataGet = true;
		_fnProcessingDisplay( settings, false );
	}
	
	
	/**
	 * Get the data from the JSON data source to use for drawing a table. Using
	 * &#x60;_fnGetObjectDataFn&#x60; allows the data to be sourced from a property of the
	 * source object, or from a processing function.
	 *  @param {object} oSettings dataTables settings object
	 *  @param  {object} json Data source object / array from the server
	 *  @return {array} Array of data to use
	 */
	function _fnAjaxDataSrc ( oSettings, json )
	{
		var dataSrc = $.isPlainObject( oSettings.ajax ) &amp;&amp; oSettings.ajax.dataSrc !== undefined ?
			oSettings.ajax.dataSrc :
			oSettings.sAjaxDataProp; // Compatibility with 1.9-.
	
		// Compatibility with 1.9-. In order to read from aaData, check if the
		// default has been changed, if not, check for aaData
		if ( dataSrc === &#x27;data&#x27; ) {
			return json.aaData || json[dataSrc];
		}
	
		return dataSrc !== &quot;&quot; ?
			_fnGetObjectDataFn( dataSrc )( json ) :
			json;
	}
	
	/**
	 * Generate the node required for filtering text
	 *  @returns {node} Filter control element
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlFilter ( settings )
	{
		var classes = settings.oClasses;
		var tableId = settings.sTableId;
		var language = settings.oLanguage;
		var previousSearch = settings.oPreviousSearch;
		var features = settings.aanFeatures;
		var input = &#x27;&lt;input type=&quot;search&quot; class=&quot;&#x27;+classes.sFilterInput+&#x27;&quot;/&gt;&#x27;;
	
		var str = language.sSearch;
		str = str.match(/_INPUT_/) ?
			str.replace(&#x27;_INPUT_&#x27;, input) :
			str+input;
	
		var filter = $(&#x27;&lt;div/&gt;&#x27;, {
				&#x27;id&#x27;: ! features.f ? tableId+&#x27;_filter&#x27; : null,
				&#x27;class&#x27;: classes.sFilter
			} )
			.append( $(&#x27;&lt;label/&gt;&#x27; ).append( str ) );
	
		var searchFn = function() {
			/* Update all other filter input elements for the new display */
			var n = features.f;
			var val = !this.value ? &quot;&quot; : this.value; // mental IE8 fix :-(
	
			/* Now do the filter */
			if ( val != previousSearch.sSearch ) {
				_fnFilterComplete( settings, {
					&quot;sSearch&quot;: val,
					&quot;bRegex&quot;: previousSearch.bRegex,
					&quot;bSmart&quot;: previousSearch.bSmart ,
					&quot;bCaseInsensitive&quot;: previousSearch.bCaseInsensitive
				} );
	
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			}
		};
	
		var searchDelay = settings.searchDelay !== null ?
			settings.searchDelay :
			_fnDataSource( settings ) === &#x27;ssp&#x27; ?
				400 :
				0;
	
		var jqFilter = $(&#x27;input&#x27;, filter)
			.val( previousSearch.sSearch )
			.attr( &#x27;placeholder&#x27;, language.sSearchPlaceholder )
			.on(
				&#x27;keyup.DT search.DT input.DT paste.DT cut.DT&#x27;,
				searchDelay ?
					_fnThrottle( searchFn, searchDelay ) :
					searchFn
			)
			.on( &#x27;keypress.DT&#x27;, function(e) {
				/* Prevent form submission */
				if ( e.keyCode == 13 ) {
					return false;
				}
			} )
			.attr(&#x27;aria-controls&#x27;, tableId);
	
		// Update the input elements whenever the table is filtered
		$(settings.nTable).on( &#x27;search.dt.DT&#x27;, function ( ev, s ) {
			if ( settings === s ) {
				// IE9 throws an &#x27;unknown error&#x27; if document.activeElement is used
				// inside an iframe or frame...
				try {
					if ( jqFilter[0] !== document.activeElement ) {
						jqFilter.val( previousSearch.sSearch );
					}
				}
				catch ( e ) {}
			}
		} );
	
		return filter[0];
	}
	
	
	/**
	 * Filter the table using both the global filter and column based filtering
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oSearch search information
	 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterComplete ( oSettings, oInput, iForce )
	{
		var oPrevSearch = oSettings.oPreviousSearch;
		var aoPrevSearch = oSettings.aoPreSearchCols;
		var fnSaveFilter = function ( oFilter ) {
			/* Save the filtering values */
			oPrevSearch.sSearch = oFilter.sSearch;
			oPrevSearch.bRegex = oFilter.bRegex;
			oPrevSearch.bSmart = oFilter.bSmart;
			oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
		};
		var fnRegex = function ( o ) {
			// Backwards compatibility with the bEscapeRegex option
			return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
		};
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo As per sort - can this be moved into an event handler?
		_fnColumnTypes( oSettings );
	
		/* In server-side processing all filtering is done by the server, so no point hanging around here */
		if ( _fnDataSource( oSettings ) != &#x27;ssp&#x27; )
		{
			/* Global filter */
			_fnFilter( oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive );
			fnSaveFilter( oInput );
	
			/* Now do the individual column filter */
			for ( var i=0 ; i&lt;aoPrevSearch.length ; i++ )
			{
				_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
					aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
			}
	
			/* Custom filtering */
			_fnFilterCustom( oSettings );
		}
		else
		{
			fnSaveFilter( oInput );
		}
	
		/* Tell the draw function we have been filtering */
		oSettings.bFiltered = true;
		_fnCallbackFire( oSettings, null, &#x27;search&#x27;, [oSettings] );
	}
	
	
	/**
	 * Apply custom filtering functions
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCustom( settings )
	{
		var filters = DataTable.ext.search;
		var displayRows = settings.aiDisplay;
		var row, rowIdx;
	
		for ( var i=0, ien=filters.length ; i&lt;ien ; i++ ) {
			var rows = [];
	
			// Loop over each row and see if it should be included
			for ( var j=0, jen=displayRows.length ; j&lt;jen ; j++ ) {
				rowIdx = displayRows[ j ];
				row = settings.aoData[ rowIdx ];
	
				if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
					rows.push( rowIdx );
				}
			}
	
			// So the array reference doesn&#x27;t break set the results into the
			// existing array
			displayRows.length = 0;
			$.merge( displayRows, rows );
		}
	}
	
	
	/**
	 * Filter the table on a per-column basis
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sInput string to filter on
	 *  @param {int} iColumn column to filter
	 *  @param {bool} bRegex treat search string as a regular expression or not
	 *  @param {bool} bSmart use smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterColumn ( settings, searchStr, colIdx, regex, smart, caseInsensitive )
	{
		if ( searchStr === &#x27;&#x27; ) {
			return;
		}
	
		var data;
		var out = [];
		var display = settings.aiDisplay;
		var rpSearch = _fnFilterCreateSearch( searchStr, regex, smart, caseInsensitive );
	
		for ( var i=0 ; i&lt;display.length ; i++ ) {
			data = settings.aoData[ display[i] ]._aFilterData[ colIdx ];
	
			if ( rpSearch.test( data ) ) {
				out.push( display[i] );
			}
		}
	
		settings.aiDisplay = out;
	}
	
	
	/**
	 * Filter the data table based on user input and draw the table
	 *  @param {object} settings dataTables settings object
	 *  @param {string} input string to filter on
	 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	 *  @param {bool} regex treat as a regular expression or not
	 *  @param {bool} smart perform smart filtering or not
	 *  @param {bool} caseInsensitive Do case insenstive matching or not
	 *  @memberof DataTable#oApi
	 */
	function _fnFilter( settings, input, force, regex, smart, caseInsensitive )
	{
		var rpSearch = _fnFilterCreateSearch( input, regex, smart, caseInsensitive );
		var prevSearch = settings.oPreviousSearch.sSearch;
		var displayMaster = settings.aiDisplayMaster;
		var display, invalidated, i;
		var filtered = [];
	
		// Need to take account of custom filtering functions - always filter
		if ( DataTable.ext.search.length !== 0 ) {
			force = true;
		}
	
		// Check if any of the rows were invalidated
		invalidated = _fnFilterData( settings );
	
		// If the input is blank - we just want the full data set
		if ( input.length &lt;= 0 ) {
			settings.aiDisplay = displayMaster.slice();
		}
		else {
			// New search - start from the master array
			if ( invalidated ||
				 force ||
				 prevSearch.length &gt; input.length ||
				 input.indexOf(prevSearch) !== 0 ||
				 settings.bSorted // On resort, the display master needs to be
				                  // re-filtered since indexes will have changed
			) {
				settings.aiDisplay = displayMaster.slice();
			}
	
			// Search the display array
			display = settings.aiDisplay;
	
			for ( i=0 ; i&lt;display.length ; i++ ) {
				if ( rpSearch.test( settings.aoData[ display[i] ]._sFilterRow ) ) {
					filtered.push( display[i] );
				}
			}
	
			settings.aiDisplay = filtered;
		}
	}
	
	
	/**
	 * Build a regular expression object suitable for searching a table
	 *  @param {string} sSearch string to search for
	 *  @param {bool} bRegex treat as a regular expression or not
	 *  @param {bool} bSmart perform smart filtering or not
	 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	 *  @returns {RegExp} constructed object
	 *  @memberof DataTable#oApi
	 */
	function _fnFilterCreateSearch( search, regex, smart, caseInsensitive )
	{
		search = regex ?
			search :
			_fnEscapeRegex( search );
		
		if ( smart ) {
			/* For smart filtering we want to allow the search to work regardless of
			 * word order. We also want double quoted text to be preserved, so word
			 * order is important - a la google. So this is what we want to
			 * generate:
			 * 
			 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
			 */
			var a = $.map( search.match( /&quot;[^&quot;]+&quot;|[^ ]+/g ) || [&#x27;&#x27;], function ( word ) {
				if ( word.charAt(0) === &#x27;&quot;&#x27; ) {
					var m = word.match( /^&quot;(.*)&quot;$/ );
					word = m ? m[1] : word;
				}
	
				return word.replace(&#x27;&quot;&#x27;, &#x27;&#x27;);
			} );
	
			search = &#x27;^(?=.*?&#x27;+a.join( &#x27;)(?=.*?&#x27; )+&#x27;).*$&#x27;;
		}
	
		return new RegExp( search, caseInsensitive ? &#x27;i&#x27; : &#x27;&#x27; );
	}
	
	
	/**
	 * Escape a string such that it can be used in a regular expression
	 *  @param {string} sVal string to escape
	 *  @returns {string} escaped string
	 *  @memberof DataTable#oApi
	 */
	var _fnEscapeRegex = DataTable.util.escapeRegex;
	
	var __filter_div = $(&#x27;&lt;div&gt;&#x27;)[0];
	var __filter_div_textContent = __filter_div.textContent !== undefined;
	
	// Update the filtering data for each row if needed (by invalidation or first run)
	function _fnFilterData ( settings )
	{
		var columns = settings.aoColumns;
		var column;
		var i, j, ien, jen, filterData, cellData, row;
		var fomatters = DataTable.ext.type.search;
		var wasInvalidated = false;
	
		for ( i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aFilterData ) {
				filterData = [];
	
				for ( j=0, jen=columns.length ; j&lt;jen ; j++ ) {
					column = columns[j];
	
					if ( column.bSearchable ) {
						cellData = _fnGetCellData( settings, i, j, &#x27;filter&#x27; );
	
						if ( fomatters[ column.sType ] ) {
							cellData = fomatters[ column.sType ]( cellData );
						}
	
						// Search in DataTables 1.10 is string based. In 1.11 this
						// should be altered to also allow strict type checking.
						if ( cellData === null ) {
							cellData = &#x27;&#x27;;
						}
	
						if ( typeof cellData !== &#x27;string&#x27; &amp;&amp; cellData.toString ) {
							cellData = cellData.toString();
						}
					}
					else {
						cellData = &#x27;&#x27;;
					}
	
					// If it looks like there is an HTML entity in the string,
					// attempt to decode it so sorting works as expected. Note that
					// we could use a single line of jQuery to do this, but the DOM
					// method used here is much faster http://jsperf.com/html-decode
					if ( cellData.indexOf &amp;&amp; cellData.indexOf(&#x27;&amp;&#x27;) !== -1 ) {
						__filter_div.innerHTML = cellData;
						cellData = __filter_div_textContent ?
							__filter_div.textContent :
							__filter_div.innerText;
					}
	
					if ( cellData.replace ) {
						cellData = cellData.replace(/[\r\n]/g, &#x27;&#x27;);
					}
	
					filterData.push( cellData );
				}
	
				row._aFilterData = filterData;
				row._sFilterRow = filterData.join(&#x27;  &#x27;);
				wasInvalidated = true;
			}
		}
	
		return wasInvalidated;
	}
	
	
	/**
	 * Convert from the internal Hungarian notation to camelCase for external
	 * interaction
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToCamel ( obj )
	{
		return {
			search:          obj.sSearch,
			smart:           obj.bSmart,
			regex:           obj.bRegex,
			caseInsensitive: obj.bCaseInsensitive
		};
	}
	
	
	
	/**
	 * Convert from camelCase notation to the internal Hungarian. We could use the
	 * Hungarian convert function here, but this is cleaner
	 *  @param {object} obj Object to convert
	 *  @returns {object} Inverted object
	 *  @memberof DataTable#oApi
	 */
	function _fnSearchToHung ( obj )
	{
		return {
			sSearch:          obj.search,
			bSmart:           obj.smart,
			bRegex:           obj.regex,
			bCaseInsensitive: obj.caseInsensitive
		};
	}
	
	/**
	 * Generate the node required for the info display
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Information element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlInfo ( settings )
	{
		var
			tid = settings.sTableId,
			nodes = settings.aanFeatures.i,
			n = $(&#x27;&lt;div/&gt;&#x27;, {
				&#x27;class&#x27;: settings.oClasses.sInfo,
				&#x27;id&#x27;: ! nodes ? tid+&#x27;_info&#x27; : null
			} );
	
		if ( ! nodes ) {
			// Update display on each draw
			settings.aoDrawCallback.push( {
				&quot;fn&quot;: _fnUpdateInfo,
				&quot;sName&quot;: &quot;information&quot;
			} );
	
			n
				.attr( &#x27;role&#x27;, &#x27;status&#x27; )
				.attr( &#x27;aria-live&#x27;, &#x27;polite&#x27; );
	
			// Table is described by our info div
			$(settings.nTable).attr( &#x27;aria-describedby&#x27;, tid+&#x27;_info&#x27; );
		}
	
		return n[0];
	}
	
	
	/**
	 * Update the information elements in the display
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnUpdateInfo ( settings )
	{
		/* Show information about the table */
		var nodes = settings.aanFeatures.i;
		if ( nodes.length === 0 ) {
			return;
		}
	
		var
			lang  = settings.oLanguage,
			start = settings._iDisplayStart+1,
			end   = settings.fnDisplayEnd(),
			max   = settings.fnRecordsTotal(),
			total = settings.fnRecordsDisplay(),
			out   = total ?
				lang.sInfo :
				lang.sInfoEmpty;
	
		if ( total !== max ) {
			/* Record set after filtering */
			out += &#x27; &#x27; + lang.sInfoFiltered;
		}
	
		// Convert the macros
		out += lang.sInfoPostFix;
		out = _fnInfoMacros( settings, out );
	
		var callback = lang.fnInfoCallback;
		if ( callback !== null ) {
			out = callback.call( settings.oInstance,
				settings, start, end, max, total, out
			);
		}
	
		$(nodes).html( out );
	}
	
	
	function _fnInfoMacros ( settings, str )
	{
		// When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
		// internally
		var
			formatter  = settings.fnFormatNumber,
			start      = settings._iDisplayStart+1,
			len        = settings._iDisplayLength,
			vis        = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return str.
			replace(/_START_/g, formatter.call( settings, start ) ).
			replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
			replace(/_MAX_/g,   formatter.call( settings, settings.fnRecordsTotal() ) ).
			replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
			replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
			replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) );
	}
	
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnInitialise ( settings )
	{
		var i, iLen, iAjaxStart=settings.iInitDisplayStart;
		var columns = settings.aoColumns, column;
		var features = settings.oFeatures;
		var deferLoading = settings.bDeferLoading; // value modified by the draw
	
		/* Ensure that the table data is fully initialised */
		if ( ! settings.bInitialised ) {
			setTimeout( function(){ _fnInitialise( settings ); }, 200 );
			return;
		}
	
		/* Show the display HTML options */
		_fnAddOptionsHtml( settings );
	
		/* Build and draw the header / footer for the table */
		_fnBuildHead( settings );
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );
	
		/* Calculate sizes for columns */
		if ( features.bAutoWidth ) {
			_fnCalculateColumnWidths( settings );
		}
	
		for ( i=0, iLen=columns.length ; i&lt;iLen ; i++ ) {
			column = columns[i];
	
			if ( column.sWidth ) {
				column.nTh.style.width = _fnStringToCss( column.sWidth );
			}
		}
	
		_fnCallbackFire( settings, null, &#x27;preInit&#x27;, [settings] );
	
		// If there is default sorting required - let&#x27;s do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show &#x27;loading&#x27; message possibly)
		_fnReDraw( settings );
	
		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		var dataSrc = _fnDataSource( settings );
		if ( dataSrc != &#x27;ssp&#x27; || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == &#x27;ajax&#x27; ) {
				_fnBuildAjax( settings, [], function(json) {
					var aData = _fnAjaxDataSrc( settings, json );
	
					// Got the data - add it to the table
					for ( i=0 ; i&lt;aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}
	
					// Reset the init display for cookie saving. We&#x27;ve already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear &#x27;fresh&#x27;
					settings.iInitDisplayStart = iAjaxStart;
	
					_fnReDraw( settings );
	
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings, json );
				}, settings );
			}
			else {
				_fnProcessingDisplay( settings, false );
				_fnInitComplete( settings );
			}
		}
	}
	
	
	/**
	 * Draw the table for the first time, adding all required features
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	 *    with client-side processing (optional)
	 *  @memberof DataTable#oApi
	 */
	function _fnInitComplete ( settings, json )
	{
		settings._bInitComplete = true;
	
		// When data was added after the initialisation (data or Ajax) we need to
		// calculate the column sizing
		if ( json || settings.oInit.aaData ) {
			_fnAdjustColumnSizing( settings );
		}
	
		_fnCallbackFire( settings, null, &#x27;plugin-init&#x27;, [settings, json] );
		_fnCallbackFire( settings, &#x27;aoInitComplete&#x27;, &#x27;init&#x27;, [settings, json] );
	}
	
	
	function _fnLengthChange ( settings, val )
	{
		var len = parseInt( val, 10 );
		settings._iDisplayLength = len;
	
		_fnLengthOverflow( settings );
	
		// Fire length change event
		_fnCallbackFire( settings, null, &#x27;length&#x27;, [settings, len] );
	}
	
	
	/**
	 * Generate the node required for user display length changing
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Display length feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlLength ( settings )
	{
		var
			classes  = settings.oClasses,
			tableId  = settings.sTableId,
			menu     = settings.aLengthMenu,
			d2       = $.isArray( menu[0] ),
			lengths  = d2 ? menu[0] : menu,
			language = d2 ? menu[1] : menu;
	
		var select = $(&#x27;&lt;select/&gt;&#x27;, {
			&#x27;name&#x27;:          tableId+&#x27;_length&#x27;,
			&#x27;aria-controls&#x27;: tableId,
			&#x27;class&#x27;:         classes.sLengthSelect
		} );
	
		for ( var i=0, ien=lengths.length ; i&lt;ien ; i++ ) {
			select[0][ i ] = new Option(
				typeof language[i] === &#x27;number&#x27; ?
					settings.fnFormatNumber( language[i] ) :
					language[i],
				lengths[i]
			);
		}
	
		var div = $(&#x27;&lt;div&gt;&lt;label/&gt;&lt;/div&gt;&#x27;).addClass( classes.sLength );
		if ( ! settings.aanFeatures.l ) {
			div[0].id = tableId+&#x27;_length&#x27;;
		}
	
		div.children().append(
			settings.oLanguage.sLengthMenu.replace( &#x27;_MENU_&#x27;, select[0].outerHTML )
		);
	
		// Can&#x27;t use &#x60;select&#x60; variable as user might provide their own and the
		// reference is broken by the use of outerHTML
		$(&#x27;select&#x27;, div)
			.val( settings._iDisplayLength )
			.on( &#x27;change.DT&#x27;, function(e) {
				_fnLengthChange( settings, $(this).val() );
				_fnDraw( settings );
			} );
	
		// Update node value whenever anything changes the table&#x27;s length
		$(settings.nTable).on( &#x27;length.dt.DT&#x27;, function (e, s, len) {
			if ( settings === s ) {
				$(&#x27;select&#x27;, div).val( len );
			}
		} );
	
		return div[0];
	}
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Note that most of the paging logic is done in
	 * DataTable.ext.pager
	 */
	
	/**
	 * Generate the node required for default pagination
	 *  @param {object} oSettings dataTables settings object
	 *  @returns {node} Pagination feature node
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlPaginate ( settings )
	{
		var
			type   = settings.sPaginationType,
			plugin = DataTable.ext.pager[ type ],
			modern = typeof plugin === &#x27;function&#x27;,
			redraw = function( settings ) {
				_fnDraw( settings );
			},
			node = $(&#x27;&lt;div/&gt;&#x27;).addClass( settings.oClasses.sPaging + type )[0],
			features = settings.aanFeatures;
	
		if ( ! modern ) {
			plugin.fnInit( settings, node, redraw );
		}
	
		/* Add a draw callback for the pagination on first instance, to update the paging display */
		if ( ! features.p )
		{
			node.id = settings.sTableId+&#x27;_paginate&#x27;;
	
			settings.aoDrawCallback.push( {
				&quot;fn&quot;: function( settings ) {
					if ( modern ) {
						var
							start      = settings._iDisplayStart,
							len        = settings._iDisplayLength,
							visRecords = settings.fnRecordsDisplay(),
							all        = len === -1,
							page = all ? 0 : Math.ceil( start / len ),
							pages = all ? 1 : Math.ceil( visRecords / len ),
							buttons = plugin(page, pages),
							i, ien;
	
						for ( i=0, ien=features.p.length ; i&lt;ien ; i++ ) {
							_fnRenderer( settings, &#x27;pageButton&#x27; )(
								settings, features.p[i], i, buttons, page, pages
							);
						}
					}
					else {
						plugin.fnUpdate( settings, redraw );
					}
				},
				&quot;sName&quot;: &quot;pagination&quot;
			} );
		}
	
		return node;
	}
	
	
	/**
	 * Alter the display settings to change the page
	 *  @param {object} settings DataTables settings object
	 *  @param {string|int} action Paging action to take: &quot;first&quot;, &quot;previous&quot;,
	 *    &quot;next&quot; or &quot;last&quot; or page number to jump to (integer)
	 *  @param [bool] redraw Automatically draw the update or not
	 *  @returns {bool} true page has changed, false - no change
	 *  @memberof DataTable#oApi
	 */
	function _fnPageChange ( settings, action, redraw )
	{
		var
			start     = settings._iDisplayStart,
			len       = settings._iDisplayLength,
			records   = settings.fnRecordsDisplay();
	
		if ( records === 0 || len === -1 )
		{
			start = 0;
		}
		else if ( typeof action === &quot;number&quot; )
		{
			start = action * len;
	
			if ( start &gt; records )
			{
				start = 0;
			}
		}
		else if ( action == &quot;first&quot; )
		{
			start = 0;
		}
		else if ( action == &quot;previous&quot; )
		{
			start = len &gt;= 0 ?
				start - len :
				0;
	
			if ( start &lt; 0 )
			{
			  start = 0;
			}
		}
		else if ( action == &quot;next&quot; )
		{
			if ( start + len &lt; records )
			{
				start += len;
			}
		}
		else if ( action == &quot;last&quot; )
		{
			start = Math.floor( (records-1) / len) * len;
		}
		else
		{
			_fnLog( settings, 0, &quot;Unknown paging action: &quot;+action, 5 );
		}
	
		var changed = settings._iDisplayStart !== start;
		settings._iDisplayStart = start;
	
		if ( changed ) {
			_fnCallbackFire( settings, null, &#x27;page&#x27;, [settings] );
	
			if ( redraw ) {
				_fnDraw( settings );
			}
		}
	
		return changed;
	}
	
	
	
	/**
	 * Generate the node required for the processing node
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Processing element
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlProcessing ( settings )
	{
		return $(&#x27;&lt;div/&gt;&#x27;, {
				&#x27;id&#x27;: ! settings.aanFeatures.r ? settings.sTableId+&#x27;_processing&#x27; : null,
				&#x27;class&#x27;: settings.oClasses.sProcessing
			} )
			.html( settings.oLanguage.sProcessing )
			.insertBefore( settings.nTable )[0];
	}
	
	
	/**
	 * Display or hide the processing indicator
	 *  @param {object} settings dataTables settings object
	 *  @param {bool} show Show the processing indicator (true) or not (false)
	 *  @memberof DataTable#oApi
	 */
	function _fnProcessingDisplay ( settings, show )
	{
		if ( settings.oFeatures.bProcessing ) {
			$(settings.aanFeatures.r).css( &#x27;display&#x27;, show ? &#x27;block&#x27; : &#x27;none&#x27; );
		}
	
		_fnCallbackFire( settings, null, &#x27;processing&#x27;, [settings, show] );
	}
	
	/**
	 * Add any control elements for the table - specifically scrolling
	 *  @param {object} settings dataTables settings object
	 *  @returns {node} Node to add to the DOM
	 *  @memberof DataTable#oApi
	 */
	function _fnFeatureHtmlTable ( settings )
	{
		var table = $(settings.nTable);
	
		// Add the ARIA grid role to the table
		table.attr( &#x27;role&#x27;, &#x27;grid&#x27; );
	
		// Scrolling from here on in
		var scroll = settings.oScroll;
	
		if ( scroll.sX === &#x27;&#x27; &amp;&amp; scroll.sY === &#x27;&#x27; ) {
			return settings.nTable;
		}
	
		var scrollX = scroll.sX;
		var scrollY = scroll.sY;
		var classes = settings.oClasses;
		var caption = table.children(&#x27;caption&#x27;);
		var captionSide = caption.length ? caption[0]._captionSide : null;
		var headerClone = $( table[0].cloneNode(false) );
		var footerClone = $( table[0].cloneNode(false) );
		var footer = table.children(&#x27;tfoot&#x27;);
		var _div = &#x27;&lt;div/&gt;&#x27;;
		var size = function ( s ) {
			return !s ? null : _fnStringToCss( s );
		};
	
		if ( ! footer.length ) {
			footer = null;
		}
	
		/*
		 * The HTML structure that we want to generate in this function is:
		 *  div - scroller
		 *    div - scroll head
		 *      div - scroll head inner
		 *        table - scroll head table
		 *          thead - thead
		 *    div - scroll body
		 *      table - table (master table)
		 *        thead - thead clone for sizing
		 *        tbody - tbody
		 *    div - scroll foot
		 *      div - scroll foot inner
		 *        table - scroll foot table
		 *          tfoot - tfoot
		 */
		var scroller = $( _div, { &#x27;class&#x27;: classes.sScrollWrapper } )
			.append(
				$(_div, { &#x27;class&#x27;: classes.sScrollHead } )
					.css( {
						overflow: &#x27;hidden&#x27;,
						position: &#x27;relative&#x27;,
						border: 0,
						width: scrollX ? size(scrollX) : &#x27;100%&#x27;
					} )
					.append(
						$(_div, { &#x27;class&#x27;: classes.sScrollHeadInner } )
							.css( {
								&#x27;box-sizing&#x27;: &#x27;content-box&#x27;,
								width: scroll.sXInner || &#x27;100%&#x27;
							} )
							.append(
								headerClone
									.removeAttr(&#x27;id&#x27;)
									.css( &#x27;margin-left&#x27;, 0 )
									.append( captionSide === &#x27;top&#x27; ? caption : null )
									.append(
										table.children(&#x27;thead&#x27;)
									)
							)
					)
			)
			.append(
				$(_div, { &#x27;class&#x27;: classes.sScrollBody } )
					.css( {
						position: &#x27;relative&#x27;,
						overflow: &#x27;auto&#x27;,
						width: size( scrollX )
					} )
					.append( table )
			);
	
		if ( footer ) {
			scroller.append(
				$(_div, { &#x27;class&#x27;: classes.sScrollFoot } )
					.css( {
						overflow: &#x27;hidden&#x27;,
						border: 0,
						width: scrollX ? size(scrollX) : &#x27;100%&#x27;
					} )
					.append(
						$(_div, { &#x27;class&#x27;: classes.sScrollFootInner } )
							.append(
								footerClone
									.removeAttr(&#x27;id&#x27;)
									.css( &#x27;margin-left&#x27;, 0 )
									.append( captionSide === &#x27;bottom&#x27; ? caption : null )
									.append(
										table.children(&#x27;tfoot&#x27;)
									)
							)
					)
			);
		}
	
		var children = scroller.children();
		var scrollHead = children[0];
		var scrollBody = children[1];
		var scrollFoot = footer ? children[2] : null;
	
		// When the body is scrolled, then we also want to scroll the headers
		if ( scrollX ) {
			$(scrollBody).on( &#x27;scroll.DT&#x27;, function (e) {
				var scrollLeft = this.scrollLeft;
	
				scrollHead.scrollLeft = scrollLeft;
	
				if ( footer ) {
					scrollFoot.scrollLeft = scrollLeft;
				}
			} );
		}
	
		$(scrollBody).css(
			scrollY &amp;&amp; scroll.bCollapse ? &#x27;max-height&#x27; : &#x27;height&#x27;, 
			scrollY
		);
	
		settings.nScrollHead = scrollHead;
		settings.nScrollBody = scrollBody;
		settings.nScrollFoot = scrollFoot;
	
		// On redraw - align columns
		settings.aoDrawCallback.push( {
			&quot;fn&quot;: _fnScrollDraw,
			&quot;sName&quot;: &quot;scrolling&quot;
		} );
	
		return scroller[0];
	}
	
	
	
	/**
	 * Update the header, footer and body tables for resizing - i.e. column
	 * alignment.
	 *
	 * Welcome to the most horrible function DataTables. The process that this
	 * function follows is basically:
	 *   1. Re-create the table inside the scrolling div
	 *   2. Take live measurements from the DOM
	 *   3. Apply the measurements to align the columns
	 *   4. Clean up
	 *
	 *  @param {object} settings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnScrollDraw ( settings )
	{
		// Given that this is such a monster function, a lot of variables are use
		// to try and keep the minimised size as small as possible
		var
			scroll         = settings.oScroll,
			scrollX        = scroll.sX,
			scrollXInner   = scroll.sXInner,
			scrollY        = scroll.sY,
			barWidth       = scroll.iBarWidth,
			divHeader      = $(settings.nScrollHead),
			divHeaderStyle = divHeader[0].style,
			divHeaderInner = divHeader.children(&#x27;div&#x27;),
			divHeaderInnerStyle = divHeaderInner[0].style,
			divHeaderTable = divHeaderInner.children(&#x27;table&#x27;),
			divBodyEl      = settings.nScrollBody,
			divBody        = $(divBodyEl),
			divBodyStyle   = divBodyEl.style,
			divFooter      = $(settings.nScrollFoot),
			divFooterInner = divFooter.children(&#x27;div&#x27;),
			divFooterTable = divFooterInner.children(&#x27;table&#x27;),
			header         = $(settings.nTHead),
			table          = $(settings.nTable),
			tableEl        = table[0],
			tableStyle     = tableEl.style,
			footer         = settings.nTFoot ? $(settings.nTFoot) : null,
			browser        = settings.oBrowser,
			ie67           = browser.bScrollOversize,
			dtHeaderCells  = _pluck( settings.aoColumns, &#x27;nTh&#x27; ),
			headerTrgEls, footerTrgEls,
			headerSrcEls, footerSrcEls,
			headerCopy, footerCopy,
			headerWidths=[], footerWidths=[],
			headerContent=[], footerContent=[],
			idx, correction, sanityWidth,
			zeroOut = function(nSizer) {
				var style = nSizer.style;
				style.paddingTop = &quot;0&quot;;
				style.paddingBottom = &quot;0&quot;;
				style.borderTopWidth = &quot;0&quot;;
				style.borderBottomWidth = &quot;0&quot;;
				style.height = 0;
			};
	
		// If the scrollbar visibility has changed from the last draw, we need to
		// adjust the column sizes as the table width will have changed to account
		// for the scrollbar
		var scrollBarVis = divBodyEl.scrollHeight &gt; divBodyEl.clientHeight;
		
		if ( settings.scrollBarVis !== scrollBarVis &amp;&amp; settings.scrollBarVis !== undefined ) {
			settings.scrollBarVis = scrollBarVis;
			_fnAdjustColumnSizing( settings );
			return; // adjust column sizing will call this function again
		}
		else {
			settings.scrollBarVis = scrollBarVis;
		}
	
		/*
		 * 1. Re-create the table inside the scrolling div
		 */
	
		// Remove the old minimised thead and tfoot elements in the inner table
		table.children(&#x27;thead, tfoot&#x27;).remove();
	
		if ( footer ) {
			footerCopy = footer.clone().prependTo( table );
			footerTrgEls = footer.find(&#x27;tr&#x27;); // the original tfoot is in its own table and must be sized
			footerSrcEls = footerCopy.find(&#x27;tr&#x27;);
		}
	
		// Clone the current header and footer elements and then place it into the inner table
		headerCopy = header.clone().prependTo( table );
		headerTrgEls = header.find(&#x27;tr&#x27;); // original header is in its own table
		headerSrcEls = headerCopy.find(&#x27;tr&#x27;);
		headerCopy.find(&#x27;th, td&#x27;).removeAttr(&#x27;tabindex&#x27;);
	
	
		/*
		 * 2. Take live measurements from the DOM - do not alter the DOM itself!
		 */
	
		// Remove old sizing and apply the calculated column widths
		// Get the unique column headers in the newly created (cloned) header. We want to apply the
		// calculated sizes to this header
		if ( ! scrollX )
		{
			divBodyStyle.width = &#x27;100%&#x27;;
			divHeader[0].style.width = &#x27;100%&#x27;;
		}
	
		$.each( _fnGetUniqueThs( settings, headerCopy ), function ( i, el ) {
			idx = _fnVisibleToColumnIndex( settings, i );
			el.style.width = settings.aoColumns[idx].sWidth;
		} );
	
		if ( footer ) {
			_fnApplyToChildren( function(n) {
				n.style.width = &quot;&quot;;
			}, footerSrcEls );
		}
	
		// Size the table as a whole
		sanityWidth = table.outerWidth();
		if ( scrollX === &quot;&quot; ) {
			// No x scrolling
			tableStyle.width = &quot;100%&quot;;
	
			// IE7 will make the width of the table when 100% include the scrollbar
			// - which is shouldn&#x27;t. When there is a scrollbar we need to take this
			// into account.
			if ( ie67 &amp;&amp; (table.find(&#x27;tbody&#x27;).height() &gt; divBodyEl.offsetHeight ||
				divBody.css(&#x27;overflow-y&#x27;) == &quot;scroll&quot;)
			) {
				tableStyle.width = _fnStringToCss( table.outerWidth() - barWidth);
			}
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
		else if ( scrollXInner !== &quot;&quot; ) {
			// legacy x scroll inner has been given - use it
			tableStyle.width = _fnStringToCss(scrollXInner);
	
			// Recalculate the sanity width
			sanityWidth = table.outerWidth();
		}
	
		// Hidden header should have zero height, so remove padding and borders. Then
		// set the width based on the real headers
	
		// Apply all styles in one pass
		_fnApplyToChildren( zeroOut, headerSrcEls );
	
		// Read all widths in next pass
		_fnApplyToChildren( function(nSizer) {
			headerContent.push( nSizer.innerHTML );
			headerWidths.push( _fnStringToCss( $(nSizer).css(&#x27;width&#x27;) ) );
		}, headerSrcEls );
	
		// Apply all widths in final pass
		_fnApplyToChildren( function(nToSize, i) {
			// Only apply widths to the DataTables detected header cells - this
			// prevents complex headers from having contradictory sizes applied
			if ( $.inArray( nToSize, dtHeaderCells ) !== -1 ) {
				nToSize.style.width = headerWidths[i];
			}
		}, headerTrgEls );
	
		$(headerSrcEls).height(0);
	
		/* Same again with the footer if we have one */
		if ( footer )
		{
			_fnApplyToChildren( zeroOut, footerSrcEls );
	
			_fnApplyToChildren( function(nSizer) {
				footerContent.push( nSizer.innerHTML );
				footerWidths.push( _fnStringToCss( $(nSizer).css(&#x27;width&#x27;) ) );
			}, footerSrcEls );
	
			_fnApplyToChildren( function(nToSize, i) {
				nToSize.style.width = footerWidths[i];
			}, footerTrgEls );
	
			$(footerSrcEls).height(0);
		}
	
	
		/*
		 * 3. Apply the measurements
		 */
	
		// &quot;Hide&quot; the header and footer that we used for the sizing. We need to keep
		// the content of the cell so that the width applied to the header and body
		// both match, but we want to hide it completely. We want to also fix their
		// width to what they currently are
		_fnApplyToChildren( function(nSizer, i) {
			nSizer.innerHTML = &#x27;&lt;div class=&quot;dataTables_sizing&quot; style=&quot;height:0;overflow:hidden;&quot;&gt;&#x27;+headerContent[i]+&#x27;&lt;/div&gt;&#x27;;
			nSizer.style.width = headerWidths[i];
		}, headerSrcEls );
	
		if ( footer )
		{
			_fnApplyToChildren( function(nSizer, i) {
				nSizer.innerHTML = &#x27;&lt;div class=&quot;dataTables_sizing&quot; style=&quot;height:0;overflow:hidden;&quot;&gt;&#x27;+footerContent[i]+&#x27;&lt;/div&gt;&#x27;;
				nSizer.style.width = footerWidths[i];
			}, footerSrcEls );
		}
	
		// Sanity check that the table is of a sensible width. If not then we are going to get
		// misalignment - try to prevent this by not allowing the table to shrink below its min width
		if ( table.outerWidth() &lt; sanityWidth )
		{
			// The min width depends upon if we have a vertical scrollbar visible or not */
			correction = ((divBodyEl.scrollHeight &gt; divBodyEl.offsetHeight ||
				divBody.css(&#x27;overflow-y&#x27;) == &quot;scroll&quot;)) ?
					sanityWidth+barWidth :
					sanityWidth;
	
			// IE6/7 are a law unto themselves...
			if ( ie67 &amp;&amp; (divBodyEl.scrollHeight &gt;
				divBodyEl.offsetHeight || divBody.css(&#x27;overflow-y&#x27;) == &quot;scroll&quot;)
			) {
				tableStyle.width = _fnStringToCss( correction-barWidth );
			}
	
			// And give the user a warning that we&#x27;ve stopped the table getting too small
			if ( scrollX === &quot;&quot; || scrollXInner !== &quot;&quot; ) {
				_fnLog( settings, 1, &#x27;Possible column misalignment&#x27;, 6 );
			}
		}
		else
		{
			correction = &#x27;100%&#x27;;
		}
	
		// Apply to the container elements
		divBodyStyle.width = _fnStringToCss( correction );
		divHeaderStyle.width = _fnStringToCss( correction );
	
		if ( footer ) {
			settings.nScrollFoot.style.width = _fnStringToCss( correction );
		}
	
	
		/*
		 * 4. Clean up
		 */
		if ( ! scrollY ) {
			/* IE7&lt; puts a vertical scrollbar in place (when it shouldn&#x27;t be) due to subtracting
			 * the scrollbar height from the visible display, rather than adding it on. We need to
			 * set the height in order to sort this. Don&#x27;t want to do it in any other browsers.
			 */
			if ( ie67 ) {
				divBodyStyle.height = _fnStringToCss( tableEl.offsetHeight+barWidth );
			}
		}
	
		/* Finally set the width&#x27;s of the header and footer tables */
		var iOuterWidth = table.outerWidth();
		divHeaderTable[0].style.width = _fnStringToCss( iOuterWidth );
		divHeaderInnerStyle.width = _fnStringToCss( iOuterWidth );
	
		// Figure out if there are scrollbar present - if so then we need a the header and footer to
		// provide a bit more space to allow &quot;overflow&quot; scrolling (i.e. past the scrollbar)
		var bScrolling = table.height() &gt; divBodyEl.clientHeight || divBody.css(&#x27;overflow-y&#x27;) == &quot;scroll&quot;;
		var padding = &#x27;padding&#x27; + (browser.bScrollbarLeft ? &#x27;Left&#x27; : &#x27;Right&#x27; );
		divHeaderInnerStyle[ padding ] = bScrolling ? barWidth+&quot;px&quot; : &quot;0px&quot;;
	
		if ( footer ) {
			divFooterTable[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style.width = _fnStringToCss( iOuterWidth );
			divFooterInner[0].style[padding] = bScrolling ? barWidth+&quot;px&quot; : &quot;0px&quot;;
		}
	
		// Correct DOM ordering for colgroup - comes before the thead
		table.children(&#x27;colgroup&#x27;).insertBefore( table.children(&#x27;thead&#x27;) );
	
		/* Adjust the position of the header in case we loose the y-scrollbar */
		divBody.scroll();
	
		// If sorting or filtering has occurred, jump the scrolling back to the top
		// only if we aren&#x27;t holding the position
		if ( (settings.bSorted || settings.bFiltered) &amp;&amp; ! settings._drawHold ) {
			divBodyEl.scrollTop = 0;
		}
	}
	
	
	
	/**
	 * Apply a given function to the display child nodes of an element array (typically
	 * TD children of TR rows
	 *  @param {function} fn Method to apply to the objects
	 *  @param array {nodes} an1 List of elements to look through for display children
	 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	 *  @memberof DataTable#oApi
	 */
	function _fnApplyToChildren( fn, an1, an2 )
	{
		var index=0, i=0, iLen=an1.length;
		var nNode1, nNode2;
	
		while ( i &lt; iLen ) {
			nNode1 = an1[i].firstChild;
			nNode2 = an2 ? an2[i].firstChild : null;
	
			while ( nNode1 ) {
				if ( nNode1.nodeType === 1 ) {
					if ( an2 ) {
						fn( nNode1, nNode2, index );
					}
					else {
						fn( nNode1, index );
					}
	
					index++;
				}
	
				nNode1 = nNode1.nextSibling;
				nNode2 = an2 ? nNode2.nextSibling : null;
			}
	
			i++;
		}
	}
	
	
	
	var __re_html_remove = /&lt;.*?&gt;/g;
	
	
	/**
	 * Calculate the width of columns for the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnCalculateColumnWidths ( oSettings )
	{
		var
			table = oSettings.nTable,
			columns = oSettings.aoColumns,
			scroll = oSettings.oScroll,
			scrollY = scroll.sY,
			scrollX = scroll.sX,
			scrollXInner = scroll.sXInner,
			columnCount = columns.length,
			visibleColumns = _fnGetColumns( oSettings, &#x27;bVisible&#x27; ),
			headerCells = $(&#x27;th&#x27;, oSettings.nTHead),
			tableWidthAttr = table.getAttribute(&#x27;width&#x27;), // from DOM element
			tableContainer = table.parentNode,
			userInputs = false,
			i, column, columnIdx, width, outerWidth,
			browser = oSettings.oBrowser,
			ie67 = browser.bScrollOversize;
	
		var styleWidth = table.style.width;
		if ( styleWidth &amp;&amp; styleWidth.indexOf(&#x27;%&#x27;) !== -1 ) {
			tableWidthAttr = styleWidth;
		}
	
		/* Convert any user input sizes into pixel sizes */
		for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
			column = columns[ visibleColumns[i] ];
	
			if ( column.sWidth !== null ) {
				column.sWidth = _fnConvertToWidth( column.sWidthOrig, tableContainer );
	
				userInputs = true;
			}
		}
	
		/* If the number of columns in the DOM equals the number that we have to
		 * process in DataTables, then we can use the offsets that are created by
		 * the web- browser. No custom sizes can be set in order for this to happen,
		 * nor scrolling used
		 */
		if ( ie67 || ! userInputs &amp;&amp; ! scrollX &amp;&amp; ! scrollY &amp;&amp;
		     columnCount == _fnVisbleColumns( oSettings ) &amp;&amp;
		     columnCount == headerCells.length
		) {
			for ( i=0 ; i&lt;columnCount ; i++ ) {
				var colIdx = _fnVisibleToColumnIndex( oSettings, i );
	
				if ( colIdx !== null ) {
					columns[ colIdx ].sWidth = _fnStringToCss( headerCells.eq(i).width() );
				}
			}
		}
		else
		{
			// Otherwise construct a single row, worst case, table with the widest
			// node in the data, assign any user defined widths, then insert it into
			// the DOM and allow the browser to do all the hard work of calculating
			// table widths
			var tmpTable = $(table).clone() // don&#x27;t use cloneNode - IE8 will remove events on the main table
				.css( &#x27;visibility&#x27;, &#x27;hidden&#x27; )
				.removeAttr( &#x27;id&#x27; );
	
			// Clean up the table body
			tmpTable.find(&#x27;tbody tr&#x27;).remove();
			var tr = $(&#x27;&lt;tr/&gt;&#x27;).appendTo( tmpTable.find(&#x27;tbody&#x27;) );
	
			// Clone the table header and footer - we can&#x27;t use the header / footer
			// from the cloned table, since if scrolling is active, the table&#x27;s
			// real header and footer are contained in different table tags
			tmpTable.find(&#x27;thead, tfoot&#x27;).remove();
			tmpTable
				.append( $(oSettings.nTHead).clone() )
				.append( $(oSettings.nTFoot).clone() );
	
			// Remove any assigned widths from the footer (from scrolling)
			tmpTable.find(&#x27;tfoot th, tfoot td&#x27;).css(&#x27;width&#x27;, &#x27;&#x27;);
	
			// Apply custom sizing to the cloned header
			headerCells = _fnGetUniqueThs( oSettings, tmpTable.find(&#x27;thead&#x27;)[0] );
	
			for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
				column = columns[ visibleColumns[i] ];
	
				headerCells[i].style.width = column.sWidthOrig !== null &amp;&amp; column.sWidthOrig !== &#x27;&#x27; ?
					_fnStringToCss( column.sWidthOrig ) :
					&#x27;&#x27;;
	
				// For scrollX we need to force the column width otherwise the
				// browser will collapse it. If this width is smaller than the
				// width the column requires, then it will have no effect
				if ( column.sWidthOrig &amp;&amp; scrollX ) {
					$( headerCells[i] ).append( $(&#x27;&lt;div/&gt;&#x27;).css( {
						width: column.sWidthOrig,
						margin: 0,
						padding: 0,
						border: 0,
						height: 1
					} ) );
				}
			}
	
			// Find the widest cell for each column and put it into the table
			if ( oSettings.aoData.length ) {
				for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
					columnIdx = visibleColumns[i];
					column = columns[ columnIdx ];
	
					$( _fnGetWidestNode( oSettings, columnIdx ) )
						.clone( false )
						.append( column.sContentPadding )
						.appendTo( tr );
				}
			}
	
			// Tidy the temporary table - remove name attributes so there aren&#x27;t
			// duplicated in the dom (radio elements for example)
			$(&#x27;[name]&#x27;, tmpTable).removeAttr(&#x27;name&#x27;);
	
			// Table has been built, attach to the document so we can work with it.
			// A holding element is used, positioned at the top of the container
			// with minimal height, so it has no effect on if the container scrolls
			// or not. Otherwise it might trigger scrolling when it actually isn&#x27;t
			// needed
			var holder = $(&#x27;&lt;div/&gt;&#x27;).css( scrollX || scrollY ?
					{
						position: &#x27;absolute&#x27;,
						top: 0,
						left: 0,
						height: 1,
						right: 0,
						overflow: &#x27;hidden&#x27;
					} :
					{}
				)
				.append( tmpTable )
				.appendTo( tableContainer );
	
			// When scrolling (X or Y) we want to set the width of the table as 
			// appropriate. However, when not scrolling leave the table width as it
			// is. This results in slightly different, but I think correct behaviour
			if ( scrollX &amp;&amp; scrollXInner ) {
				tmpTable.width( scrollXInner );
			}
			else if ( scrollX ) {
				tmpTable.css( &#x27;width&#x27;, &#x27;auto&#x27; );
				tmpTable.removeAttr(&#x27;width&#x27;);
	
				// If there is no width attribute or style, then allow the table to
				// collapse
				if ( tmpTable.width() &lt; tableContainer.clientWidth &amp;&amp; tableWidthAttr ) {
					tmpTable.width( tableContainer.clientWidth );
				}
			}
			else if ( scrollY ) {
				tmpTable.width( tableContainer.clientWidth );
			}
			else if ( tableWidthAttr ) {
				tmpTable.width( tableWidthAttr );
			}
	
			// Get the width of each column in the constructed table - we need to
			// know the inner width (so it can be assigned to the other table&#x27;s
			// cells) and the outer width so we can calculate the full width of the
			// table. This is safe since DataTables requires a unique cell for each
			// column, but if ever a header can span multiple columns, this will
			// need to be modified.
			var total = 0;
			for ( i=0 ; i&lt;visibleColumns.length ; i++ ) {
				var cell = $(headerCells[i]);
				var border = cell.outerWidth() - cell.width();
	
				// Use getBounding... where possible (not IE8-) because it can give
				// sub-pixel accuracy, which we then want to round up!
				var bounding = browser.bBounding ?
					Math.ceil( headerCells[i].getBoundingClientRect().width ) :
					cell.outerWidth();
	
				// Total is tracked to remove any sub-pixel errors as the outerWidth
				// of the table might not equal the total given here (IE!).
				total += bounding;
	
				// Width for each column to use
				columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding - border );
			}
	
			table.style.width = _fnStringToCss( total );
	
			// Finished with the table - ditch it
			holder.remove();
		}
	
		// If there is a width attr, we want to attach an event listener which
		// allows the table sizing to automatically adjust when the window is
		// resized. Use the width attr rather than CSS, since we can&#x27;t know if the
		// CSS is a relative value or absolute - DOM read is always px.
		if ( tableWidthAttr ) {
			table.style.width = _fnStringToCss( tableWidthAttr );
		}
	
		if ( (tableWidthAttr || scrollX) &amp;&amp; ! oSettings._reszEvt ) {
			var bindResize = function () {
				$(window).on(&#x27;resize.DT-&#x27;+oSettings.sInstance, _fnThrottle( function () {
					_fnAdjustColumnSizing( oSettings );
				} ) );
			};
	
			// IE6/7 will crash if we bind a resize event handler on page load.
			// To be removed in 1.11 which drops IE6/7 support
			if ( ie67 ) {
				setTimeout( bindResize, 1000 );
			}
			else {
				bindResize();
			}
	
			oSettings._reszEvt = true;
		}
	}
	
	
	/**
	 * Throttle the calls to a function. Arguments and context are maintained for
	 * the throttled function
	 *  @param {function} fn Function to be called
	 *  @param {int} [freq=200] call frequency in mS
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#oApi
	 */
	var _fnThrottle = DataTable.util.throttle;
	
	
	/**
	 * Convert a CSS unit width to pixels (e.g. 2em)
	 *  @param {string} width width to be converted
	 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	 *  @returns {int} width in pixels
	 *  @memberof DataTable#oApi
	 */
	function _fnConvertToWidth ( width, parent )
	{
		if ( ! width ) {
			return 0;
		}
	
		var n = $(&#x27;&lt;div/&gt;&#x27;)
			.css( &#x27;width&#x27;, _fnStringToCss( width ) )
			.appendTo( parent || document.body );
	
		var val = n[0].offsetWidth;
		n.remove();
	
		return val;
	}
	
	
	/**
	 * Get the widest node
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {node} widest table node
	 *  @memberof DataTable#oApi
	 */
	function _fnGetWidestNode( settings, colIdx )
	{
		var idx = _fnGetMaxLenString( settings, colIdx );
		if ( idx &lt; 0 ) {
			return null;
		}
	
		var data = settings.aoData[ idx ];
		return ! data.nTr ? // Might not have been created when deferred rendering
			$(&#x27;&lt;td/&gt;&#x27;).html( _fnGetCellData( settings, idx, colIdx, &#x27;display&#x27; ) )[0] :
			data.anCells[ colIdx ];
	}
	
	
	/**
	 * Get the maximum strlen for each data column
	 *  @param {object} settings dataTables settings object
	 *  @param {int} colIdx column of interest
	 *  @returns {string} max string length for each column
	 *  @memberof DataTable#oApi
	 */
	function _fnGetMaxLenString( settings, colIdx )
	{
		var s, max=-1, maxIdx = -1;
	
		for ( var i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			s = _fnGetCellData( settings, i, colIdx, &#x27;display&#x27; )+&#x27;&#x27;;
			s = s.replace( __re_html_remove, &#x27;&#x27; );
			s = s.replace( /&amp;nbsp;/g, &#x27; &#x27; );
	
			if ( s.length &gt; max ) {
				max = s.length;
				maxIdx = i;
			}
		}
	
		return maxIdx;
	}
	
	
	/**
	 * Append a CSS unit (only if required) to a string
	 *  @param {string} value to css-ify
	 *  @returns {string} value with css unit
	 *  @memberof DataTable#oApi
	 */
	function _fnStringToCss( s )
	{
		if ( s === null ) {
			return &#x27;0px&#x27;;
		}
	
		if ( typeof s == &#x27;number&#x27; ) {
			return s &lt; 0 ?
				&#x27;0px&#x27; :
				s+&#x27;px&#x27;;
		}
	
		// Check it has a unit character already
		return s.match(/\d$/) ?
			s+&#x27;px&#x27; :
			s;
	}
	
	
	
	function _fnSortFlatten ( settings )
	{
		var
			i, iLen, k, kLen,
			aSort = [],
			aiOrig = [],
			aoColumns = settings.aoColumns,
			aDataSort, iCol, sType, srcCol,
			fixed = settings.aaSortingFixed,
			fixedObj = $.isPlainObject( fixed ),
			nestedSort = [],
			add = function ( a ) {
				if ( a.length &amp;&amp; ! $.isArray( a[0] ) ) {
					// 1D array
					nestedSort.push( a );
				}
				else {
					// 2D array
					$.merge( nestedSort, a );
				}
			};
	
		// Build the sort array, with pre-fix and post-fix options if they have been
		// specified
		if ( $.isArray( fixed ) ) {
			add( fixed );
		}
	
		if ( fixedObj &amp;&amp; fixed.pre ) {
			add( fixed.pre );
		}
	
		add( settings.aaSorting );
	
		if (fixedObj &amp;&amp; fixed.post ) {
			add( fixed.post );
		}
	
		for ( i=0 ; i&lt;nestedSort.length ; i++ )
		{
			srcCol = nestedSort[i][0];
			aDataSort = aoColumns[ srcCol ].aDataSort;
	
			for ( k=0, kLen=aDataSort.length ; k&lt;kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || &#x27;string&#x27;;
	
				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = $.inArray( nestedSort[i][1], aoColumns[iCol].asSorting );
				}
	
				aSort.push( {
					src:       srcCol,
					col:       iCol,
					dir:       nestedSort[i][1],
					index:     nestedSort[i]._idx,
					type:      sType,
					formatter: DataTable.ext.type.order[ sType+&quot;-pre&quot; ]
				} );
			}
		}
	
		return aSort;
	}
	
	/**
	 * Change the order of the table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 *  @todo This really needs split up!
	 */
	function _fnSort ( oSettings )
	{
		var
			i, ien, iLen, j, jLen, k, kLen,
			sDataType, nTh,
			aiOrig = [],
			oExtSort = DataTable.ext.type.order,
			aoData = oSettings.aoData,
			aoColumns = oSettings.aoColumns,
			aDataSort, data, iCol, sType, oSort,
			formatters = 0,
			sortCol,
			displayMaster = oSettings.aiDisplayMaster,
			aSort;
	
		// Resolve any column types that are unknown due to addition or invalidation
		// @todo Can this be moved into a &#x27;data-ready&#x27; handler which is called when
		//   data is going to be used in the table?
		_fnColumnTypes( oSettings );
	
		aSort = _fnSortFlatten( oSettings );
	
		for ( i=0, ien=aSort.length ; i&lt;ien ; i++ ) {
			sortCol = aSort[i];
	
			// Track if we can use the fast sort algorithm
			if ( sortCol.formatter ) {
				formatters++;
			}
	
			// Load the data needed for the sort, for each cell
			_fnSortData( oSettings, sortCol.col );
		}
	
		/* No sorting required if server-side or no sorting array */
		if ( _fnDataSource( oSettings ) != &#x27;ssp&#x27; &amp;&amp; aSort.length !== 0 )
		{
			// Create a value - key array of the current row positions such that we can use their
			// current position during the sort, if values match, in order to perform stable sorting
			for ( i=0, iLen=displayMaster.length ; i&lt;iLen ; i++ ) {
				aiOrig[ displayMaster[i] ] = i;
			}
	
			/* Do the sort - here we want multi-column sorting based on a given data source (column)
			 * and sorting function (from oSort) in a certain direction. It&#x27;s reasonably complex to
			 * follow on it&#x27;s own, but this is what we want (example two column sorting):
			 *  fnLocalSorting = function(a,b){
			 *    var iTest;
			 *    iTest = oSort[&#x27;string-asc&#x27;](&#x27;data11&#x27;, &#x27;data12&#x27;);
			 *      if (iTest !== 0)
			 *        return iTest;
			 *    iTest = oSort[&#x27;numeric-desc&#x27;](&#x27;data21&#x27;, &#x27;data22&#x27;);
			 *    if (iTest !== 0)
			 *      return iTest;
			 *    return oSort[&#x27;numeric-asc&#x27;]( aiOrig[a], aiOrig[b] );
			 *  }
			 * Basically we have a test for each sorting column, if the data in that column is equal,
			 * test the next column. If all columns match, then we use a numeric sort on the row
			 * positions in the original data array to provide a stable sort.
			 *
			 * Note - I know it seems excessive to have two sorting methods, but the first is around
			 * 15% faster, so the second is only maintained for backwards compatibility with sorting
			 * methods which do not have a pre-sort formatting function.
			 */
			if ( formatters === aSort.length ) {
				// All sort types have formatting functions
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, test, sort,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k&lt;len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						test = x&lt;y ? -1 : x&gt;y ? 1 : 0;
						if ( test !== 0 ) {
							return sort.dir === &#x27;asc&#x27; ? test : -test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x&lt;y ? -1 : x&gt;y ? 1 : 0;
				} );
			}
			else {
				// Depreciated - remove in 1.11 (providing a plug-in option)
				// Not all sort types have formatting methods, so we have to call their sorting
				// methods.
				displayMaster.sort( function ( a, b ) {
					var
						x, y, k, l, test, sort, fn,
						len=aSort.length,
						dataA = aoData[a]._aSortData,
						dataB = aoData[b]._aSortData;
	
					for ( k=0 ; k&lt;len ; k++ ) {
						sort = aSort[k];
	
						x = dataA[ sort.col ];
						y = dataB[ sort.col ];
	
						fn = oExtSort[ sort.type+&quot;-&quot;+sort.dir ] || oExtSort[ &quot;string-&quot;+sort.dir ];
						test = fn( x, y );
						if ( test !== 0 ) {
							return test;
						}
					}
	
					x = aiOrig[a];
					y = aiOrig[b];
					return x&lt;y ? -1 : x&gt;y ? 1 : 0;
				} );
			}
		}
	
		/* Tell the draw function that we have sorted the data */
		oSettings.bSorted = true;
	}
	
	
	function _fnSortAria ( settings )
	{
		var label;
		var nextSort;
		var columns = settings.aoColumns;
		var aSort = _fnSortFlatten( settings );
		var oAria = settings.oLanguage.oAria;
	
		// ARIA attributes - need to loop all columns, to update all (removing old
		// attributes as needed)
		for ( var i=0, iLen=columns.length ; i&lt;iLen ; i++ )
		{
			var col = columns[i];
			var asSorting = col.asSorting;
			var sTitle = col.sTitle.replace( /&lt;.*?&gt;/g, &quot;&quot; );
			var th = col.nTh;
	
			// IE7 is throwing an error when setting these properties with jQuery&#x27;s
			// attr() and removeAttr() methods...
			th.removeAttribute(&#x27;aria-sort&#x27;);
	
			/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
			if ( col.bSortable ) {
				if ( aSort.length &gt; 0 &amp;&amp; aSort[0].col == i ) {
					th.setAttribute(&#x27;aria-sort&#x27;, aSort[0].dir==&quot;asc&quot; ? &quot;ascending&quot; : &quot;descending&quot; );
					nextSort = asSorting[ aSort[0].index+1 ] || asSorting[0];
				}
				else {
					nextSort = asSorting[0];
				}
	
				label = sTitle + ( nextSort === &quot;asc&quot; ?
					oAria.sSortAscending :
					oAria.sSortDescending
				);
			}
			else {
				label = sTitle;
			}
	
			th.setAttribute(&#x27;aria-label&#x27;, label);
		}
	}
	
	
	/**
	 * Function to run on user sort request
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {boolean} [append=false] Append the requested sort to the existing
	 *    sort if true (i.e. multi-column sort)
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortListener ( settings, colIdx, append, callback )
	{
		var col = settings.aoColumns[ colIdx ];
		var sorting = settings.aaSorting;
		var asSorting = col.asSorting;
		var nextSortIdx;
		var next = function ( a, overflow ) {
			var idx = a._idx;
			if ( idx === undefined ) {
				idx = $.inArray( a[1], asSorting );
			}
	
			return idx+1 &lt; asSorting.length ?
				idx+1 :
				overflow ?
					null :
					0;
		};
	
		// Convert to 2D array if needed
		if ( typeof sorting[0] === &#x27;number&#x27; ) {
			sorting = settings.aaSorting = [ sorting ];
		}
	
		// If appending the sort then we are multi-column sorting
		if ( append &amp;&amp; settings.oFeatures.bSortMulti ) {
			// Are we already doing some kind of sort on this column?
			var sortIdx = $.inArray( colIdx, _pluck(sorting, &#x27;0&#x27;) );
	
			if ( sortIdx !== -1 ) {
				// Yes, modify the sort
				nextSortIdx = next( sorting[sortIdx], true );
	
				if ( nextSortIdx === null &amp;&amp; sorting.length === 1 ) {
					nextSortIdx = 0; // can&#x27;t remove sorting completely
				}
	
				if ( nextSortIdx === null ) {
					sorting.splice( sortIdx, 1 );
				}
				else {
					sorting[sortIdx][1] = asSorting[ nextSortIdx ];
					sorting[sortIdx]._idx = nextSortIdx;
				}
			}
			else {
				// No sort on this column yet
				sorting.push( [ colIdx, asSorting[0], 0 ] );
				sorting[sorting.length-1]._idx = 0;
			}
		}
		else if ( sorting.length &amp;&amp; sorting[0][0] == colIdx ) {
			// Single column - already sorting on this column, modify the sort
			nextSortIdx = next( sorting[0] );
	
			sorting.length = 1;
			sorting[0][1] = asSorting[ nextSortIdx ];
			sorting[0]._idx = nextSortIdx;
		}
		else {
			// Single column - sort only on this column
			sorting.length = 0;
			sorting.push( [ colIdx, asSorting[0] ] );
			sorting[0]._idx = 0;
		}
	
		// Run the sort by calling a full redraw
		_fnReDraw( settings );
	
		// callback used for async user interaction
		if ( typeof callback == &#x27;function&#x27; ) {
			callback( settings );
		}
	}
	
	
	/**
	 * Attach a sort handler (click) to a node
	 *  @param {object} settings dataTables settings object
	 *  @param {node} attachTo node to attach the handler to
	 *  @param {int} colIdx column sorting index
	 *  @param {function} [callback] callback function
	 *  @memberof DataTable#oApi
	 */
	function _fnSortAttachListener ( settings, attachTo, colIdx, callback )
	{
		var col = settings.aoColumns[ colIdx ];
	
		_fnBindAction( attachTo, {}, function (e) {
			/* If the column is not sortable - don&#x27;t to anything */
			if ( col.bSortable === false ) {
				return;
			}
	
			// If processing is enabled use a timeout to allow the processing
			// display to be shown - otherwise to it synchronously
			if ( settings.oFeatures.bProcessing ) {
				_fnProcessingDisplay( settings, true );
	
				setTimeout( function() {
					_fnSortListener( settings, colIdx, e.shiftKey, callback );
	
					// In server-side processing, the draw callback will remove the
					// processing display
					if ( _fnDataSource( settings ) !== &#x27;ssp&#x27; ) {
						_fnProcessingDisplay( settings, false );
					}
				}, 0 );
			}
			else {
				_fnSortListener( settings, colIdx, e.shiftKey, callback );
			}
		} );
	}
	
	
	/**
	 * Set the sorting classes on table&#x27;s body, Note: it is safe to call this function
	 * when bSort and bSortClasses are false
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSortingClasses( settings )
	{
		var oldSort = settings.aLastSort;
		var sortClass = settings.oClasses.sSortColumn;
		var sort = _fnSortFlatten( settings );
		var features = settings.oFeatures;
		var i, ien, colIdx;
	
		if ( features.bSort &amp;&amp; features.bSortClasses ) {
			// Remove old sorting classes
			for ( i=0, ien=oldSort.length ; i&lt;ien ; i++ ) {
				colIdx = oldSort[i].src;
	
				// Remove column sorting
				$( _pluck( settings.aoData, &#x27;anCells&#x27;, colIdx ) )
					.removeClass( sortClass + (i&lt;2 ? i+1 : 3) );
			}
	
			// Add new column sorting
			for ( i=0, ien=sort.length ; i&lt;ien ; i++ ) {
				colIdx = sort[i].src;
	
				$( _pluck( settings.aoData, &#x27;anCells&#x27;, colIdx ) )
					.addClass( sortClass + (i&lt;2 ? i+1 : 3) );
			}
		}
	
		settings.aLastSort = sort;
	}
	
	
	// Get the data to sort a column, be it from cache, fresh (populating the
	// cache), or from a sort formatter
	function _fnSortData( settings, idx )
	{
		// Custom sorting function - provided by the sort data type
		var column = settings.aoColumns[ idx ];
		var customSort = DataTable.ext.order[ column.sSortDataType ];
		var customData;
	
		if ( customSort ) {
			customData = customSort.call( settings.oInstance, settings, idx,
				_fnColumnIndexToVisible( settings, idx )
			);
		}
	
		// Use / populate cache
		var row, cellData;
		var formatter = DataTable.ext.type.order[ column.sType+&quot;-pre&quot; ];
	
		for ( var i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
			row = settings.aoData[i];
	
			if ( ! row._aSortData ) {
				row._aSortData = [];
			}
	
			if ( ! row._aSortData[idx] || customSort ) {
				cellData = customSort ?
					customData[i] : // If there was a custom sort function, use data from there
					_fnGetCellData( settings, i, idx, &#x27;sort&#x27; );
	
				row._aSortData[ idx ] = formatter ?
					formatter( cellData ) :
					cellData;
			}
		}
	}
	
	
	
	/**
	 * Save the state of a table
	 *  @param {object} oSettings dataTables settings object
	 *  @memberof DataTable#oApi
	 */
	function _fnSaveState ( settings )
	{
		if ( !settings.oFeatures.bStateSave || settings.bDestroying )
		{
			return;
		}
	
		/* Store the interesting variables */
		var state = {
			time:    +new Date(),
			start:   settings._iDisplayStart,
			length:  settings._iDisplayLength,
			order:   $.extend( true, [], settings.aaSorting ),
			search:  _fnSearchToCamel( settings.oPreviousSearch ),
			columns: $.map( settings.aoColumns, function ( col, i ) {
				return {
					visible: col.bVisible,
					search: _fnSearchToCamel( settings.aoPreSearchCols[i] )
				};
			} )
		};
	
		_fnCallbackFire( settings, &quot;aoStateSaveParams&quot;, &#x27;stateSaveParams&#x27;, [settings, state] );
	
		settings.oSavedState = state;
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}
	
	
	/**
	 * Attempt to load a saved table state
	 *  @param {object} oSettings dataTables settings object
	 *  @param {object} oInit DataTables init object so we can override settings
	 *  @param {function} callback Callback to execute when the state has been loaded
	 *  @memberof DataTable#oApi
	 */
	function _fnLoadState ( settings, oInit, callback )
	{
		var i, ien;
		var columns = settings.aoColumns;
		var loaded = function ( s ) {
			if ( ! s || ! s.time ) {
				callback();
				return;
			}
	
			// Allow custom and plug-in manipulation functions to alter the saved data set and
			// cancelling of loading by returning false
			var abStateLoad = _fnCallbackFire( settings, &#x27;aoStateLoadParams&#x27;, &#x27;stateLoadParams&#x27;, [settings, s] );
			if ( $.inArray( false, abStateLoad ) !== -1 ) {
				callback();
				return;
			}
	
			// Reject old data
			var duration = settings.iStateDuration;
			if ( duration &gt; 0 &amp;&amp; s.time &lt; +new Date() - (duration*1000) ) {
				callback();
				return;
			}
	
			// Number of columns have changed - all bets are off, no restore of settings
			if ( s.columns &amp;&amp; columns.length !== s.columns.length ) {
				callback();
				return;
			}
	
			// Store the saved state so it might be accessed at any time
			settings.oLoadedState = $.extend( true, {}, s );
	
			// Restore key features - todo - for 1.11 this needs to be done by
			// subscribed events
			if ( s.start !== undefined ) {
				settings._iDisplayStart    = s.start;
				settings.iInitDisplayStart = s.start;
			}
			if ( s.length !== undefined ) {
				settings._iDisplayLength   = s.length;
			}
	
			// Order
			if ( s.order !== undefined ) {
				settings.aaSorting = [];
				$.each( s.order, function ( i, col ) {
					settings.aaSorting.push( col[0] &gt;= columns.length ?
						[ 0, col[1] ] :
						col
					);
				} );
			}
	
			// Search
			if ( s.search !== undefined ) {
				$.extend( settings.oPreviousSearch, _fnSearchToHung( s.search ) );
			}
	
			// Columns
			//
			if ( s.columns ) {
				for ( i=0, ien=s.columns.length ; i&lt;ien ; i++ ) {
					var col = s.columns[i];
	
					// Visibility
					if ( col.visible !== undefined ) {
						columns[i].bVisible = col.visible;
					}
	
					// Search
					if ( col.search !== undefined ) {
						$.extend( settings.aoPreSearchCols[i], _fnSearchToHung( col.search ) );
					}
				}
			}
	
			_fnCallbackFire( settings, &#x27;aoStateLoaded&#x27;, &#x27;stateLoaded&#x27;, [settings, s] );
			callback();
		}
	
		if ( ! settings.oFeatures.bStateSave ) {
			callback();
			return;
		}
	
		var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );
	
		if ( state !== undefined ) {
			loaded( state );
		}
		// otherwise, wait for the loaded callback to be executed
	}
	
	
	/**
	 * Return the settings object for a particular table
	 *  @param {node} table table we are using as a dataTable
	 *  @returns {object} Settings object - or null if not found
	 *  @memberof DataTable#oApi
	 */
	function _fnSettingsFromNode ( table )
	{
		var settings = DataTable.settings;
		var idx = $.inArray( table, _pluck( settings, &#x27;nTable&#x27; ) );
	
		return idx !== -1 ?
			settings[ idx ] :
			null;
	}
	
	
	/**
	 * Log an error message
	 *  @param {object} settings dataTables settings object
	 *  @param {int} level log error messages, or display them to the user
	 *  @param {string} msg error message
	 *  @param {int} tn Technical note id to get more information about the error.
	 *  @memberof DataTable#oApi
	 */
	function _fnLog( settings, level, msg, tn )
	{
		msg = &#x27;DataTables warning: &#x27;+
			(settings ? &#x27;table id=&#x27;+settings.sTableId+&#x27; - &#x27; : &#x27;&#x27;)+msg;
	
		if ( tn ) {
			msg += &#x27;. For more information about this error, please see &#x27;+
			&#x27;http://datatables.net/tn/&#x27;+tn;
		}
	
		if ( ! level  ) {
			// Backwards compatibility pre 1.10
			var ext = DataTable.ext;
			var type = ext.sErrMode || ext.errMode;
	
			if ( settings ) {
				_fnCallbackFire( settings, null, &#x27;error&#x27;, [ settings, tn, msg ] );
			}
	
			if ( type == &#x27;alert&#x27; ) {
				alert( msg );
			}
			else if ( type == &#x27;throw&#x27; ) {
				throw new Error(msg);
			}
			else if ( typeof type == &#x27;function&#x27; ) {
				type( settings, tn, msg );
			}
		}
		else if ( window.console &amp;&amp; console.log ) {
			console.log( msg );
		}
	}
	
	
	/**
	 * See if a property is defined on one object, if so assign it to the other object
	 *  @param {object} ret target object
	 *  @param {object} src source object
	 *  @param {string} name property
	 *  @param {string} [mappedName] name to map too - optional, name used if not given
	 *  @memberof DataTable#oApi
	 */
	function _fnMap( ret, src, name, mappedName )
	{
		if ( $.isArray( name ) ) {
			$.each( name, function (i, val) {
				if ( $.isArray( val ) ) {
					_fnMap( ret, src, val[0], val[1] );
				}
				else {
					_fnMap( ret, src, val );
				}
			} );
	
			return;
		}
	
		if ( mappedName === undefined ) {
			mappedName = name;
		}
	
		if ( src[name] !== undefined ) {
			ret[mappedName] = src[name];
		}
	}
	
	
	/**
	 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	 * shallow copy arrays. The reason we need to do this, is that we don&#x27;t want to
	 * deep copy array init values (such as aaSorting) since the dev wouldn&#x27;t be
	 * able to override them, but we do want to deep copy arrays.
	 *  @param {object} out Object to extend
	 *  @param {object} extender Object from which the properties will be applied to
	 *      out
	 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	 *      independent copy with the exception of the &#x60;data&#x60; or &#x60;aaData&#x60; parameters
	 *      if they are present. This is so you can pass in a collection to
	 *      DataTables and have that used as your data source without breaking the
	 *      references
	 *  @returns {object} out Reference, just for convenience - out === the return.
	 *  @memberof DataTable#oApi
	 *  @todo This doesn&#x27;t take account of arrays inside the deep copied objects.
	 */
	function _fnExtend( out, extender, breakRefs )
	{
		var val;
	
		for ( var prop in extender ) {
			if ( extender.hasOwnProperty(prop) ) {
				val = extender[prop];
	
				if ( $.isPlainObject( val ) ) {
					if ( ! $.isPlainObject( out[prop] ) ) {
						out[prop] = {};
					}
					$.extend( true, out[prop], val );
				}
				else if ( breakRefs &amp;&amp; prop !== &#x27;data&#x27; &amp;&amp; prop !== &#x27;aaData&#x27; &amp;&amp; $.isArray(val) ) {
					out[prop] = val.slice();
				}
				else {
					out[prop] = val;
				}
			}
		}
	
		return out;
	}
	
	
	/**
	 * Bind an event handers to allow a click or return key to activate the callback.
	 * This is good for accessibility since a return on the keyboard will have the
	 * same effect as a click, if the element has focus.
	 *  @param {element} n Element to bind the action to
	 *  @param {object} oData Data object to pass to the triggered function
	 *  @param {function} fn Callback function for when the event is triggered
	 *  @memberof DataTable#oApi
	 */
	function _fnBindAction( n, oData, fn )
	{
		$(n)
			.on( &#x27;click.DT&#x27;, oData, function (e) {
					n.blur(); // Remove focus outline for mouse users
					fn(e);
				} )
			.on( &#x27;keypress.DT&#x27;, oData, function (e){
					if ( e.which === 13 ) {
						e.preventDefault();
						fn(e);
					}
				} )
			.on( &#x27;selectstart.DT&#x27;, function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
				} );
	}
	
	
	/**
	 * Register a callback function. Easily allows a callback function to be added to
	 * an array store of callback functions that can then all be called together.
	 *  @param {object} oSettings dataTables settings object
	 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	 *  @param {function} fn Function to be called back
	 *  @param {string} sName Identifying name for the callback (i.e. a label)
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackReg( oSettings, sStore, fn, sName )
	{
		if ( fn )
		{
			oSettings[sStore].push( {
				&quot;fn&quot;: fn,
				&quot;sName&quot;: sName
			} );
		}
	}
	
	
	/**
	 * Fire callback functions and trigger events. Note that the loop over the
	 * callback array store is done backwards! Further note that you do not want to
	 * fire off triggers in time sensitive applications (for example cell creation)
	 * as its slow.
	 *  @param {object} settings dataTables settings object
	 *  @param {string} callbackArr Name of the array storage for the callbacks in
	 *      oSettings
	 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	 *      null no trigger is fired
	 *  @param {array} args Array of arguments to pass to the callback function /
	 *      trigger
	 *  @memberof DataTable#oApi
	 */
	function _fnCallbackFire( settings, callbackArr, eventName, args )
	{
		var ret = [];
	
		if ( callbackArr ) {
			ret = $.map( settings[callbackArr].slice().reverse(), function (val, i) {
				return val.fn.apply( settings.oInstance, args );
			} );
		}
	
		if ( eventName !== null ) {
			var e = $.Event( eventName+&#x27;.dt&#x27; );
	
			$(settings.nTable).trigger( e, args );
	
			ret.push( e.result );
		}
	
		return ret;
	}
	
	
	function _fnLengthOverflow ( settings )
	{
		var
			start = settings._iDisplayStart,
			end = settings.fnDisplayEnd(),
			len = settings._iDisplayLength;
	
		/* If we have space to show extra rows (backing up from the end point - then do so */
		if ( start &gt;= end )
		{
			start = end - len;
		}
	
		// Keep the start record on the current page
		start -= (start % len);
	
		if ( len === -1 || start &lt; 0 )
		{
			start = 0;
		}
	
		settings._iDisplayStart = start;
	}
	
	
	function _fnRenderer( settings, type )
	{
		var renderer = settings.renderer;
		var host = DataTable.ext.renderer[type];
	
		if ( $.isPlainObject( renderer ) &amp;&amp; renderer[type] ) {
			// Specific renderer for this type. If available use it, otherwise use
			// the default.
			return host[renderer[type]] || host._;
		}
		else if ( typeof renderer === &#x27;string&#x27; ) {
			// Common renderer - if there is one available for this type use it,
			// otherwise use the default
			return host[renderer] || host._;
		}
	
		// Use the default
		return host._;
	}
	
	
	/**
	 * Detect the data source being used for the table. Used to simplify the code
	 * a little (ajax) and to make it compress a little smaller.
	 *
	 *  @param {object} settings dataTables settings object
	 *  @returns {string} Data source
	 *  @memberof DataTable#oApi
	 */
	function _fnDataSource ( settings )
	{
		if ( settings.oFeatures.bServerSide ) {
			return &#x27;ssp&#x27;;
		}
		else if ( settings.ajax || settings.sAjaxSource ) {
			return &#x27;ajax&#x27;;
		}
		return &#x27;dom&#x27;;
	}
	

	
	
	/**
	 * Computed structure of the DataTables API, defined by the options passed to
	 * &#x60;DataTable.Api.register()&#x60; when building the API.
	 *
	 * The structure is built in order to speed creation and extension of the Api
	 * objects since the extensions are effectively pre-parsed.
	 *
	 * The array is an array of objects with the following structure, where this
	 * base array represents the Api prototype base:
	 *
	 *     [
	 *       {
	 *         name:      &#x27;data&#x27;                -- string   - Property name
	 *         val:       function () {},       -- function - Api method (or undefined if just an object
	 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	 *       },
	 *       {
	 *         name:     &#x27;row&#x27;
	 *         val:       {},
	 *         methodExt: [ ... ],
	 *         propExt:   [
	 *           {
	 *             name:      &#x27;data&#x27;
	 *             val:       function () {},
	 *             methodExt: [ ... ],
	 *             propExt:   [ ... ]
	 *           },
	 *           ...
	 *         ]
	 *       }
	 *     ]
	 *
	 * @type {Array}
	 * @ignore
	 */
	var __apiStruct = [];
	
	
	/**
	 * &#x60;Array.prototype&#x60; reference.
	 *
	 * @type object
	 * @ignore
	 */
	var __arrayProto = Array.prototype;
	
	
	/**
	 * Abstraction for &#x60;context&#x60; parameter of the &#x60;Api&#x60; constructor to allow it to
	 * take several different forms for ease of use.
	 *
	 * Each of the input parameter types will be converted to a DataTables settings
	 * object where possible.
	 *
	 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	 *   of:
	 *
	 *   * &#x60;string&#x60; - jQuery selector. Any DataTables&#x27; matching the given selector
	 *     with be found and used.
	 *   * &#x60;node&#x60; - &#x60;TABLE&#x60; node which has already been formed into a DataTable.
	 *   * &#x60;jQuery&#x60; - A jQuery object of &#x60;TABLE&#x60; nodes.
	 *   * &#x60;object&#x60; - DataTables settings object
	 *   * &#x60;DataTables.Api&#x60; - API instance
	 * @return {array|null} Matching DataTables settings objects. &#x60;null&#x60; or
	 *   &#x60;undefined&#x60; is returned if no matching DataTable is found.
	 * @ignore
	 */
	var _toSettings = function ( mixed )
	{
		var idx, jq;
		var settings = DataTable.settings;
		var tables = $.map( settings, function (el, i) {
			return el.nTable;
		} );
	
		if ( ! mixed ) {
			return [];
		}
		else if ( mixed.nTable &amp;&amp; mixed.oApi ) {
			// DataTables settings object
			return [ mixed ];
		}
		else if ( mixed.nodeName &amp;&amp; mixed.nodeName.toLowerCase() === &#x27;table&#x27; ) {
			// Table node
			idx = $.inArray( mixed, tables );
			return idx !== -1 ? [ settings[idx] ] : null;
		}
		else if ( mixed &amp;&amp; typeof mixed.settings === &#x27;function&#x27; ) {
			return mixed.settings().toArray();
		}
		else if ( typeof mixed === &#x27;string&#x27; ) {
			// jQuery selector
			jq = $(mixed);
		}
		else if ( mixed instanceof $ ) {
			// jQuery object (also DataTables instance)
			jq = mixed;
		}
	
		if ( jq ) {
			return jq.map( function(i) {
				idx = $.inArray( this, tables );
				return idx !== -1 ? settings[idx] : null;
			} ).toArray();
		}
	};
	
	
	/**
	 * DataTables API class - used to control and interface with  one or more
	 * DataTables enhanced tables.
	 *
	 * The API class is heavily based on jQuery, presenting a chainable interface
	 * that you can use to interact with tables. Each instance of the API class has
	 * a &quot;context&quot; - i.e. the tables that it will operate on. This could be a single
	 * table, all tables on a page or a sub-set thereof.
	 *
	 * Additionally the API is designed to allow you to easily work with the data in
	 * the tables, retrieving and manipulating it as required. This is done by
	 * presenting the API class as an array like interface. The contents of the
	 * array depend upon the actions requested by each method (for example
	 * &#x60;rows().nodes()&#x60; will return an array of nodes, while &#x60;rows().data()&#x60; will
	 * return an array of objects or arrays depending upon your table&#x27;s
	 * configuration). The API object has a number of array like methods (&#x60;push&#x60;,
	 * &#x60;pop&#x60;, &#x60;reverse&#x60; etc) as well as additional helper methods (&#x60;each&#x60;, &#x60;pluck&#x60;,
	 * &#x60;unique&#x60; etc) to assist your working with the data held in a table.
	 *
	 * Most methods (those which return an Api instance) are chainable, which means
	 * the return from a method call also has all of the methods available that the
	 * top level object had. For example, these two calls are equivalent:
	 *
	 *     // Not chained
	 *     api.row.add( {...} );
	 *     api.draw();
	 *
	 *     // Chained
	 *     api.row.add( {...} ).draw();
	 *
	 * @class DataTable.Api
	 * @param {array|object|string|jQuery} context DataTable identifier. This is
	 *   used to define which DataTables enhanced tables this API will operate on.
	 *   Can be one of:
	 *
	 *   * &#x60;string&#x60; - jQuery selector. Any DataTables&#x27; matching the given selector
	 *     with be found and used.
	 *   * &#x60;node&#x60; - &#x60;TABLE&#x60; node which has already been formed into a DataTable.
	 *   * &#x60;jQuery&#x60; - A jQuery object of &#x60;TABLE&#x60; nodes.
	 *   * &#x60;object&#x60; - DataTables settings object
	 * @param {array} [data] Data to initialise the Api instance with.
	 *
	 * @example
	 *   // Direct initialisation during DataTables construction
	 *   var api = $(&#x27;#example&#x27;).DataTable();
	 *
	 * @example
	 *   // Initialisation using a DataTables jQuery object
	 *   var api = $(&#x27;#example&#x27;).dataTable().api();
	 *
	 * @example
	 *   // Initialisation as a constructor
	 *   var api = new $.fn.DataTable.Api( &#x27;table.dataTable&#x27; );
	 */
	_Api = function ( context, data )
	{
		if ( ! (this instanceof _Api) ) {
			return new _Api( context, data );
		}
	
		var settings = [];
		var ctxSettings = function ( o ) {
			var a = _toSettings( o );
			if ( a ) {
				settings = settings.concat( a );
			}
		};
	
		if ( $.isArray( context ) ) {
			for ( var i=0, ien=context.length ; i&lt;ien ; i++ ) {
				ctxSettings( context[i] );
			}
		}
		else {
			ctxSettings( context );
		}
	
		// Remove duplicates
		this.context = _unique( settings );
	
		// Initial data
		if ( data ) {
			$.merge( this, data );
		}
	
		// selector
		this.selector = {
			rows: null,
			cols: null,
			opts: null
		};
	
		_Api.extend( this, this, __apiStruct );
	};
	
	DataTable.Api = _Api;
	
	// Don&#x27;t destroy the existing prototype, just extend it. Required for jQuery 2&#x27;s
	// isPlainObject.
	$.extend( _Api.prototype, {
		any: function ()
		{
			return this.count() !== 0;
		},
	
	
		concat:  __arrayProto.concat,
	
	
		context: [], // array of table settings objects
	
	
		count: function ()
		{
			return this.flatten().length;
		},
	
	
		each: function ( fn )
		{
			for ( var i=0, ien=this.length ; i&lt;ien; i++ ) {
				fn.call( this, this[i], i, this );
			}
	
			return this;
		},
	
	
		eq: function ( idx )
		{
			var ctx = this.context;
	
			return ctx.length &gt; idx ?
				new _Api( ctx[idx], this[idx] ) :
				null;
		},
	
	
		filter: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.filter ) {
				a = __arrayProto.filter.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i&lt;ien ; i++ ) {
					if ( fn.call( this, this[i], i, this ) ) {
						a.push( this[i] );
					}
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		flatten: function ()
		{
			var a = [];
			return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
		},
	
	
		join:    __arrayProto.join,
	
	
		indexOf: __arrayProto.indexOf || function (obj, start)
		{
			for ( var i=(start || 0), ien=this.length ; i&lt;ien ; i++ ) {
				if ( this[i] === obj ) {
					return i;
				}
			}
			return -1;
		},
	
		iterator: function ( flatten, type, fn, alwaysNew ) {
			var
				a = [], ret,
				i, ien, j, jen,
				context = this.context,
				rows, items, item,
				selector = this.selector;
	
			// Argument shifting
			if ( typeof flatten === &#x27;string&#x27; ) {
				alwaysNew = fn;
				fn = type;
				type = flatten;
				flatten = false;
			}
	
			for ( i=0, ien=context.length ; i&lt;ien ; i++ ) {
				var apiInst = new _Api( context[i] );
	
				if ( type === &#x27;table&#x27; ) {
					ret = fn.call( apiInst, context[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === &#x27;columns&#x27; || type === &#x27;rows&#x27; ) {
					// this has same length as context - one entry for each table
					ret = fn.call( apiInst, context[i], this[i], i );
	
					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
				else if ( type === &#x27;column&#x27; || type === &#x27;column-rows&#x27; || type === &#x27;row&#x27; || type === &#x27;cell&#x27; ) {
					// columns and rows share the same structure.
					// &#x27;this&#x27; is an array of column indexes for each context
					items = this[i];
	
					if ( type === &#x27;column-rows&#x27; ) {
						rows = _selector_row_indexes( context[i], selector.opts );
					}
	
					for ( j=0, jen=items.length ; j&lt;jen ; j++ ) {
						item = items[j];
	
						if ( type === &#x27;cell&#x27; ) {
							ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
						}
						else {
							ret = fn.call( apiInst, context[i], item, i, j, rows );
						}
	
						if ( ret !== undefined ) {
							a.push( ret );
						}
					}
				}
			}
	
			if ( a.length || alwaysNew ) {
				var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
				var apiSelector = api.selector;
				apiSelector.rows = selector.rows;
				apiSelector.cols = selector.cols;
				apiSelector.opts = selector.opts;
				return api;
			}
			return this;
		},
	
	
		lastIndexOf: __arrayProto.lastIndexOf || function (obj, start)
		{
			// Bit cheeky...
			return this.indexOf.apply( this.toArray.reverse(), arguments );
		},
	
	
		length:  0,
	
	
		map: function ( fn )
		{
			var a = [];
	
			if ( __arrayProto.map ) {
				a = __arrayProto.map.call( this, fn, this );
			}
			else {
				// Compatibility for browsers without EMCA-252-5 (JS 1.6)
				for ( var i=0, ien=this.length ; i&lt;ien ; i++ ) {
					a.push( fn.call( this, this[i], i ) );
				}
			}
	
			return new _Api( this.context, a );
		},
	
	
		pluck: function ( prop )
		{
			return this.map( function ( el ) {
				return el[ prop ];
			} );
		},
	
		pop:     __arrayProto.pop,
	
	
		push:    __arrayProto.push,
	
	
		// Does not return an API instance
		reduce: __arrayProto.reduce || function ( fn, init )
		{
			return _fnReduce( this, fn, init, 0, this.length, 1 );
		},
	
	
		reduceRight: __arrayProto.reduceRight || function ( fn, init )
		{
			return _fnReduce( this, fn, init, this.length-1, -1, -1 );
		},
	
	
		reverse: __arrayProto.reverse,
	
	
		// Object with rows, columns and opts
		selector: null,
	
	
		shift:   __arrayProto.shift,
	
	
		slice: function () {
			return new _Api( this.context, this );
		},
	
	
		sort:    __arrayProto.sort, // ? name - order?
	
	
		splice:  __arrayProto.splice,
	
	
		toArray: function ()
		{
			return __arrayProto.slice.call( this );
		},
	
	
		to$: function ()
		{
			return $( this );
		},
	
	
		toJQuery: function ()
		{
			return $( this );
		},
	
	
		unique: function ()
		{
			return new _Api( this.context, _unique(this) );
		},
	
	
		unshift: __arrayProto.unshift
	} );
	
	
	_Api.extend = function ( scope, obj, ext )
	{
		// Only extend API instances and static properties of the API
		if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) &amp;&amp; ! obj.__dt_wrapper ) ) {
			return;
		}
	
		var
			i, ien,
			j, jen,
			struct, inner,
			methodScoping = function ( scope, fn, struc ) {
				return function () {
					var ret = fn.apply( scope, arguments );
	
					// Method extension
					_Api.extend( ret, ret, struc.methodExt );
					return ret;
				};
			};
	
		for ( i=0, ien=ext.length ; i&lt;ien ; i++ ) {
			struct = ext[i];
	
			// Value
			obj[ struct.name ] = typeof struct.val === &#x27;function&#x27; ?
				methodScoping( scope, struct.val, struct ) :
				$.isPlainObject( struct.val ) ?
					{} :
					struct.val;
	
			obj[ struct.name ].__dt_wrapper = true;
	
			// Property extension
			_Api.extend( scope, obj[ struct.name ], struct.propExt );
		}
	};
	
	
	// @todo - Is there need for an augment function?
	// _Api.augment = function ( inst, name )
	// {
	// 	// Find src object in the structure from the name
	// 	var parts = name.split(&#x27;.&#x27;);
	
	// 	_Api.extend( inst, obj );
	// };
	
	
	//     [
	//       {
	//         name:      &#x27;data&#x27;                -- string   - Property name
	//         val:       function () {},       -- function - Api method (or undefined if just an object
	//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	//       },
	//       {
	//         name:     &#x27;row&#x27;
	//         val:       {},
	//         methodExt: [ ... ],
	//         propExt:   [
	//           {
	//             name:      &#x27;data&#x27;
	//             val:       function () {},
	//             methodExt: [ ... ],
	//             propExt:   [ ... ]
	//           },
	//           ...
	//         ]
	//       }
	//     ]
	
	_Api.register = _api_register = function ( name, val )
	{
		if ( $.isArray( name ) ) {
			for ( var j=0, jen=name.length ; j&lt;jen ; j++ ) {
				_Api.register( name[j], val );
			}
			return;
		}
	
		var
			i, ien,
			heir = name.split(&#x27;.&#x27;),
			struct = __apiStruct,
			key, method;
	
		var find = function ( src, name ) {
			for ( var i=0, ien=src.length ; i&lt;ien ; i++ ) {
				if ( src[i].name === name ) {
					return src[i];
				}
			}
			return null;
		};
	
		for ( i=0, ien=heir.length ; i&lt;ien ; i++ ) {
			method = heir[i].indexOf(&#x27;()&#x27;) !== -1;
			key = method ?
				heir[i].replace(&#x27;()&#x27;, &#x27;&#x27;) :
				heir[i];
	
			var src = find( struct, key );
			if ( ! src ) {
				src = {
					name:      key,
					val:       {},
					methodExt: [],
					propExt:   []
				};
				struct.push( src );
			}
	
			if ( i === ien-1 ) {
				src.val = val;
			}
			else {
				struct = method ?
					src.methodExt :
					src.propExt;
			}
		}
	};
	
	
	_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
		_Api.register( pluralName, val );
	
		_Api.register( singularName, function () {
			var ret = val.apply( this, arguments );
	
			if ( ret === this ) {
				// Returned item is the API instance that was passed in, return it
				return this;
			}
			else if ( ret instanceof _Api ) {
				// New API instance returned, want the value from the first item
				// in the returned array for the singular result.
				return ret.length ?
					$.isArray( ret[0] ) ?
						new _Api( ret.context, ret[0] ) : // Array results are &#x27;enhanced&#x27;
						ret[0] :
					undefined;
			}
	
			// Non-API return - just fire it back
			return ret;
		} );
	};
	
	
	/**
	 * Selector for HTML tables. Apply the given selector to the give array of
	 * DataTables settings objects.
	 *
	 * @param {string|integer} [selector] jQuery selector string or integer
	 * @param  {array} Array of DataTables settings objects to be filtered
	 * @return {array}
	 * @ignore
	 */
	var __table_selector = function ( selector, a )
	{
		// Integer is used to pick out a table by index
		if ( typeof selector === &#x27;number&#x27; ) {
			return [ a[ selector ] ];
		}
	
		// Perform a jQuery selector on the table nodes
		var nodes = $.map( a, function (el, i) {
			return el.nTable;
		} );
	
		return $(nodes)
			.filter( selector )
			.map( function (i) {
				// Need to translate back from the table node to the settings
				var idx = $.inArray( this, nodes );
				return a[ idx ];
			} )
			.toArray();
	};
	
	
	
	/**
	 * Context selector for the API&#x27;s context (i.e. the tables the API instance
	 * refers to.
	 *
	 * @name    DataTable.Api#tables
	 * @param {string|integer} [selector] Selector to pick which tables the iterator
	 *   should operate on. If not given, all tables in the current context are
	 *   used. This can be given as a jQuery selector (for example &#x60;&#x27;:gt(0)&#x27;&#x60;) to
	 *   select multiple tables or as an integer to select a single table.
	 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	 */
	_api_register( &#x27;tables()&#x27;, function ( selector ) {
		// A new instance is created if there was a selector specified
		return selector ?
			new _Api( __table_selector( selector, this.context ) ) :
			this;
	} );
	
	
	_api_register( &#x27;table()&#x27;, function ( selector ) {
		var tables = this.tables( selector );
		var ctx = tables.context;
	
		// Truncate to the first matched table
		return ctx.length ?
			new _Api( ctx[0] ) :
			tables;
	} );
	
	
	_api_registerPlural( &#x27;tables().nodes()&#x27;, &#x27;table().node()&#x27; , function () {
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			return ctx.nTable;
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;tables().body()&#x27;, &#x27;table().body()&#x27; , function () {
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			return ctx.nTBody;
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;tables().header()&#x27;, &#x27;table().header()&#x27; , function () {
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			return ctx.nTHead;
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;tables().footer()&#x27;, &#x27;table().footer()&#x27; , function () {
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			return ctx.nTFoot;
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;tables().containers()&#x27;, &#x27;table().container()&#x27; , function () {
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			return ctx.nTableWrapper;
		}, 1 );
	} );
	
	
	
	/**
	 * Redraw the tables in the current context.
	 */
	_api_register( &#x27;draw()&#x27;, function ( paging ) {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			if ( paging === &#x27;page&#x27; ) {
				_fnDraw( settings );
			}
			else {
				if ( typeof paging === &#x27;string&#x27; ) {
					paging = paging === &#x27;full-hold&#x27; ?
						false :
						true;
				}
	
				_fnReDraw( settings, paging===false );
			}
		} );
	} );
	
	
	
	/**
	 * Get the current page index.
	 *
	 * @return {integer} Current page index (zero based)
	 *//**
	 * Set the current page.
	 *
	 * Note that if you attempt to show a page which does not exist, DataTables will
	 * not throw an error, but rather reset the paging.
	 *
	 * @param {integer|string} action The paging action to take. This can be one of:
	 *  * &#x60;integer&#x60; - The page index to jump to
	 *  * &#x60;string&#x60; - An action to take:
	 *    * &#x60;first&#x60; - Jump to first page.
	 *    * &#x60;next&#x60; - Jump to the next page
	 *    * &#x60;previous&#x60; - Jump to previous page
	 *    * &#x60;last&#x60; - Jump to the last page.
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;page()&#x27;, function ( action ) {
		if ( action === undefined ) {
			return this.page.info().page; // not an expensive call
		}
	
		// else, have an action to take on all tables
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnPageChange( settings, action );
		} );
	} );
	
	
	/**
	 * Paging information for the first table in the current context.
	 *
	 * If you require paging information for another table, use the &#x60;table()&#x60; method
	 * with a suitable selector.
	 *
	 * @return {object} Object with the following properties set:
	 *  * &#x60;page&#x60; - Current page index (zero based - i.e. the first page is &#x60;0&#x60;)
	 *  * &#x60;pages&#x60; - Total number of pages
	 *  * &#x60;start&#x60; - Display index for the first record shown on the current page
	 *  * &#x60;end&#x60; - Display index for the last record shown on the current page
	 *  * &#x60;length&#x60; - Display length (number of records). Note that generally &#x60;start
	 *    + length = end&#x60;, but this is not always true, for example if there are
	 *    only 2 records to show on the final page, with a length of 10.
	 *  * &#x60;recordsTotal&#x60; - Full data set length
	 *  * &#x60;recordsDisplay&#x60; - Data set length once the current filtering criterion
	 *    are applied.
	 */
	_api_register( &#x27;page.info()&#x27;, function ( action ) {
		if ( this.context.length === 0 ) {
			return undefined;
		}
	
		var
			settings   = this.context[0],
			start      = settings._iDisplayStart,
			len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
			visRecords = settings.fnRecordsDisplay(),
			all        = len === -1;
	
		return {
			&quot;page&quot;:           all ? 0 : Math.floor( start / len ),
			&quot;pages&quot;:          all ? 1 : Math.ceil( visRecords / len ),
			&quot;start&quot;:          start,
			&quot;end&quot;:            settings.fnDisplayEnd(),
			&quot;length&quot;:         len,
			&quot;recordsTotal&quot;:   settings.fnRecordsTotal(),
			&quot;recordsDisplay&quot;: visRecords,
			&quot;serverSide&quot;:     _fnDataSource( settings ) === &#x27;ssp&#x27;
		};
	} );
	
	
	/**
	 * Get the current page length.
	 *
	 * @return {integer} Current page length. Note &#x60;-1&#x60; indicates that all records
	 *   are to be shown.
	 *//**
	 * Set the current page length.
	 *
	 * @param {integer} Page length to set. Use &#x60;-1&#x60; to show all records.
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;page.len()&#x27;, function ( len ) {
		// Note that we can&#x27;t call this function &#x27;length()&#x27; because &#x60;length&#x60;
		// is a Javascript property of functions which defines how many arguments
		// the function expects.
		if ( len === undefined ) {
			return this.context.length !== 0 ?
				this.context[0]._iDisplayLength :
				undefined;
		}
	
		// else, set the page length
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnLengthChange( settings, len );
		} );
	} );
	
	
	
	var __reload = function ( settings, holdPosition, callback ) {
		// Use the draw event to trigger a callback
		if ( callback ) {
			var api = new _Api( settings );
	
			api.one( &#x27;draw&#x27;, function () {
				callback( api.ajax.json() );
			} );
		}
	
		if ( _fnDataSource( settings ) == &#x27;ssp&#x27; ) {
			_fnReDraw( settings, holdPosition );
		}
		else {
			_fnProcessingDisplay( settings, true );
	
			// Cancel an existing request
			var xhr = settings.jqXHR;
			if ( xhr &amp;&amp; xhr.readyState !== 4 ) {
				xhr.abort();
			}
	
			// Trigger xhr
			_fnBuildAjax( settings, [], function( json ) {
				_fnClearTable( settings );
	
				var data = _fnAjaxDataSrc( settings, json );
				for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
					_fnAddData( settings, data[i] );
				}
	
				_fnReDraw( settings, holdPosition );
				_fnProcessingDisplay( settings, false );
			} );
		}
	};
	
	
	/**
	 * Get the JSON response from the last Ajax request that DataTables made to the
	 * server. Note that this returns the JSON from the first table in the current
	 * context.
	 *
	 * @return {object} JSON received from the server.
	 */
	_api_register( &#x27;ajax.json()&#x27;, function () {
		var ctx = this.context;
	
		if ( ctx.length &gt; 0 ) {
			return ctx[0].json;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Get the data submitted in the last Ajax request
	 */
	_api_register( &#x27;ajax.params()&#x27;, function () {
		var ctx = this.context;
	
		if ( ctx.length &gt; 0 ) {
			return ctx[0].oAjaxData;
		}
	
		// else return undefined;
	} );
	
	
	/**
	 * Reload tables from the Ajax data source. Note that this function will
	 * automatically re-draw the table when the remote data has been loaded.
	 *
	 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	 *   position. A full re-sort and re-filter is performed when this method is
	 *   called, which is why the pagination reset is the default action.
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;ajax.reload()&#x27;, function ( callback, resetPaging ) {
		return this.iterator( &#x27;table&#x27;, function (settings) {
			__reload( settings, resetPaging===false, callback );
		} );
	} );
	
	
	/**
	 * Get the current Ajax URL. Note that this returns the URL from the first
	 * table in the current context.
	 *
	 * @return {string} Current Ajax source URL
	 *//**
	 * Set the Ajax URL. Note that this will set the URL for all tables in the
	 * current context.
	 *
	 * @param {string} url URL to set.
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;ajax.url()&#x27;, function ( url ) {
		var ctx = this.context;
	
		if ( url === undefined ) {
			// get
			if ( ctx.length === 0 ) {
				return undefined;
			}
			ctx = ctx[0];
	
			return ctx.ajax ?
				$.isPlainObject( ctx.ajax ) ?
					ctx.ajax.url :
					ctx.ajax :
				ctx.sAjaxSource;
		}
	
		// set
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			if ( $.isPlainObject( settings.ajax ) ) {
				settings.ajax.url = url;
			}
			else {
				settings.ajax = url;
			}
			// No need to consider sAjaxSource here since DataTables gives priority
			// to &#x60;ajax&#x60; over &#x60;sAjaxSource&#x60;. So setting &#x60;ajax&#x60; here, renders any
			// value of &#x60;sAjaxSource&#x60; redundant.
		} );
	} );
	
	
	/**
	 * Load data from the newly set Ajax URL. Note that this method is only
	 * available when &#x60;ajax.url()&#x60; is used to set a URL. Additionally, this method
	 * has the same effect as calling &#x60;ajax.reload()&#x60; but is provided for
	 * convenience when setting a new URL. Like &#x60;ajax.reload()&#x60; it will
	 * automatically redraw the table once the remote data has been loaded.
	 *
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;ajax.url().load()&#x27;, function ( callback, resetPaging ) {
		// Same as a reload, but makes sense to present it for easy access after a
		// url change
		return this.iterator( &#x27;table&#x27;, function ( ctx ) {
			__reload( ctx, resetPaging===false, callback );
		} );
	} );
	
	
	
	
	var _selector_run = function ( type, selector, selectFn, settings, opts )
	{
		var
			out = [], res,
			a, i, ien, j, jen,
			selectorType = typeof selector;
	
		// Can&#x27;t just check for isArray here, as an API or jQuery instance might be
		// given with their array like look
		if ( ! selector || selectorType === &#x27;string&#x27; || selectorType === &#x27;function&#x27; || selector.length === undefined ) {
			selector = [ selector ];
		}
	
		for ( i=0, ien=selector.length ; i&lt;ien ; i++ ) {
			// Only split on simple strings - complex expressions will be jQuery selectors
			a = selector[i] &amp;&amp; selector[i].split &amp;&amp; ! selector[i].match(/[\[\(:]/) ?
				selector[i].split(&#x27;,&#x27;) :
				[ selector[i] ];
	
			for ( j=0, jen=a.length ; j&lt;jen ; j++ ) {
				res = selectFn( typeof a[j] === &#x27;string&#x27; ? $.trim(a[j]) : a[j] );
	
				if ( res &amp;&amp; res.length ) {
					out = out.concat( res );
				}
			}
		}
	
		// selector extensions
		var ext = _ext.selector[ type ];
		if ( ext.length ) {
			for ( i=0, ien=ext.length ; i&lt;ien ; i++ ) {
				out = ext[i]( settings, opts, out );
			}
		}
	
		return _unique( out );
	};
	
	
	var _selector_opts = function ( opts )
	{
		if ( ! opts ) {
			opts = {};
		}
	
		// Backwards compatibility for 1.9- which used the terminology filter rather
		// than search
		if ( opts.filter &amp;&amp; opts.search === undefined ) {
			opts.search = opts.filter;
		}
	
		return $.extend( {
			search: &#x27;none&#x27;,
			order: &#x27;current&#x27;,
			page: &#x27;all&#x27;
		}, opts );
	};
	
	
	var _selector_first = function ( inst )
	{
		// Reduce the API instance to the first item found
		for ( var i=0, ien=inst.length ; i&lt;ien ; i++ ) {
			if ( inst[i].length &gt; 0 ) {
				// Assign the first element to the first item in the instance
				// and truncate the instance and context
				inst[0] = inst[i];
				inst[0].length = 1;
				inst.length = 1;
				inst.context = [ inst.context[i] ];
	
				return inst;
			}
		}
	
		// Not found - return an empty instance
		inst.length = 0;
		return inst;
	};
	
	
	var _selector_row_indexes = function ( settings, opts )
	{
		var
			i, ien, tmp, a=[],
			displayFiltered = settings.aiDisplay,
			displayMaster = settings.aiDisplayMaster;
	
		var
			search = opts.search,  // none, applied, removed
			order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
			page   = opts.page;    // all, current
	
		if ( _fnDataSource( settings ) == &#x27;ssp&#x27; ) {
			// In server-side processing mode, most options are irrelevant since
			// rows not shown don&#x27;t exist and the index order is the applied order
			// Removed is a special case - for consistency just return an empty
			// array
			return search === &#x27;removed&#x27; ?
				[] :
				_range( 0, displayMaster.length );
		}
		else if ( page == &#x27;current&#x27; ) {
			// Current page implies that order=current and fitler=applied, since it is
			// fairly senseless otherwise, regardless of what order and search actually
			// are
			for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i&lt;ien ; i++ ) {
				a.push( displayFiltered[i] );
			}
		}
		else if ( order == &#x27;current&#x27; || order == &#x27;applied&#x27; ) {
			a = search == &#x27;none&#x27; ?
				displayMaster.slice() :                      // no search
				search == &#x27;applied&#x27; ?
					displayFiltered.slice() :                // applied search
					$.map( displayMaster, function (el, i) { // removed search
						return $.inArray( el, displayFiltered ) === -1 ? el : null;
					} );
		}
		else if ( order == &#x27;index&#x27; || order == &#x27;original&#x27; ) {
			for ( i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
				if ( search == &#x27;none&#x27; ) {
					a.push( i );
				}
				else { // applied | removed
					tmp = $.inArray( i, displayFiltered );
	
					if ((tmp === -1 &amp;&amp; search == &#x27;removed&#x27;) ||
						(tmp &gt;= 0   &amp;&amp; search == &#x27;applied&#x27;) )
					{
						a.push( i );
					}
				}
			}
		}
	
		return a;
	};
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Rows
	 *
	 * {}          - no selector - use all available rows
	 * {integer}   - row aoData index
	 * {node}      - TR node
	 * {string}    - jQuery selector to apply to the TR elements
	 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	 *
	 */
	
	
	var __row_selector = function ( settings, selector, opts )
	{
		var rows;
		var run = function ( sel ) {
			var selInt = _intVal( sel );
			var i, ien;
	
			// Short cut - selector is a number and no options provided (default is
			// all records, so no need to check if the index is in there, since it
			// must be - dev error if the index doesn&#x27;t exist).
			if ( selInt !== null &amp;&amp; ! opts ) {
				return [ selInt ];
			}
	
			if ( ! rows ) {
				rows = _selector_row_indexes( settings, opts );
			}
	
			if ( selInt !== null &amp;&amp; $.inArray( selInt, rows ) !== -1 ) {
				// Selector - integer
				return [ selInt ];
			}
			else if ( sel === null || sel === undefined || sel === &#x27;&#x27; ) {
				// Selector - none
				return rows;
			}
	
			// Selector - function
			if ( typeof sel === &#x27;function&#x27; ) {
				return $.map( rows, function (idx) {
					var row = settings.aoData[ idx ];
					return sel( idx, row._aData, row.nTr ) ? idx : null;
				} );
			}
	
			// Get nodes in the order from the &#x60;rows&#x60; array with null values removed
			var nodes = _removeEmpty(
				_pluck_order( settings.aoData, rows, &#x27;nTr&#x27; )
			);
	
			// Selector - node
			if ( sel.nodeName ) {
				if ( sel._DT_RowIndex !== undefined ) {
					return [ sel._DT_RowIndex ]; // Property added by DT for fast lookup
				}
				else if ( sel._DT_CellIndex ) {
					return [ sel._DT_CellIndex.row ];
				}
				else {
					var host = $(sel).closest(&#x27;*[data-dt-row]&#x27;);
					return host.length ?
						[ host.data(&#x27;dt-row&#x27;) ] :
						[];
				}
			}
	
			// ID selector. Want to always be able to select rows by id, regardless
			// of if the tr element has been created or not, so can&#x27;t rely upon
			// jQuery here - hence a custom implementation. This does not match
			// Sizzle&#x27;s fast selector or HTML4 - in HTML5 the ID can be anything,
			// but to select it using a CSS selector engine (like Sizzle or
			// querySelect) it would need to need to be escaped for some characters.
			// DataTables simplifies this for row selectors since you can select
			// only a row. A # indicates an id any anything that follows is the id -
			// unescaped.
			if ( typeof sel === &#x27;string&#x27; &amp;&amp; sel.charAt(0) === &#x27;#&#x27; ) {
				// get row index from id
				var rowObj = settings.aIds[ sel.replace( /^#/, &#x27;&#x27; ) ];
				if ( rowObj !== undefined ) {
					return [ rowObj.idx ];
				}
	
				// need to fall through to jQuery in case there is DOM id that
				// matches
			}
	
			// Selector - jQuery selector string, array of nodes or jQuery object/
			// As jQuery&#x27;s .filter() allows jQuery objects to be passed in filter,
			// it also allows arrays, so this will cope with all three options
			return $(nodes)
				.filter( sel )
				.map( function () {
					return this._DT_RowIndex;
				} )
				.toArray();
		};
	
		return _selector_run( &#x27;row&#x27;, selector, run, settings, opts );
	};
	
	
	_api_register( &#x27;rows()&#x27;, function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = &#x27;&#x27;;
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = &#x27;&#x27;;
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( &#x27;table&#x27;, function ( settings ) {
			return __row_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in __row_selector?
		inst.selector.rows = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_register( &#x27;rows().nodes()&#x27;, function () {
		return this.iterator( &#x27;row&#x27;, function ( settings, row ) {
			return settings.aoData[ row ].nTr || undefined;
		}, 1 );
	} );
	
	_api_register( &#x27;rows().data()&#x27;, function () {
		return this.iterator( true, &#x27;rows&#x27;, function ( settings, rows ) {
			return _pluck_order( settings.aoData, rows, &#x27;_aData&#x27; );
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;rows().cache()&#x27;, &#x27;row().cache()&#x27;, function ( type ) {
		return this.iterator( &#x27;row&#x27;, function ( settings, row ) {
			var r = settings.aoData[ row ];
			return type === &#x27;search&#x27; ? r._aFilterData : r._aSortData;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;rows().invalidate()&#x27;, &#x27;row().invalidate()&#x27;, function ( src ) {
		return this.iterator( &#x27;row&#x27;, function ( settings, row ) {
			_fnInvalidate( settings, row, src );
		} );
	} );
	
	_api_registerPlural( &#x27;rows().indexes()&#x27;, &#x27;row().index()&#x27;, function () {
		return this.iterator( &#x27;row&#x27;, function ( settings, row ) {
			return row;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;rows().ids()&#x27;, &#x27;row().id()&#x27;, function ( hash ) {
		var a = [];
		var context = this.context;
	
		// &#x60;iterator&#x60; will drop undefined values, but in this case we want them
		for ( var i=0, ien=context.length ; i&lt;ien ; i++ ) {
			for ( var j=0, jen=this[i].length ; j&lt;jen ; j++ ) {
				var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
				a.push( (hash === true ? &#x27;#&#x27; : &#x27;&#x27; )+ id );
			}
		}
	
		return new _Api( context, a );
	} );
	
	_api_registerPlural( &#x27;rows().remove()&#x27;, &#x27;row().remove()&#x27;, function () {
		var that = this;
	
		this.iterator( &#x27;row&#x27;, function ( settings, row, thatIdx ) {
			var data = settings.aoData;
			var rowData = data[ row ];
			var i, ien, j, jen;
			var loopRow, loopCells;
	
			data.splice( row, 1 );
	
			// Update the cached indexes
			for ( i=0, ien=data.length ; i&lt;ien ; i++ ) {
				loopRow = data[i];
				loopCells = loopRow.anCells;
	
				// Rows
				if ( loopRow.nTr !== null ) {
					loopRow.nTr._DT_RowIndex = i;
				}
	
				// Cells
				if ( loopCells !== null ) {
					for ( j=0, jen=loopCells.length ; j&lt;jen ; j++ ) {
						loopCells[j]._DT_CellIndex.row = i;
					}
				}
			}
	
			// Delete from the display arrays
			_fnDeleteIndex( settings.aiDisplayMaster, row );
			_fnDeleteIndex( settings.aiDisplay, row );
			_fnDeleteIndex( that[ thatIdx ], row, false ); // maintain local indexes
	
			// For server-side processing tables - subtract the deleted row from the count
			if ( settings._iRecordsDisplay &gt; 0 ) {
				settings._iRecordsDisplay--;
			}
	
			// Check for an &#x27;overflow&#x27; they case for displaying the table
			_fnLengthOverflow( settings );
	
			// Remove the row&#x27;s ID reference if there is one
			var id = settings.rowIdFn( rowData._aData );
			if ( id !== undefined ) {
				delete settings.aIds[ id ];
			}
		} );
	
		this.iterator( &#x27;table&#x27;, function ( settings ) {
			for ( var i=0, ien=settings.aoData.length ; i&lt;ien ; i++ ) {
				settings.aoData[i].idx = i;
			}
		} );
	
		return this;
	} );
	
	
	_api_register( &#x27;rows.add()&#x27;, function ( rows ) {
		var newRows = this.iterator( &#x27;table&#x27;, function ( settings ) {
				var row, i, ien;
				var out = [];
	
				for ( i=0, ien=rows.length ; i&lt;ien ; i++ ) {
					row = rows[i];
	
					if ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === &#x27;TR&#x27; ) {
						out.push( _fnAddTr( settings, row )[0] );
					}
					else {
						out.push( _fnAddData( settings, row ) );
					}
				}
	
				return out;
			}, 1 );
	
		// Return an Api.rows() extended instance, so rows().nodes() etc can be used
		var modRows = this.rows( -1 );
		modRows.pop();
		$.merge( modRows, newRows );
	
		return modRows;
	} );
	
	
	
	
	
	/**
	 *
	 */
	_api_register( &#x27;row()&#x27;, function ( selector, opts ) {
		return _selector_first( this.rows( selector, opts ) );
	} );
	
	
	_api_register( &#x27;row().data()&#x27;, function ( data ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// Get
			return ctx.length &amp;&amp; this.length ?
				ctx[0].aoData[ this[0] ]._aData :
				undefined;
		}
	
		// Set
		ctx[0].aoData[ this[0] ]._aData = data;
	
		// Automatically invalidate
		_fnInvalidate( ctx[0], this[0], &#x27;data&#x27; );
	
		return this;
	} );
	
	
	_api_register( &#x27;row().node()&#x27;, function () {
		var ctx = this.context;
	
		return ctx.length &amp;&amp; this.length ?
			ctx[0].aoData[ this[0] ].nTr || null :
			null;
	} );
	
	
	_api_register( &#x27;row.add()&#x27;, function ( row ) {
		// Allow a jQuery object to be passed in - only a single row is added from
		// it though - the first element in the set
		if ( row instanceof $ &amp;&amp; row.length ) {
			row = row[0];
		}
	
		var rows = this.iterator( &#x27;table&#x27;, function ( settings ) {
			if ( row.nodeName &amp;&amp; row.nodeName.toUpperCase() === &#x27;TR&#x27; ) {
				return _fnAddTr( settings, row )[0];
			}
			return _fnAddData( settings, row );
		} );
	
		// Return an Api.rows() extended instance, with the newly added row selected
		return this.row( rows[0] );
	} );
	
	
	
	var __details_add = function ( ctx, row, data, klass )
	{
		// Convert to array of TR elements
		var rows = [];
		var addRow = function ( r, k ) {
			// Recursion to allow for arrays of jQuery objects
			if ( $.isArray( r ) || r instanceof $ ) {
				for ( var i=0, ien=r.length ; i&lt;ien ; i++ ) {
					addRow( r[i], k );
				}
				return;
			}
	
			// If we get a TR element, then just add it directly - up to the dev
			// to add the correct number of columns etc
			if ( r.nodeName &amp;&amp; r.nodeName.toLowerCase() === &#x27;tr&#x27; ) {
				rows.push( r );
			}
			else {
				// Otherwise create a row with a wrapper
				var created = $(&#x27;&lt;tr&gt;&lt;td/&gt;&lt;/tr&gt;&#x27;).addClass( k );
				$(&#x27;td&#x27;, created)
					.addClass( k )
					.html( r )
					[0].colSpan = _fnVisbleColumns( ctx );
	
				rows.push( created[0] );
			}
		};
	
		addRow( data, klass );
	
		if ( row._details ) {
			row._details.detach();
		}
	
		row._details = $(rows);
	
		// If the children were already shown, that state should be retained
		if ( row._detailsShow ) {
			row._details.insertAfter( row.nTr );
		}
	};
	
	
	var __details_remove = function ( api, idx )
	{
		var ctx = api.context;
	
		if ( ctx.length ) {
			var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];
	
			if ( row &amp;&amp; row._details ) {
				row._details.remove();
	
				row._detailsShow = undefined;
				row._details = undefined;
			}
		}
	};
	
	
	var __details_display = function ( api, show ) {
		var ctx = api.context;
	
		if ( ctx.length &amp;&amp; api.length ) {
			var row = ctx[0].aoData[ api[0] ];
	
			if ( row._details ) {
				row._detailsShow = show;
	
				if ( show ) {
					row._details.insertAfter( row.nTr );
				}
				else {
					row._details.detach();
				}
	
				__details_events( ctx[0] );
			}
		}
	};
	
	
	var __details_events = function ( settings )
	{
		var api = new _Api( settings );
		var namespace = &#x27;.dt.DT_details&#x27;;
		var drawEvent = &#x27;draw&#x27;+namespace;
		var colvisEvent = &#x27;column-visibility&#x27;+namespace;
		var destroyEvent = &#x27;destroy&#x27;+namespace;
		var data = settings.aoData;
	
		api.off( drawEvent +&#x27; &#x27;+ colvisEvent +&#x27; &#x27;+ destroyEvent );
	
		if ( _pluck( data, &#x27;_details&#x27; ).length &gt; 0 ) {
			// On each draw, insert the required elements into the document
			api.on( drawEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				api.rows( {page:&#x27;current&#x27;} ).eq(0).each( function (idx) {
					// Internal data grab
					var row = data[ idx ];
	
					if ( row._detailsShow ) {
						row._details.insertAfter( row.nTr );
					}
				} );
			} );
	
			// Column visibility change - update the colspan
			api.on( colvisEvent, function ( e, ctx, idx, vis ) {
				if ( settings !== ctx ) {
					return;
				}
	
				// Update the colspan for the details rows (note, only if it already has
				// a colspan)
				var row, visible = _fnVisbleColumns( ctx );
	
				for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
					row = data[i];
	
					if ( row._details ) {
						row._details.children(&#x27;td[colspan]&#x27;).attr(&#x27;colspan&#x27;, visible );
					}
				}
			} );
	
			// Table destroyed - nuke any child rows
			api.on( destroyEvent, function ( e, ctx ) {
				if ( settings !== ctx ) {
					return;
				}
	
				for ( var i=0, ien=data.length ; i&lt;ien ; i++ ) {
					if ( data[i]._details ) {
						__details_remove( api, i );
					}
				}
			} );
		}
	};
	
	// Strings for the method names to help minification
	var _emp = &#x27;&#x27;;
	var _child_obj = _emp+&#x27;row().child&#x27;;
	var _child_mth = _child_obj+&#x27;()&#x27;;
	
	// data can be:
	//  tr
	//  string
	//  jQuery or array of any of the above
	_api_register( _child_mth, function ( data, klass ) {
		var ctx = this.context;
	
		if ( data === undefined ) {
			// get
			return ctx.length &amp;&amp; this.length ?
				ctx[0].aoData[ this[0] ]._details :
				undefined;
		}
		else if ( data === true ) {
			// show
			this.child.show();
		}
		else if ( data === false ) {
			// remove
			__details_remove( this );
		}
		else if ( ctx.length &amp;&amp; this.length ) {
			// set
			__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
		}
	
		return this;
	} );
	
	
	_api_register( [
		_child_obj+&#x27;.show()&#x27;,
		_child_mth+&#x27;.show()&#x27; // only when &#x60;child()&#x60; was called with parameters (without
	], function ( show ) {   // it returns an object and this method is not executed)
		__details_display( this, true );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+&#x27;.hide()&#x27;,
		_child_mth+&#x27;.hide()&#x27; // only when &#x60;child()&#x60; was called with parameters (without
	], function () {         // it returns an object and this method is not executed)
		__details_display( this, false );
		return this;
	} );
	
	
	_api_register( [
		_child_obj+&#x27;.remove()&#x27;,
		_child_mth+&#x27;.remove()&#x27; // only when &#x60;child()&#x60; was called with parameters (without
	], function () {           // it returns an object and this method is not executed)
		__details_remove( this );
		return this;
	} );
	
	
	_api_register( _child_obj+&#x27;.isShown()&#x27;, function () {
		var ctx = this.context;
	
		if ( ctx.length &amp;&amp; this.length ) {
			// _detailsShown as false or undefined will fall through to return false
			return ctx[0].aoData[ this[0] ]._detailsShow || false;
		}
		return false;
	} );
	
	
	
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Columns
	 *
	 * {integer}           - column index (&gt;=0 count from left, &lt;0 count from right)
	 * &quot;{integer}:visIdx&quot;  - visible column index (i.e. translate to column index)  (&gt;=0 count from left, &lt;0 count from right)
	 * &quot;{integer}:visible&quot; - alias for {integer}:visIdx  (&gt;=0 count from left, &lt;0 count from right)
	 * &quot;{string}:name&quot;     - column name
	 * &quot;{string}&quot;          - jQuery selector on column header nodes
	 *
	 */
	
	// can be an array of these items, comma separated list, or an array of comma
	// separated lists
	
	var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
	
	
	// r1 and r2 are redundant - but it means that the parameters match for the
	// iterator callback in columns().data()
	var __columnData = function ( settings, column, r1, r2, rows ) {
		var a = [];
		for ( var row=0, ien=rows.length ; row&lt;ien ; row++ ) {
			a.push( _fnGetCellData( settings, rows[row], column ) );
		}
		return a;
	};
	
	
	var __column_selector = function ( settings, selector, opts )
	{
		var
			columns = settings.aoColumns,
			names = _pluck( columns, &#x27;sName&#x27; ),
			nodes = _pluck( columns, &#x27;nTh&#x27; );
	
		var run = function ( s ) {
			var selInt = _intVal( s );
	
			// Selector - all
			if ( s === &#x27;&#x27; ) {
				return _range( columns.length );
			}
	
			// Selector - index
			if ( selInt !== null ) {
				return [ selInt &gt;= 0 ?
					selInt : // Count from left
					columns.length + selInt // Count from right (+ because its a negative value)
				];
			}
	
			// Selector = function
			if ( typeof s === &#x27;function&#x27; ) {
				var rows = _selector_row_indexes( settings, opts );
	
				return $.map( columns, function (col, idx) {
					return s(
							idx,
							__columnData( settings, idx, 0, 0, rows ),
							nodes[ idx ]
						) ? idx : null;
				} );
			}
	
			// jQuery or string selector
			var match = typeof s === &#x27;string&#x27; ?
				s.match( __re_column_selector ) :
				&#x27;&#x27;;
	
			if ( match ) {
				switch( match[2] ) {
					case &#x27;visIdx&#x27;:
					case &#x27;visible&#x27;:
						var idx = parseInt( match[1], 10 );
						// Visible index given, convert to column index
						if ( idx &lt; 0 ) {
							// Counting from the right
							var visColumns = $.map( columns, function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
	
					case &#x27;name&#x27;:
						// match by name. &#x60;names&#x60; is column index complete and in order
						return $.map( names, function (name, i) {
							return name === match[1] ? i : null;
						} );
	
					default:
						return [];
				}
			}
	
			// Cell in the table body
			if ( s.nodeName &amp;&amp; s._DT_CellIndex ) {
				return [ s._DT_CellIndex.column ];
			}
	
			// jQuery selector on the TH elements for the columns
			var jqResult = $( nodes )
				.filter( s )
				.map( function () {
					return $.inArray( this, nodes ); // &#x60;nodes&#x60; is column index complete and in order
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise a node which might have a &#x60;dt-column&#x60; data attribute, or be
			// a child or such an element
			var host = $(s).closest(&#x27;*[data-dt-column]&#x27;);
			return host.length ?
				[ host.data(&#x27;dt-column&#x27;) ] :
				[];
		};
	
		return _selector_run( &#x27;column&#x27;, selector, run, settings, opts );
	};
	
	
	var __setColumnVis = function ( settings, column, vis ) {
		var
			cols = settings.aoColumns,
			col  = cols[ column ],
			data = settings.aoData,
			row, cells, i, ien, tr;
	
		// Get
		if ( vis === undefined ) {
			return col.bVisible;
		}
	
		// Set
		// No change
		if ( col.bVisible === vis ) {
			return;
		}
	
		if ( vis ) {
			// Insert column
			// Need to decide if we should use appendChild or insertBefore
			var insertBefore = $.inArray( true, _pluck(cols, &#x27;bVisible&#x27;), column+1 );
	
			for ( i=0, ien=data.length ; i&lt;ien ; i++ ) {
				tr = data[i].nTr;
				cells = data[i].anCells;
	
				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
		else {
			// Remove column
			$( _pluck( settings.aoData, &#x27;anCells&#x27;, column ) ).detach();
		}
	
		// Common actions
		col.bVisible = vis;
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );
	
		_fnSaveState( settings );
	};
	
	
	_api_register( &#x27;columns()&#x27;, function ( selector, opts ) {
		// argument shifting
		if ( selector === undefined ) {
			selector = &#x27;&#x27;;
		}
		else if ( $.isPlainObject( selector ) ) {
			opts = selector;
			selector = &#x27;&#x27;;
		}
	
		opts = _selector_opts( opts );
	
		var inst = this.iterator( &#x27;table&#x27;, function ( settings ) {
			return __column_selector( settings, selector, opts );
		}, 1 );
	
		// Want argument shifting here and in _row_selector?
		inst.selector.cols = selector;
		inst.selector.opts = opts;
	
		return inst;
	} );
	
	_api_registerPlural( &#x27;columns().header()&#x27;, &#x27;column().header()&#x27;, function ( selector, opts ) {
		return this.iterator( &#x27;column&#x27;, function ( settings, column ) {
			return settings.aoColumns[column].nTh;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().footer()&#x27;, &#x27;column().footer()&#x27;, function ( selector, opts ) {
		return this.iterator( &#x27;column&#x27;, function ( settings, column ) {
			return settings.aoColumns[column].nTf;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().data()&#x27;, &#x27;column().data()&#x27;, function () {
		return this.iterator( &#x27;column-rows&#x27;, __columnData, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().dataSrc()&#x27;, &#x27;column().dataSrc()&#x27;, function () {
		return this.iterator( &#x27;column&#x27;, function ( settings, column ) {
			return settings.aoColumns[column].mData;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().cache()&#x27;, &#x27;column().cache()&#x27;, function ( type ) {
		return this.iterator( &#x27;column-rows&#x27;, function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows,
				type === &#x27;search&#x27; ? &#x27;_aFilterData&#x27; : &#x27;_aSortData&#x27;, column
			);
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().nodes()&#x27;, &#x27;column().nodes()&#x27;, function () {
		return this.iterator( &#x27;column-rows&#x27;, function ( settings, column, i, j, rows ) {
			return _pluck_order( settings.aoData, rows, &#x27;anCells&#x27;, column ) ;
		}, 1 );
	} );
	
	_api_registerPlural( &#x27;columns().visible()&#x27;, &#x27;column().visible()&#x27;, function ( vis, calc ) {
		var ret = this.iterator( &#x27;column&#x27;, function ( settings, column ) {
			if ( vis === undefined ) {
				return settings.aoColumns[ column ].bVisible;
			} // else
			__setColumnVis( settings, column, vis );
		} );
	
		// Group the column visibility changes
		if ( vis !== undefined ) {
			// Second loop once the first is done for events
			this.iterator( &#x27;column&#x27;, function ( settings, column ) {
				_fnCallbackFire( settings, null, &#x27;column-visibility&#x27;, [settings, column, vis, calc] );
			} );
	
			if ( calc === undefined || calc ) {
				this.columns.adjust();
			}
		}
	
		return ret;
	} );
	
	_api_registerPlural( &#x27;columns().indexes()&#x27;, &#x27;column().index()&#x27;, function ( type ) {
		return this.iterator( &#x27;column&#x27;, function ( settings, column ) {
			return type === &#x27;visible&#x27; ?
				_fnColumnIndexToVisible( settings, column ) :
				column;
		}, 1 );
	} );
	
	_api_register( &#x27;columns.adjust()&#x27;, function () {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnAdjustColumnSizing( settings );
		}, 1 );
	} );
	
	_api_register( &#x27;column.index()&#x27;, function ( type, idx ) {
		if ( this.context.length !== 0 ) {
			var ctx = this.context[0];
	
			if ( type === &#x27;fromVisible&#x27; || type === &#x27;toData&#x27; ) {
				return _fnVisibleToColumnIndex( ctx, idx );
			}
			else if ( type === &#x27;fromData&#x27; || type === &#x27;toVisible&#x27; ) {
				return _fnColumnIndexToVisible( ctx, idx );
			}
		}
	} );
	
	_api_register( &#x27;column()&#x27;, function ( selector, opts ) {
		return _selector_first( this.columns( selector, opts ) );
	} );
	
	
	
	var __cell_selector = function ( settings, selector, opts )
	{
		var data = settings.aoData;
		var rows = _selector_row_indexes( settings, opts );
		var cells = _removeEmpty( _pluck_order( data, rows, &#x27;anCells&#x27; ) );
		var allCells = $( [].concat.apply([], cells) );
		var row;
		var columns = settings.aoColumns.length;
		var a, i, ien, j, o, host;
	
		var run = function ( s ) {
			var fnSelector = typeof s === &#x27;function&#x27;;
	
			if ( s === null || s === undefined || fnSelector ) {
				// All cells and function selectors
				a = [];
	
				for ( i=0, ien=rows.length ; i&lt;ien ; i++ ) {
					row = rows[i];
	
					for ( j=0 ; j&lt;columns ; j++ ) {
						o = {
							row: row,
							column: j
						};
	
						if ( fnSelector ) {
							// Selector - function
							host = data[ row ];
	
							if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
								a.push( o );
							}
						}
						else {
							// Selector - all
							a.push( o );
						}
					}
				}
	
				return a;
			}
			
			// Selector - index
			if ( $.isPlainObject( s ) ) {
				return [s];
			}
	
			// Selector - jQuery filtered cells
			var jqResult = allCells
				.filter( s )
				.map( function (i, el) {
					return { // use a new object, in case someone changes the values
						row:    el._DT_CellIndex.row,
						column: el._DT_CellIndex.column
	 				};
				} )
				.toArray();
	
			if ( jqResult.length || ! s.nodeName ) {
				return jqResult;
			}
	
			// Otherwise the selector is a node, and there is one last option - the
			// element might be a child of an element which has dt-row and dt-column
			// data attributes
			host = $(s).closest(&#x27;*[data-dt-row]&#x27;);
			return host.length ?
				[ {
					row: host.data(&#x27;dt-row&#x27;),
					column: host.data(&#x27;dt-column&#x27;)
				} ] :
				[];
		};
	
		return _selector_run( &#x27;cell&#x27;, selector, run, settings, opts );
	};
	
	
	
	
	_api_register( &#x27;cells()&#x27;, function ( rowSelector, columnSelector, opts ) {
		// Argument shifting
		if ( $.isPlainObject( rowSelector ) ) {
			// Indexes
			if ( rowSelector.row === undefined ) {
				// Selector options in first parameter
				opts = rowSelector;
				rowSelector = null;
			}
			else {
				// Cell index objects in first parameter
				opts = columnSelector;
				columnSelector = null;
			}
		}
		if ( $.isPlainObject( columnSelector ) ) {
			opts = columnSelector;
			columnSelector = null;
		}
	
		// Cell selector
		if ( columnSelector === null || columnSelector === undefined ) {
			return this.iterator( &#x27;table&#x27;, function ( settings ) {
				return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
			} );
		}
	
		// Row + column selector
		var columns = this.columns( columnSelector, opts );
		var rows = this.rows( rowSelector, opts );
		var a, i, ien, j, jen;
	
		var cells = this.iterator( &#x27;table&#x27;, function ( settings, idx ) {
			a = [];
	
			for ( i=0, ien=rows[idx].length ; i&lt;ien ; i++ ) {
				for ( j=0, jen=columns[idx].length ; j&lt;jen ; j++ ) {
					a.push( {
						row:    rows[idx][i],
						column: columns[idx][j]
					} );
				}
			}
	
			return a;
		}, 1 );
	
		$.extend( cells.selector, {
			cols: columnSelector,
			rows: rowSelector,
			opts: opts
		} );
	
		return cells;
	} );
	
	
	_api_registerPlural( &#x27;cells().nodes()&#x27;, &#x27;cell().node()&#x27;, function () {
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			var data = settings.aoData[ row ];
	
			return data &amp;&amp; data.anCells ?
				data.anCells[ column ] :
				undefined;
		}, 1 );
	} );
	
	
	_api_register( &#x27;cells().data()&#x27;, function () {
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column );
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;cells().cache()&#x27;, &#x27;cell().cache()&#x27;, function ( type ) {
		type = type === &#x27;search&#x27; ? &#x27;_aFilterData&#x27; : &#x27;_aSortData&#x27;;
	
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			return settings.aoData[ row ][ type ][ column ];
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;cells().render()&#x27;, &#x27;cell().render()&#x27;, function ( type ) {
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			return _fnGetCellData( settings, row, column, type );
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;cells().indexes()&#x27;, &#x27;cell().index()&#x27;, function () {
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			return {
				row: row,
				column: column,
				columnVisible: _fnColumnIndexToVisible( settings, column )
			};
		}, 1 );
	} );
	
	
	_api_registerPlural( &#x27;cells().invalidate()&#x27;, &#x27;cell().invalidate()&#x27;, function ( src ) {
		return this.iterator( &#x27;cell&#x27;, function ( settings, row, column ) {
			_fnInvalidate( settings, row, src, column );
		} );
	} );
	
	
	
	_api_register( &#x27;cell()&#x27;, function ( rowSelector, columnSelector, opts ) {
		return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
	} );
	
	
	_api_register( &#x27;cell().data()&#x27;, function ( data ) {
		var ctx = this.context;
		var cell = this[0];
	
		if ( data === undefined ) {
			// Get
			return ctx.length &amp;&amp; cell.length ?
				_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
				undefined;
		}
	
		// Set
		_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
		_fnInvalidate( ctx[0], cell[0].row, &#x27;data&#x27;, cell[0].column );
	
		return this;
	} );
	
	
	
	/**
	 * Get current ordering (sorting) that has been applied to the table.
	 *
	 * @returns {array} 2D array containing the sorting information for the first
	 *   table in the current context. Each element in the parent array represents
	 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	 *   the column index that the sorting condition applies to, the second is the
	 *   direction of the sort (&#x60;desc&#x60; or &#x60;asc&#x60;) and, optionally, the third is the
	 *   index of the sorting order from the &#x60;column.sorting&#x60; initialisation array.
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {integer} order Column index to sort upon.
	 * @param {string} direction Direction of the sort to be applied (&#x60;asc&#x60; or &#x60;desc&#x60;)
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 1D array of sorting information to be applied.
	 * @param {array} [...] Optional additional sorting conditions
	 * @returns {DataTables.Api} this
	 *//**
	 * Set the ordering for the table.
	 *
	 * @param {array} order 2D array of sorting information to be applied.
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;order()&#x27;, function ( order, dir ) {
		var ctx = this.context;
	
		if ( order === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].aaSorting :
				undefined;
		}
	
		// set
		if ( typeof order === &#x27;number&#x27; ) {
			// Simple column / direction passed in
			order = [ [ order, dir ] ];
		}
		else if ( order.length &amp;&amp; ! $.isArray( order[0] ) ) {
			// Arguments passed in (list of 1D arrays)
			order = Array.prototype.slice.call( arguments );
		}
		// otherwise a 2D array was passed in
	
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			settings.aaSorting = order.slice();
		} );
	} );
	
	
	/**
	 * Attach a sort listener to an element for a given column
	 *
	 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	 *   listener to. This can take the form of a single DOM node, a jQuery
	 *   collection of nodes or a jQuery selector which will identify the node(s).
	 * @param {integer} column the column that a click on this node will sort on
	 * @param {function} [callback] callback function when sort is run
	 * @returns {DataTables.Api} this
	 */
	_api_register( &#x27;order.listener()&#x27;, function ( node, column, callback ) {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnSortAttachListener( settings, node, column, callback );
		} );
	} );
	
	
	_api_register( &#x27;order.fixed()&#x27;, function ( set ) {
		if ( ! set ) {
			var ctx = this.context;
			var fixed = ctx.length ?
				ctx[0].aaSortingFixed :
				undefined;
	
			return $.isArray( fixed ) ?
				{ pre: fixed } :
				fixed;
		}
	
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			settings.aaSortingFixed = $.extend( true, {}, set );
		} );
	} );
	
	
	// Order by the selected column(s)
	_api_register( [
		&#x27;columns().order()&#x27;,
		&#x27;column().order()&#x27;
	], function ( dir ) {
		var that = this;
	
		return this.iterator( &#x27;table&#x27;, function ( settings, i ) {
			var sort = [];
	
			$.each( that[i], function (j, col) {
				sort.push( [ col, dir ] );
			} );
	
			settings.aaSorting = sort;
		} );
	} );
	
	
	
	_api_register( &#x27;search()&#x27;, function ( input, regex, smart, caseInsen ) {
		var ctx = this.context;
	
		if ( input === undefined ) {
			// get
			return ctx.length !== 0 ?
				ctx[0].oPreviousSearch.sSearch :
				undefined;
		}
	
		// set
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}
	
			_fnFilterComplete( settings, $.extend( {}, settings.oPreviousSearch, {
				&quot;sSearch&quot;: input+&quot;&quot;,
				&quot;bRegex&quot;:  regex === null ? false : regex,
				&quot;bSmart&quot;:  smart === null ? true  : smart,
				&quot;bCaseInsensitive&quot;: caseInsen === null ? true : caseInsen
			} ), 1 );
		} );
	} );
	
	
	_api_registerPlural(
		&#x27;columns().search()&#x27;,
		&#x27;column().search()&#x27;,
		function ( input, regex, smart, caseInsen ) {
			return this.iterator( &#x27;column&#x27;, function ( settings, column ) {
				var preSearch = settings.aoPreSearchCols;
	
				if ( input === undefined ) {
					// get
					return preSearch[ column ].sSearch;
				}
	
				// set
				if ( ! settings.oFeatures.bFilter ) {
					return;
				}
	
				$.extend( preSearch[ column ], {
					&quot;sSearch&quot;: input+&quot;&quot;,
					&quot;bRegex&quot;:  regex === null ? false : regex,
					&quot;bSmart&quot;:  smart === null ? true  : smart,
					&quot;bCaseInsensitive&quot;: caseInsen === null ? true : caseInsen
				} );
	
				_fnFilterComplete( settings, settings.oPreviousSearch, 1 );
			} );
		}
	);
	
	/*
	 * State API methods
	 */
	
	_api_register( &#x27;state()&#x27;, function () {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	} );
	
	
	_api_register( &#x27;state.clear()&#x27;, function () {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			// Save an empty object
			settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
		} );
	} );
	
	
	_api_register( &#x27;state.loaded()&#x27;, function () {
		return this.context.length ?
			this.context[0].oLoadedState :
			null;
	} );
	
	
	_api_register( &#x27;state.save()&#x27;, function () {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnSaveState( settings );
		} );
	} );
	
	
	
	/**
	 * Provide a common method for plug-ins to check the version of DataTables being
	 * used, in order to ensure compatibility.
	 *
	 *  @param {string} version Version string to check for, in the format &quot;X.Y.Z&quot;.
	 *    Note that the formats &quot;X&quot; and &quot;X.Y&quot; are also acceptable.
	 *  @returns {boolean} true if this version of DataTables is greater or equal to
	 *    the required version, or false if this version of DataTales is not
	 *    suitable
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    alert( $.fn.dataTable.versionCheck( &#x27;1.9.0&#x27; ) );
	 */
	DataTable.versionCheck = DataTable.fnVersionCheck = function( version )
	{
		var aThis = DataTable.version.split(&#x27;.&#x27;);
		var aThat = version.split(&#x27;.&#x27;);
		var iThis, iThat;
	
		for ( var i=0, iLen=aThat.length ; i&lt;iLen ; i++ ) {
			iThis = parseInt( aThis[i], 10 ) || 0;
			iThat = parseInt( aThat[i], 10 ) || 0;
	
			// Parts are the same, keep comparing
			if (iThis === iThat) {
				continue;
			}
	
			// Parts are different, return immediately
			return iThis &gt; iThat;
		}
	
		return true;
	};
	
	
	/**
	 * Check if a &#x60;&lt;table&gt;&#x60; node is a DataTable table already or not.
	 *
	 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	 *      selector for the table to test. Note that if more than more than one
	 *      table is passed on, only the first will be checked
	 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    if ( ! $.fn.DataTable.isDataTable( &#x27;#example&#x27; ) ) {
	 *      $(&#x27;#example&#x27;).dataTable();
	 *    }
	 */
	DataTable.isDataTable = DataTable.fnIsDataTable = function ( table )
	{
		var t = $(table).get(0);
		var is = false;
	
		if ( table instanceof DataTable.Api ) {
			return true;
		}
	
		$.each( DataTable.settings, function (i, o) {
			var head = o.nScrollHead ? $(&#x27;table&#x27;, o.nScrollHead)[0] : null;
			var foot = o.nScrollFoot ? $(&#x27;table&#x27;, o.nScrollFoot)[0] : null;
	
			if ( o.nTable === t || head === t || foot === t ) {
				is = true;
			}
		} );
	
		return is;
	};
	
	
	/**
	 * Get all DataTable tables that have been initialised - optionally you can
	 * select to get only currently visible tables.
	 *
	 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	 *    or visible tables only.
	 *  @returns {array} Array of &#x60;table&#x60; nodes (not DataTable instances) which are
	 *    DataTables
	 *  @static
	 *  @dtopt API-Static
	 *
	 *  @example
	 *    $.each( $.fn.dataTable.tables(true), function () {
	 *      $(table).DataTable().columns.adjust();
	 *    } );
	 */
	DataTable.tables = DataTable.fnTables = function ( visible )
	{
		var api = false;
	
		if ( $.isPlainObject( visible ) ) {
			api = visible.api;
			visible = visible.visible;
		}
	
		var a = $.map( DataTable.settings, function (o) {
			if ( !visible || (visible &amp;&amp; $(o.nTable).is(&#x27;:visible&#x27;)) ) {
				return o.nTable;
			}
		} );
	
		return api ?
			new _Api( a ) :
			a;
	};
	
	
	/**
	 * Convert from camel case parameters to Hungarian notation. This is made public
	 * for the extensions to provide the same ability as DataTables core to accept
	 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	 * parameters.
	 *
	 *  @param {object} src The model object which holds all parameters that can be
	 *    mapped.
	 *  @param {object} user The object to convert from camel case to Hungarian.
	 *  @param {boolean} force When set to &#x60;true&#x60;, properties which already have a
	 *    Hungarian value in the &#x60;user&#x60; object will be overwritten. Otherwise they
	 *    won&#x27;t be.
	 */
	DataTable.camelToHungarian = _fnCamelToHungarian;
	
	
	
	/**
	 *
	 */
	_api_register( &#x27;$()&#x27;, function ( selector, opts ) {
		var
			rows   = this.rows( opts ).nodes(), // Get all rows
			jqRows = $(rows);
	
		return $( [].concat(
			jqRows.filter( selector ).toArray(),
			jqRows.find( selector ).toArray()
		) );
	} );
	
	
	// jQuery functions to operate on the tables
	$.each( [ &#x27;on&#x27;, &#x27;one&#x27;, &#x27;off&#x27; ], function (i, key) {
		_api_register( key+&#x27;()&#x27;, function ( /* event, handler */ ) {
			var args = Array.prototype.slice.call(arguments);
	
			// Add the &#x60;dt&#x60; namespace automatically if it isn&#x27;t already present
			args[0] = $.map( args[0].split( /\s/ ), function ( e ) {
				return ! e.match(/\.dt\b/) ?
					e+&#x27;.dt&#x27; :
					e;
				} ).join( &#x27; &#x27; );
	
			var inst = $( this.tables().nodes() );
			inst[key].apply( inst, args );
			return this;
		} );
	} );
	
	
	_api_register( &#x27;clear()&#x27;, function () {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			_fnClearTable( settings );
		} );
	} );
	
	
	_api_register( &#x27;settings()&#x27;, function () {
		return new _Api( this.context, this.context );
	} );
	
	
	_api_register( &#x27;init()&#x27;, function () {
		var ctx = this.context;
		return ctx.length ? ctx[0].oInit : null;
	} );
	
	
	_api_register( &#x27;data()&#x27;, function () {
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			return _pluck( settings.aoData, &#x27;_aData&#x27; );
		} ).flatten();
	} );
	
	
	_api_register( &#x27;destroy()&#x27;, function ( remove ) {
		remove = remove || false;
	
		return this.iterator( &#x27;table&#x27;, function ( settings ) {
			var orig      = settings.nTableWrapper.parentNode;
			var classes   = settings.oClasses;
			var table     = settings.nTable;
			var tbody     = settings.nTBody;
			var thead     = settings.nTHead;
			var tfoot     = settings.nTFoot;
			var jqTable   = $(table);
			var jqTbody   = $(tbody);
			var jqWrapper = $(settings.nTableWrapper);
			var rows      = $.map( settings.aoData, function (r) { return r.nTr; } );
			var i, ien;
	
			// Flag to note that the table is currently being destroyed - no action
			// should be taken
			settings.bDestroying = true;
	
			// Fire off the destroy callbacks for plug-ins etc
			_fnCallbackFire( settings, &quot;aoDestroyCallback&quot;, &quot;destroy&quot;, [settings] );
	
			// If not being removed from the document, make all columns visible
			if ( ! remove ) {
				new _Api( settings ).columns().visible( true );
			}
	
			// Blitz all &#x60;DT&#x60; namespaced events (these are internal events, the
			// lowercase, &#x60;dt&#x60; events are user subscribed and they are responsible
			// for removing them
			jqWrapper.off(&#x27;.DT&#x27;).find(&#x27;:not(tbody *)&#x27;).off(&#x27;.DT&#x27;);
			$(window).off(&#x27;.DT-&#x27;+settings.sInstance);
	
			// When scrolling we had to break the table up - restore it
			if ( table != thead.parentNode ) {
				jqTable.children(&#x27;thead&#x27;).detach();
				jqTable.append( thead );
			}
	
			if ( tfoot &amp;&amp; table != tfoot.parentNode ) {
				jqTable.children(&#x27;tfoot&#x27;).detach();
				jqTable.append( tfoot );
			}
	
			settings.aaSorting = [];
			settings.aaSortingFixed = [];
			_fnSortingClasses( settings );
	
			$( rows ).removeClass( settings.asStripeClasses.join(&#x27; &#x27;) );
	
			$(&#x27;th, td&#x27;, thead).removeClass( classes.sSortable+&#x27; &#x27;+
				classes.sSortableAsc+&#x27; &#x27;+classes.sSortableDesc+&#x27; &#x27;+classes.sSortableNone
			);
	
			// Add the TR elements back into the table in their original order
			jqTbody.children().detach();
			jqTbody.append( rows );
	
			// Remove the DataTables generated nodes, events and classes
			var removedMethod = remove ? &#x27;remove&#x27; : &#x27;detach&#x27;;
			jqTable[ removedMethod ]();
			jqWrapper[ removedMethod ]();
	
			// If we need to reattach the table to the document
			if ( ! remove &amp;&amp; orig ) {
				// insertBefore acts like appendChild if !arg[1]
				orig.insertBefore( table, settings.nTableReinsertBefore );
	
				// Restore the width of the original table - was read from the style property,
				// so we can restore directly to that
				jqTable
					.css( &#x27;width&#x27;, settings.sDestroyWidth )
					.removeClass( classes.sTable );
	
				// If the were originally stripe classes - then we add them back here.
				// Note this is not fool proof (for example if not all rows had stripe
				// classes - but it&#x27;s a good effort without getting carried away
				ien = settings.asDestroyStripes.length;
	
				if ( ien ) {
					jqTbody.children().each( function (i) {
						$(this).addClass( settings.asDestroyStripes[i % ien] );
					} );
				}
			}
	
			/* Remove the settings object from the settings array */
			var idx = $.inArray( settings, DataTable.settings );
			if ( idx !== -1 ) {
				DataTable.settings.splice( idx, 1 );
			}
		} );
	} );
	
	
	// Add the &#x60;every()&#x60; method for rows, columns and cells in a compact form
	$.each( [ &#x27;column&#x27;, &#x27;row&#x27;, &#x27;cell&#x27; ], function ( i, type ) {
		_api_register( type+&#x27;s().every()&#x27;, function ( fn ) {
			var opts = this.selector.opts;
			var api = this;
	
			return this.iterator( type, function ( settings, arg1, arg2, arg3, arg4 ) {
				// Rows and columns:
				//  arg1 - index
				//  arg2 - table counter
				//  arg3 - loop counter
				//  arg4 - undefined
				// Cells:
				//  arg1 - row index
				//  arg2 - column index
				//  arg3 - table counter
				//  arg4 - loop counter
				fn.call(
					api[ type ](
						arg1,
						type===&#x27;cell&#x27; ? arg2 : opts,
						type===&#x27;cell&#x27; ? opts : undefined
					),
					arg1, arg2, arg3, arg4
				);
			} );
		} );
	} );
	
	
	// i18n method for extensions to be able to use the language object from the
	// DataTable
	_api_register( &#x27;i18n()&#x27;, function ( token, def, plural ) {
		var ctx = this.context[0];
		var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );
	
		if ( resolved === undefined ) {
			resolved = def;
		}
	
		if ( plural !== undefined &amp;&amp; $.isPlainObject( resolved ) ) {
			resolved = resolved[ plural ] !== undefined ?
				resolved[ plural ] :
				resolved._;
		}
	
		return resolved.replace( &#x27;%d&#x27;, plural ); // nb: plural might be undefined,
	} );

	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * &#x60;a.b.c-d&#x60; where: a:int, b:int, c:int, d:string(dev|beta|alpha). &#x60;d&#x60; is used
	 * only for non-release builds. See http://semver.org/ for more information.
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = &quot;1.10.16&quot;;

	/**
	 * Private data store, containing all of the settings objects that are
	 * created for the tables on a given page.
	 *
	 * Note that the &#x60;DataTable.settings&#x60; object is aliased to
	 * &#x60;jQuery.fn.dataTableExt&#x60; through which it may be accessed and
	 * manipulated, or &#x60;jQuery.fn.dataTable.settings&#x60;.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has
	 * available to it. These models define the objects that are used to hold
	 * the active state and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		&quot;bCaseInsensitive&quot;: true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;/i&gt;
		 */
		&quot;sSearch&quot;: &quot;&quot;,
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		&quot;bRegex&quot;: false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		&quot;bSmart&quot;: true
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		&quot;nTr&quot;: null,
	
		/**
		 * Array of TD elements for each row. This is null until the row has been
		 * created.
		 *  @type array nodes
		 *  @default []
		 */
		&quot;anCells&quot;: null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mData options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		&quot;_aData&quot;: [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default null
		 *  @private
		 */
		&quot;_aSortData&quot;: null,
	
		/**
		 * Per cell filtering data cache. As per the sort data cache, used to
		 * increase the performance of the filtering in DataTables
		 *  @type array
		 *  @default null
		 *  @private
		 */
		&quot;_aFilterData&quot;: null,
	
		/**
		 * Filtering data cache. This is the same as the cell filtering cache, but
		 * in this case a string rather than an array. This is easily computed with
		 * a join on &#x60;_aFilterData&#x60;, but is provided as a cache so the join isn&#x27;t
		 * needed on every search (memory traded for performance)
		 *  @type array
		 *  @default null
		 *  @private
		 */
		&quot;_sFilterRow&quot;: null,
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;/i&gt;
		 *  @private
		 */
		&quot;_sRowStripe&quot;: &quot;&quot;,
	
		/**
		 * Denote if the original data source was from the DOM, or the data source
		 * object. This is used for invalidating data, so DataTables can
		 * automatically read data from the original source, unless uninstructed
		 * otherwise.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		&quot;src&quot;: null,
	
		/**
		 * Index in the aoData array. This saves an indexOf lookup when we have the
		 * object, but want to know the index
		 *  @type integer
		 *  @default -1
		 *  @private
		 */
		&quot;idx&quot;: -1
	};
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 *
	 * Note that this object is related to {@link DataTable.defaults.column}
	 * but this one is the internal data store for DataTables&#x27;s cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * Column index. This could be worked out on-the-fly with $.inArray, but it
		 * is faster to just hold it as a variable
		 *  @type integer
		 *  @default null
		 */
		&quot;idx&quot;: null,
	
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn&#x27;t need to be the case).
		 *  @type array
		 */
		&quot;aDataSort&quot;: null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		&quot;asSorting&quot;: null,
	
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		&quot;bSearchable&quot;: null,
	
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		&quot;bSortable&quot;: null,
	
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		&quot;bVisible&quot;: null,
	
		/**
		 * Store for manual type assignment using the &#x60;column.type&#x60; option. This
		 * is held in store so we can manipulate the column&#x27;s &#x60;sType&#x60; property.
		 *  @type string
		 *  @default null
		 *  @private
		 */
		&quot;_sManualType&quot;: null,
	
		/**
		 * Flag to indicate if HTML5 data attributes should be used as the data
		 * source for filtering or sorting. True is either are.
		 *  @type boolean
		 *  @default false
		 *  @private
		 */
		&quot;_bAttrSrc&quot;: false,
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		&quot;fnCreatedCell&quot;: null,
	
		/**
		 * Function to get data from a cell in a column. You should &lt;b&gt;never&lt;/b&gt;
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mData to function as
		 * required. This function is automatically assigned by the column
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get -
		 *    &#x27;display&#x27;, &#x27;type&#x27; &#x27;filter&#x27; &#x27;sort&#x27;
		 *  @returns {*} The data for the cell from the given row&#x27;s data
		 *  @default null
		 */
		&quot;fnGetData&quot;: null,
	
		/**
		 * Function to set data for a cell in the column. You should &lt;b&gt;never&lt;/b&gt;
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mData to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		&quot;fnSetData&quot;: null,
	
		/**
		 * Property to read the value for the cells in the column from the data
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		&quot;mData&quot;: null,
	
		/**
		 * Partner property to mData which is used (only when defined) to get
		 * the data - i.e. it is basically the same as mData, but without the
		 * &#x27;set&#x27; option, and also the data fed to it is the result from mData.
		 * This is the rendering method to match the data method of mData.
		 *  @type function|int|string|null
		 *  @default null
		 */
		&quot;mRender&quot;: null,
	
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		&quot;nTh&quot;: null,
	
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used
		 * in DataTables as such, but can be used for plug-ins to reference the
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		&quot;nTf&quot;: null,
	
		/**
		 * The class to apply to all TD elements in the table&#x27;s TBODY for the column
		 *  @type string
		 *  @default null
		 */
		&quot;sClass&quot;: null,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a &quot;work around&quot; we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		&quot;sContentPadding&quot;: null,
	
		/**
		 * Allows a default value to be given for a column&#x27;s data, and will be used
		 * whenever a null data source is encountered (this can be because mData
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		&quot;sDefaultContent&quot;: null,
	
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		&quot;sName&quot;: null,
	
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		&quot;sSortDataType&quot;: &#x27;std&#x27;,
	
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		&quot;sSortingClass&quot;: null,
	
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		&quot;sSortingClassJUI&quot;: null,
	
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		&quot;sTitle&quot;: null,
	
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		&quot;sType&quot;: null,
	
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		&quot;sWidth&quot;: null,
	
		/**
		 * Width of the column when it was first &quot;encountered&quot;
		 *  @type string
		 *  @default null
		 */
		&quot;sWidthOrig&quot;: null
	};
	
	
	/*
	 * Developer note: The properties of the object below are given in Hungarian
	 * notation, that was used as the interface for DataTables prior to v1.10, however
	 * from v1.10 onwards the primary interface is camel case. In order to avoid
	 * breaking backwards compatibility utterly with this change, the Hungarian
	 * version is still, internally the primary interface, but is is not documented
	 * - hence the @name tags in each doc comment. This allows a Javascript function
	 * to create a map from Hungarian notation to camel case (going the other direction
	 * would require each property to be listed, which would at around 3K to the size
	 * of DataTables, while this method is about a 0.5K hit.
	 *
	 * Ultimately this does pave the way for Hungarian notation to be dropped
	 * completely, but that is a massive amount of work and will break current
	 * installs (therefore is on-hold until v2).
	 */
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.data
		 *
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;data&quot;: [
		 *          [&#x27;Trident&#x27;, &#x27;Internet Explorer 4.0&#x27;, &#x27;Win 95+&#x27;, 4, &#x27;X&#x27;],
		 *          [&#x27;Trident&#x27;, &#x27;Internet Explorer 5.0&#x27;, &#x27;Win 95+&#x27;, 5, &#x27;C&#x27;],
		 *        ],
		 *        &quot;columns&quot;: [
		 *          { &quot;title&quot;: &quot;Engine&quot; },
		 *          { &quot;title&quot;: &quot;Browser&quot; },
		 *          { &quot;title&quot;: &quot;Platform&quot; },
		 *          { &quot;title&quot;: &quot;Version&quot; },
		 *          { &quot;title&quot;: &quot;Grade&quot; }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using an array of objects as a data source (&#x60;data&#x60;)
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;data&quot;: [
		 *          {
		 *            &quot;engine&quot;:   &quot;Trident&quot;,
		 *            &quot;browser&quot;:  &quot;Internet Explorer 4.0&quot;,
		 *            &quot;platform&quot;: &quot;Win 95+&quot;,
		 *            &quot;version&quot;:  4,
		 *            &quot;grade&quot;:    &quot;X&quot;
		 *          },
		 *          {
		 *            &quot;engine&quot;:   &quot;Trident&quot;,
		 *            &quot;browser&quot;:  &quot;Internet Explorer 5.0&quot;,
		 *            &quot;platform&quot;: &quot;Win 95+&quot;,
		 *            &quot;version&quot;:  5,
		 *            &quot;grade&quot;:    &quot;C&quot;
		 *          }
		 *        ],
		 *        &quot;columns&quot;: [
		 *          { &quot;title&quot;: &quot;Engine&quot;,   &quot;data&quot;: &quot;engine&quot; },
		 *          { &quot;title&quot;: &quot;Browser&quot;,  &quot;data&quot;: &quot;browser&quot; },
		 *          { &quot;title&quot;: &quot;Platform&quot;, &quot;data&quot;: &quot;platform&quot; },
		 *          { &quot;title&quot;: &quot;Version&quot;,  &quot;data&quot;: &quot;version&quot; },
		 *          { &quot;title&quot;: &quot;Grade&quot;,    &quot;data&quot;: &quot;grade&quot; }
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;aaData&quot;: null,
	
	
		/**
		 * If ordering is enabled, then DataTables will perform a first pass sort on
		 * initialisation. You can define which column(s) the sort is performed
		 * upon, and the sorting direction, with this variable. The &#x60;sorting&#x60; array
		 * should contain an array for each column to be sorted initially containing
		 * the column&#x27;s index and a direction string (&#x27;asc&#x27; or &#x27;desc&#x27;).
		 *  @type array
		 *  @default [[0,&#x27;asc&#x27;]]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.order
		 *
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;order&quot;: [[2,&#x27;asc&#x27;], [3,&#x27;desc&#x27;]]
		 *      } );
		 *    } );
		 *
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;order&quot;: []
		 *      } );
		 *    } );
		 */
		&quot;aaSorting&quot;: [[0,&#x27;asc&#x27;]],
	
	
		/**
		 * This parameter is basically identical to the &#x60;sorting&#x60; parameter, but
		 * cannot be overridden by user interaction with the table. What this means
		 * is that you could have a column (visible or hidden) which the sorting
		 * will always be forced on first - any sorting after that (from the user)
		 * will then be performed as required. This can be useful for grouping rows
		 * together.
		 *  @type array
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.orderFixed
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;orderFixed&quot;: [[0,&#x27;asc&#x27;]]
		 *      } );
		 *    } )
		 */
		&quot;aaSortingFixed&quot;: [],
	
	
		/**
		 * DataTables can be instructed to load data to display in the table from a
		 * Ajax source. This option defines how that Ajax call is made and where to.
		 *
		 * The &#x60;ajax&#x60; property has three different modes of operation, depending on
		 * how it is defined. These are:
		 *
		 * * &#x60;string&#x60; - Set the URL from where the data should be loaded from.
		 * * &#x60;object&#x60; - Define properties for &#x60;jQuery.ajax&#x60;.
		 * * &#x60;function&#x60; - Custom data get function
		 *
		 * &#x60;string&#x60;
		 * --------
		 *
		 * As a string, the &#x60;ajax&#x60; property simply defines the URL from which
		 * DataTables will load data.
		 *
		 * &#x60;object&#x60;
		 * --------
		 *
		 * As an object, the parameters in the object are passed to
		 * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
		 * of the Ajax request. DataTables has a number of default parameters which
		 * you can override using this option. Please refer to the jQuery
		 * documentation for a full description of the options available, although
		 * the following parameters provide additional options in DataTables or
		 * require special consideration:
		 *
		 * * &#x60;data&#x60; - As with jQuery, &#x60;data&#x60; can be provided as an object, but it
		 *   can also be used as a function to manipulate the data DataTables sends
		 *   to the server. The function takes a single parameter, an object of
		 *   parameters with the values that DataTables has readied for sending. An
		 *   object may be returned which will be merged into the DataTables
		 *   defaults, or you can add the items to the object that was passed in and
		 *   not return anything from the function. This supersedes &#x60;fnServerParams&#x60;
		 *   from DataTables 1.9-.
		 *
		 * * &#x60;dataSrc&#x60; - By default DataTables will look for the property &#x60;data&#x60; (or
		 *   &#x60;aaData&#x60; for compatibility with DataTables 1.9-) when obtaining data
		 *   from an Ajax source or for server-side processing - this parameter
		 *   allows that property to be changed. You can use Javascript dotted
		 *   object notation to get a data source for multiple levels of nesting, or
		 *   it my be used as a function. As a function it takes a single parameter,
		 *   the JSON returned from the server, which can be manipulated as
		 *   required, with the returned value being that used by DataTables as the
		 *   data source for the table. This supersedes &#x60;sAjaxDataProp&#x60; from
		 *   DataTables 1.9-.
		 *
		 * * &#x60;success&#x60; - Should not be overridden it is used internally in
		 *   DataTables. To manipulate / transform the data returned by the server
		 *   use &#x60;ajax.dataSrc&#x60;, or use &#x60;ajax&#x60; as a function (see below).
		 *
		 * &#x60;function&#x60;
		 * ----------
		 *
		 * As a function, making the Ajax call is left up to yourself allowing
		 * complete control of the Ajax request. Indeed, if desired, a method other
		 * than Ajax could be used to obtain the required data, such as Web storage
		 * or an AIR database.
		 *
		 * The function is given four parameters and no return is required. The
		 * parameters are:
		 *
		 * 1. _object_ - Data to send to the server
		 * 2. _function_ - Callback function that must be executed when the required
		 *    data has been obtained. That data should be passed into the callback
		 *    as the only parameter
		 * 3. _object_ - DataTables settings object for the table
		 *
		 * Note that this supersedes &#x60;fnServerData&#x60; from DataTables 1.9-.
		 *
		 *  @type string|object|function
		 *  @default null
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.ajax
		 *  @since 1.10.0
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax.
		 *   // Note DataTables expects data in the form &#x60;{ data: [ ...data... ] }&#x60; by default).
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: &quot;data.json&quot;
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using &#x60;dataSrc&#x60; to change
		 *   // &#x60;data&#x60; to &#x60;tableData&#x60; (i.e. &#x60;{ tableData: [ ...data... ] }&#x60;)
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: {
		 *       &quot;url&quot;: &quot;data.json&quot;,
		 *       &quot;dataSrc&quot;: &quot;tableData&quot;
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get JSON data from a file via Ajax, using &#x60;dataSrc&#x60; to read data
		 *   // from a plain array rather than an array in an object
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: {
		 *       &quot;url&quot;: &quot;data.json&quot;,
		 *       &quot;dataSrc&quot;: &quot;&quot;
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Manipulate the data returned from the server - add a link to data
		 *   // (note this can, should, be done using &#x60;render&#x60; for the column - this
		 *   // is just a simple example of how the data can be manipulated).
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: {
		 *       &quot;url&quot;: &quot;data.json&quot;,
		 *       &quot;dataSrc&quot;: function ( json ) {
		 *         for ( var i=0, ien=json.length ; i&lt;ien ; i++ ) {
		 *           json[i][0] = &#x27;&lt;a href=&quot;/message/&#x27;+json[i][0]+&#x27;&gt;View message&lt;/a&gt;&#x27;;
		 *         }
		 *         return json;
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Add data to the request
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: {
		 *       &quot;url&quot;: &quot;data.json&quot;,
		 *       &quot;data&quot;: function ( d ) {
		 *         return {
		 *           &quot;extra_search&quot;: $(&#x27;#extra&#x27;).val()
		 *         };
		 *       }
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Send request as POST
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: {
		 *       &quot;url&quot;: &quot;data.json&quot;,
		 *       &quot;type&quot;: &quot;POST&quot;
		 *     }
		 *   } );
		 *
		 * @example
		 *   // Get the data from localStorage (could interface with a form for
		 *   // adding, editing and removing rows).
		 *   $(&#x27;#example&#x27;).dataTable( {
		 *     &quot;ajax&quot;: function (data, callback, settings) {
		 *       callback(
		 *         JSON.parse( localStorage.getItem(&#x27;dataTablesData&#x27;) )
		 *       );
		 *     }
		 *   } );
		 */
		&quot;ajax&quot;: null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be
		 * either a 1D array of options which will be used for both the displayed
		 * option and the value, or a 2D array which will use the array in the first
		 * position as the value, and the array in the second position as the
		 * displayed options (useful for language strings such as &#x27;All&#x27;).
		 *
		 * Note that the &#x60;pageLength&#x60; property will be automatically set to the
		 * first value given in this array, unless &#x60;pageLength&#x60; is also provided.
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.lengthMenu
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;lengthMenu&quot;: [[10, 25, 50, -1], [10, 25, 50, &quot;All&quot;]]
		 *      } );
		 *    } );
		 */
		&quot;aLengthMenu&quot;: [ 10, 25, 50, 100 ],
	
	
		/**
		 * The &#x60;columns&#x60; option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see
		 * {@link DataTable.defaults.column}. Note that if you use &#x60;columns&#x60; to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don&#x27;t which
		 * to specify any options).
		 *  @member
		 *
		 *  @name DataTable.defaults.column
		 */
		&quot;aoColumns&quot;: null,
	
		/**
		 * Very similar to &#x60;columns&#x60;, &#x60;columnDefs&#x60; allows you to target a specific
		 * column, multiple columns, or all columns, using the &#x60;targets&#x60; property of
		 * each object in the array. This allows great flexibility when creating
		 * tables, as the &#x60;columnDefs&#x60; arrays can be of any length, targeting the
		 * columns you specifically want. &#x60;columnDefs&#x60; may use any of the column
		 * options available: {@link DataTable.defaults.column}, but it _must_
		 * have &#x60;targets&#x60; defined in each object in the array. Values in the &#x60;targets&#x60;
		 * array may be:
		 *   &lt;ul&gt;
		 *     &lt;li&gt;a string - class name will be matched on the TH for the column&lt;/li&gt;
		 *     &lt;li&gt;0 or a positive integer - column index counting from the left&lt;/li&gt;
		 *     &lt;li&gt;a negative integer - column index counting from the right&lt;/li&gt;
		 *     &lt;li&gt;the string &quot;_all&quot; - all columns (i.e. assign a default)&lt;/li&gt;
		 *   &lt;/ul&gt;
		 *  @member
		 *
		 *  @name DataTable.defaults.columnDefs
		 */
		&quot;aoColumnDefs&quot;: null,
	
	
		/**
		 * Basically the same as &#x60;search&#x60;, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size
		 * as the number of columns, and each element be an object with the parameters
		 * &#x60;search&#x60; and &#x60;escapeRegex&#x60; (the latter is optional). &#x27;null&#x27; is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.searchCols
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;searchCols&quot;: [
		 *          null,
		 *          { &quot;search&quot;: &quot;My filter&quot; },
		 *          null,
		 *          { &quot;search&quot;: &quot;^[0-9]&quot;, &quot;escapeRegex&quot;: false }
		 *        ]
		 *      } );
		 *    } )
		 */
		&quot;aoSearchCols&quot;: [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This
		 * array may be of any length, and DataTables will apply each class
		 * sequentially, looping when required.
		 *  @type array
		 *  @default null &lt;i&gt;Will take the values determined by the &#x60;oClasses.stripe*&#x60;
		 *    options&lt;/i&gt;
		 *
		 *  @dtopt Option
		 *  @name DataTable.defaults.stripeClasses
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stripeClasses&quot;: [ &#x27;strip1&#x27;, &#x27;strip2&#x27;, &#x27;strip3&#x27; ]
		 *      } );
		 *    } )
		 */
		&quot;asStripeClasses&quot;: null,
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using &#x60;columns&#x60;.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.autoWidth
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;autoWidth&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bAutoWidth&quot;: true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.deferRender
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;ajax&quot;: &quot;sources/arrays.txt&quot;,
		 *        &quot;deferRender&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bDeferRender&quot;: false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.destroy
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;srollY&quot;: &quot;200px&quot;,
		 *        &quot;paginate&quot;: false
		 *      } );
		 *
		 *      // Some time later....
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;filter&quot;: false,
		 *        &quot;destroy&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bDestroy&quot;: false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is &quot;smart&quot; in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain &#x27;true&#x27; - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * {@link DataTable.defaults.dom}.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.searching
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;searching&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bFilter&quot;: true,
	
	
		/**
		 * Enable or disable the table information display. This shows information
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.info
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;info&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bInfo&quot;: true,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (&#x60;paginate&#x60;).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.lengthChange
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;lengthChange&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bLengthChange&quot;: true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.paging
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;paging&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bPaginate&quot;: true,
	
	
		/**
		 * Enable or disable the display of a &#x27;processing&#x27; indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.processing
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;processing&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bProcessing&quot;: false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). &#x60;destroy&#x60; can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.retrieve
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *
		 *    function initTable ()
		 *    {
		 *      return $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;scrollY&quot;: &quot;200px&quot;,
		 *        &quot;paginate&quot;: false,
		 *        &quot;retrieve&quot;: true
		 *      } );
		 *    }
		 *
		 *    function tableActions ()
		 *    {
		 *      var table = initTable();
		 *      // perform API operations with oTable
		 *    }
		 */
		&quot;bRetrieve&quot;: false,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table&#x27;s viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left &quot;floating&quot; further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table&#x27;s viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollCollapse
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;scrollY&quot;: &quot;200&quot;,
		 *        &quot;scrollCollapse&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bScrollCollapse&quot;: false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * &#x60;ajax&#x60; parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverSide
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;serverSide&quot;: true,
		 *        &quot;ajax&quot;: &quot;xhr.php&quot;
		 *      } );
		 *    } );
		 */
		&quot;bServerSide&quot;: false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the &#x60;sortable&#x60; option for each column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.ordering
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;ordering&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bSort&quot;: true,
	
	
		/**
		 * Enable or display DataTables&#x27; ability to sort multiple columns at the
		 * same time (activated by shift-click by the user).
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderMulti
		 *
		 *  @example
		 *    // Disable multiple column sorting ability
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;orderMulti&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bSortMulti&quot;: true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.orderCellsTop
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;orderCellsTop&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bSortCellsTop&quot;: false,
	
	
		/**
		 * Enable or disable the addition of the classes &#x60;sorting\_1&#x60;, &#x60;sorting\_2&#x60; and
		 * &#x60;sorting\_3&#x60; to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.orderClasses
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;orderClasses&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;bSortClasses&quot;: true,
	
	
		/**
		 * Enable or disable state saving. When enabled HTML5 &#x60;localStorage&#x60; will be
		 * used to save table display information such as pagination information,
		 * display length, filtering and sorting. As such when the end user reloads
		 * the page the display display will match what thy had previously set up.
		 *
		 * Due to the use of &#x60;localStorage&#x60; the default state saving is not supported
		 * in IE6 or 7. If state saving is required in those browsers, use
		 * &#x60;stateSaveCallback&#x60; to provide a storage solution such as cookies.
		 *  @type boolean
		 *  @default false
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.stateSave
		 *
		 *  @example
		 *    $(document).ready( function () {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;bStateSave&quot;: false,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} row &quot;TR&quot; element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} dataIndex The index of this row in the internal aoData array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.createdRow
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;createdRow&quot;: function( row, data, dataIndex ) {
		 *          // Bold the grade for all &#x27;A&#x27; grade browsers
		 *          if ( data[4] == &quot;A&quot; )
		 *          {
		 *            $(&#x27;td:eq(4)&#x27;, row).html( &#x27;&lt;b&gt;A&lt;/b&gt;&#x27; );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnCreatedRow&quot;: null,
	
	
		/**
		 * This function is called on every &#x27;draw&#x27; event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.drawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;drawCallback&quot;: function( settings ) {
		 *          alert( &#x27;DataTables has redrawn the table&#x27; );
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnDrawCallback&quot;: null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every &#x27;draw&#x27; event.
		 *  @type function
		 *  @param {node} foot &quot;TR&quot; element for the footer
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.footerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;footerCallback&quot;: function( tfoot, data, start, end, display ) {
		 *          tfoot.getElementsByTagName(&#x27;th&#x27;)[0].innerHTML = &quot;Starting index is &quot;+start;
		 *        }
		 *      } );
		 *    } )
		 */
		&quot;fnFooterCallback&quot;: null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. &quot;Showing 1 to 10 of 57 entries&quot;) DataTables will render large numbers
		 * to have a comma separator for the &#x27;thousands&#x27; units (e.g. 1 million is
		 * rendered as &quot;1,000,000&quot;) to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} toFormat number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.formatNumber
		 *
		 *  @example
		 *    // Format a number using a single quote for the separator (note that
		 *    // this can also be done with the language.thousands option)
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;formatNumber&quot;: function ( toFormat ) {
		 *          return toFormat.toString().replace(
		 *            /\B(?=(\d{3})+(?!\d))/g, &quot;&#x27;&quot;
		 *          );
		 *        };
		 *      } );
		 *    } );
		 */
		&quot;fnFormatNumber&quot;: function ( toFormat ) {
			return toFormat.toString().replace(
				/\B(?=(\d{3})+(?!\d))/g,
				this.oLanguage.sThousands
			);
		},
	
	
		/**
		 * This function is called on every &#x27;draw&#x27; event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} head &quot;TR&quot; element for the header
		 *  @param {array} data Full table data (as derived from the original HTML)
		 *  @param {int} start Index for the current display starting point in the
		 *    display array
		 *  @param {int} end Index for the current display ending point in the
		 *    display array
		 *  @param {array int} display Index array to translate the visual position
		 *    to the full data array
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.headerCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;fheaderCallback&quot;: function( head, data, start, end, display ) {
		 *          head.getElementsByTagName(&#x27;th&#x27;)[0].innerHTML = &quot;Displaying &quot;+(end-start)+&quot; records&quot;;
		 *        }
		 *      } );
		 *    } )
		 */
		&quot;fnHeaderCallback&quot;: null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} start Starting position in data for the draw
		 *  @param {int} end End position in data for the draw
		 *  @param {int} max Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} total Total number of rows in the data set, after filtering
		 *  @param {string} pre The string that DataTables has formatted using it&#x27;s
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.infoCallback
		 *
		 *  @example
		 *    $(&#x27;#example&#x27;).dataTable( {
		 *      &quot;infoCallback&quot;: function( settings, start, end, max, total, pre ) {
		 *        return start +&quot; to &quot;+ end;
		 *      }
		 *    } );
		 */
		&quot;fnInfoCallback&quot;: null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.initComplete
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;initComplete&quot;: function(settings, json) {
		 *          alert( &#x27;DataTables has finished its initialisation.&#x27; );
		 *        }
		 *      } );
		 *    } )
		 */
		&quot;fnInitComplete&quot;: null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.preDrawCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;preDrawCallback&quot;: function( settings ) {
		 *          if ( $(&#x27;#test&#x27;).val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnPreDrawCallback&quot;: null,
	
	
		/**
		 * This function allows you to &#x27;post process&#x27; each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} row &quot;TR&quot; element for the current row
		 *  @param {array} data Raw data array for this row
		 *  @param {int} displayIndex The display index for the current table draw
		 *  @param {int} displayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.rowCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;rowCallback&quot;: function( row, data, displayIndex, displayIndexFull ) {
		 *          // Bold the grade for all &#x27;A&#x27; grade browsers
		 *          if ( data[4] == &quot;A&quot; ) {
		 *            $(&#x27;td:eq(4)&#x27;, row).html( &#x27;&lt;b&gt;A&lt;/b&gt;&#x27; );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnRowCallback&quot;: null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through &#x60;ajax&#x60;, which should be used instead.
		 *
		 * This parameter allows you to override the default function which obtains
		 * the data from the server so something more suitable for your application.
		 * For example you could use POST data, or pull information from a Gears or
		 * AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} source HTTP source to obtain the data from (&#x60;ajax&#x60;)
		 *  @param {array} data A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} callback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} settings DataTables settings object
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverData
		 *
		 *  @deprecated 1.10. Please use &#x60;ajax&#x60; for this functionality now.
		 */
		&quot;fnServerData&quot;: null,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through &#x60;ajax&#x60;, which should be used instead.
		 *
		 *  It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} data Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the data array passed in,
		 *    as this is passed by reference.
		 *
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverParams
		 *
		 *  @deprecated 1.10. Please use &#x60;ajax&#x60; for this functionality now.
		 */
		&quot;fnServerParams&quot;: null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from &#x60;localStorage&#x60;
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} callback Callback that can be executed when done. It
		 *    should be passed the loaded state object.
		 *  @return {object} The DataTables state object to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateLoadCallback&quot;: function (settings, callback) {
		 *          $.ajax( {
		 *            &quot;url&quot;: &quot;/state_load&quot;,
		 *            &quot;dataType&quot;: &quot;json&quot;,
		 *            &quot;success&quot;: function (json) {
		 *              callback( json );
		 *            }
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnStateLoadCallback&quot;: function ( settings ) {
			try {
				return JSON.parse(
					(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
						&#x27;DataTables_&#x27;+settings.sInstance+&#x27;_&#x27;+location.pathname
					)
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for
		 * plug-in authors, you should use the &#x60;stateLoadParams&#x60; event to load parameters for
		 * a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that is to be loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoadParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateLoadParams&quot;: function (settings, data) {
		 *          data.oSearch.sSearch = &quot;&quot;;
		 *        }
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateLoadParams&quot;: function (settings, data) {
		 *          return false;
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnStateLoadParams&quot;: null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object that was loaded
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateLoaded
		 *
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateLoaded&quot;: function (settings, data) {
		 *          alert( &#x27;Saved filter was: &#x27;+data.oSearch.sSearch );
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnStateLoaded&quot;: null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored By default DataTables will use &#x60;localStorage&#x60;
		 * but you might wish to use a server-side database or cookies.
		 *  @type function
		 *  @member
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveCallback
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateSaveCallback&quot;: function (settings, data) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            &quot;url&quot;: &quot;/state_save&quot;,
		 *            &quot;data&quot;: data,
		 *            &quot;dataType&quot;: &quot;json&quot;,
		 *            &quot;method&quot;: &quot;POST&quot;
		 *            &quot;success&quot;: function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnStateSaveCallback&quot;: function ( settings, data ) {
			try {
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
					&#x27;DataTables_&#x27;+settings.sInstance+&#x27;_&#x27;+location.pathname,
					JSON.stringify( data )
				);
			} catch (e) {}
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or
		 * other state properties or modification. Note that for plug-in authors, you should
		 * use the &#x60;stateSaveParams&#x60; event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} settings DataTables settings object
		 *  @param {object} data The state object to be saved
		 *
		 *  @dtopt Callbacks
		 *  @name DataTable.defaults.stateSaveParams
		 *
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateSave&quot;: true,
		 *        &quot;stateSaveParams&quot;: function (settings, data) {
		 *          data.oSearch.sSearch = &quot;&quot;;
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;fnStateSaveParams&quot;: null,
	
	
		/**
		 * Duration for which the saved state information is considered valid. After this period
		 * has elapsed the state will be returned to the default.
		 * Value is given in seconds.
		 *  @type int
		 *  @default 7200 &lt;i&gt;(2 hours)&lt;/i&gt;
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.stateDuration
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;stateDuration&quot;: 60*60*24; // 1 day
		 *      } );
		 *    } )
		 */
		&quot;iStateDuration&quot;: 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. &#x60;deferLoading&#x60;
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly). In the case
		 * where a filtering is applied to the table on initial load, this can be
		 * indicated by giving the parameter as an array, where the first element is
		 * the number of records available after filtering and the second element is the
		 * number of records without filtering (allowing the table information element
		 * to be shown correctly).
		 *  @type int | array
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.deferLoading
		 *
		 *  @example
		 *    // 57 records available in the table, no filtering applied
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;serverSide&quot;: true,
		 *        &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
		 *        &quot;deferLoading&quot;: 57
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // 57 records after filtering, 100 without filtering (an initial filter applied)
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;serverSide&quot;: true,
		 *        &quot;ajax&quot;: &quot;scripts/server_processing.php&quot;,
		 *        &quot;deferLoading&quot;: [ 57, 100 ],
		 *        &quot;search&quot;: {
		 *          &quot;search&quot;: &quot;my_filter&quot;
		 *        }
		 *      } );
		 *    } );
		 */
		&quot;iDeferLoading&quot;: null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (&#x60;lengthChange&#x60;) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pageLength
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;pageLength&quot;: 50
		 *      } );
		 *    } )
		 */
		&quot;iDisplayLength&quot;: 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be &quot;20&quot;.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.displayStart
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;displayStart&quot;: 20
		 *      } );
		 *    } )
		 */
		&quot;iDisplayStart&quot;: 0,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a &#x60;tabindex&#x60; attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.tabIndex
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;tabIndex&quot;: 1
		 *      } );
		 *    } );
		 */
		&quot;iTabIndex&quot;: 0,
	
	
		/**
		 * Classes that DataTables assigns to the various components and features
		 * that it adds to the HTML table. This allows classes to be configured
		 * during initialisation in addition to through the static
		 * {@link DataTable.ext.oStdClasses} object).
		 *  @namespace
		 *  @name DataTable.defaults.classes
		 */
		&quot;oClasses&quot;: {},
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 *  @name DataTable.defaults.language
		 */
		&quot;oLanguage&quot;: {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 *  @name DataTable.defaults.language.aria
			 */
			&quot;oAria&quot;: {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortAscending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;aria&quot;: {
				 *            &quot;sortAscending&quot;: &quot; - click/return to sort ascending&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sSortAscending&quot;: &quot;: activate to sort column ascending&quot;,
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.aria.sortDescending
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;aria&quot;: {
				 *            &quot;sortDescending&quot;: &quot; - click/return to sort descending&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sSortDescending&quot;: &quot;: activate to sort column descending&quot;
			},
	
			/**
			 * Pagination string used by DataTables for the built-in pagination
			 * control types.
			 *  @namespace
			 *  @name DataTable.defaults.language.paginate
			 */
			&quot;oPaginate&quot;: {
				/**
				 * Text to use when using the &#x27;full_numbers&#x27; type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.first
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;paginate&quot;: {
				 *            &quot;first&quot;: &quot;First page&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sFirst&quot;: &quot;First&quot;,
	
	
				/**
				 * Text to use when using the &#x27;full_numbers&#x27; type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.last
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;paginate&quot;: {
				 *            &quot;last&quot;: &quot;Last page&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sLast&quot;: &quot;Last&quot;,
	
	
				/**
				 * Text to use for the &#x27;next&#x27; pagination button (to take the user to the
				 * next page).
				 *  @type string
				 *  @default Next
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.next
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;paginate&quot;: {
				 *            &quot;next&quot;: &quot;Next page&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sNext&quot;: &quot;Next&quot;,
	
	
				/**
				 * Text to use for the &#x27;previous&#x27; pagination button (to take the user to
				 * the previous page).
				 *  @type string
				 *  @default Previous
				 *
				 *  @dtopt Language
				 *  @name DataTable.defaults.language.paginate.previous
				 *
				 *  @example
				 *    $(document).ready( function() {
				 *      $(&#x27;#example&#x27;).dataTable( {
				 *        &quot;language&quot;: {
				 *          &quot;paginate&quot;: {
				 *            &quot;previous&quot;: &quot;Previous page&quot;
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				&quot;sPrevious&quot;: &quot;Previous&quot;
			},
	
			/**
			 * This string is shown in preference to &#x60;zeroRecords&#x60; when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of &#x60;zeroRecords&#x60; will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.emptyTable
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;emptyTable&quot;: &quot;No data available in table&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sEmptyTable&quot;: &quot;No data available in table&quot;,
	
	
			/**
			 * This string gives information to the end user about the information
			 * that is current on display on the page. The following tokens can be
			 * used in the string and will be dynamically replaced as the table
			 * display updates. This tokens can be placed anywhere in the string, or
			 * removed as needed by the language requires:
			 *
			 * * &#x60;\_START\_&#x60; - Display index of the first record on the current page
			 * * &#x60;\_END\_&#x60; - Display index of the last record on the current page
			 * * &#x60;\_TOTAL\_&#x60; - Number of records in the table after filtering
			 * * &#x60;\_MAX\_&#x60; - Number of records in the table without filtering
			 * * &#x60;\_PAGE\_&#x60; - Current page number
			 * * &#x60;\_PAGES\_&#x60; - Total number of pages of data in the table
			 *
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.info
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;info&quot;: &quot;Showing page _PAGE_ of _PAGES_&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sInfo&quot;: &quot;Showing _START_ to _END_ of _TOTAL_ entries&quot;,
	
	
			/**
			 * Display information string for when the table is empty. Typically the
			 * format of this string should match &#x60;info&#x60;.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoEmpty
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;infoEmpty&quot;: &quot;No entries to show&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sInfoEmpty&quot;: &quot;Showing 0 to 0 of 0 entries&quot;,
	
	
			/**
			 * When a user filters the information in a table, this string is appended
			 * to the information (&#x60;info&#x60;) to give an idea of how strong the filtering
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoFiltered
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;infoFiltered&quot;: &quot; - filtering from _MAX_ records&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sInfoFiltered&quot;: &quot;(filtered from _MAX_ total entries)&quot;,
	
	
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the &#x60;info&#x60; (&#x60;infoEmpty&#x60; and &#x60;infoFiltered&#x60; in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default &lt;i&gt;Empty string&lt;/i&gt;
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.infoPostFix
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;infoPostFix&quot;: &quot;All records shown are derived from real information.&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sInfoPostFix&quot;: &quot;&quot;,
	
	
			/**
			 * This decimal place operator is a little different from the other
			 * language options since DataTables doesn&#x27;t output floating point
			 * numbers, so it won&#x27;t ever use this for display of a number. Rather,
			 * what this parameter does is modify the sort methods of the table so
			 * that numbers which are in a format which has a character other than
			 * a period (&#x60;.&#x60;) as a decimal place will be sorted numerically.
			 *
			 * Note that numbers with different decimal places cannot be shown in
			 * the same table and still be sortable, the table must be consistent.
			 * However, multiple different tables on the page can use different
			 * decimal place characters.
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.decimal
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;decimal&quot;: &quot;,&quot;
			 *          &quot;thousands&quot;: &quot;.&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sDecimal&quot;: &quot;&quot;,
	
	
			/**
			 * DataTables has a build in number formatter (&#x60;formatNumber&#x60;) which is
			 * used to format large numbers that are used in the table information.
			 * By default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.thousands
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;thousands&quot;: &quot;&#x27;&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sThousands&quot;: &quot;,&quot;,
	
	
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The &#x27;_MENU_&#x27; variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.lengthMenu
			 *
			 *  @example
			 *    // Language change only
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;lengthMenu&quot;: &quot;Display _MENU_ records&quot;
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Language and options change
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;lengthMenu&quot;: &#x27;Display &lt;select&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;10&quot;&gt;10&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;20&quot;&gt;20&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;30&quot;&gt;30&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;40&quot;&gt;40&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;50&quot;&gt;50&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;option value=&quot;-1&quot;&gt;All&lt;/option&gt;&#x27;+
			 *            &#x27;&lt;/select&gt; records&#x27;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sLengthMenu&quot;: &quot;Show _MENU_ entries&quot;,
	
	
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.loadingRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;loadingRecords&quot;: &quot;Please wait - loading...&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sLoadingRecords&quot;: &quot;Loading...&quot;,
	
	
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.processing
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;processing&quot;: &quot;DataTables is currently busy&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sProcessing&quot;: &quot;Processing...&quot;,
	
	
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable &quot;_INPUT_&quot;, if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If &quot;_INPUT_&quot; is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.search
			 *
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;search&quot;: &quot;Filter records:&quot;
			 *        }
			 *      } );
			 *    } );
			 *
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;search&quot;: &quot;Apply filter _INPUT_ to table&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sSearch&quot;: &quot;Search:&quot;,
	
	
			/**
			 * Assign a &#x60;placeholder&#x60; attribute to the search &#x60;input&#x60; element
			 *  @type string
			 *  @default 
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.searchPlaceholder
			 */
			&quot;sSearchPlaceholder&quot;: &quot;&quot;,
	
	
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default &lt;i&gt;Empty string - i.e. disabled&lt;/i&gt;
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.url
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;url&quot;: &quot;http://www.sprymedia.co.uk/dataTables/lang.txt&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sUrl&quot;: &quot;&quot;,
	
	
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. &#x60;emptyTable&#x60; is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *
			 *  @dtopt Language
			 *  @name DataTable.defaults.language.zeroRecords
			 *
			 *  @example
			 *    $(document).ready( function() {
			 *      $(&#x27;#example&#x27;).dataTable( {
			 *        &quot;language&quot;: {
			 *          &quot;zeroRecords&quot;: &quot;No records to display&quot;
			 *        }
			 *      } );
			 *    } );
			 */
			&quot;sZeroRecords&quot;: &quot;No matching records found&quot;
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the &#x60;search&#x60; parameter must be
		 * defined, but all other parameters are optional. When &#x60;regex&#x60; is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When &#x60;smart&#x60;
		 * DataTables will use it&#x27;s smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.search
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;search&quot;: {&quot;search&quot;: &quot;Initial search&quot;}
		 *      } );
		 *    } )
		 */
		&quot;oSearch&quot;: $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through &#x60;ajax&#x60;, which should be used instead.
		 *
		 * By default DataTables will look for the property &#x60;data&#x60; (or &#x60;aaData&#x60; for
		 * compatibility with DataTables 1.9-) when obtaining data from an Ajax
		 * source or for server-side processing - this parameter allows that
		 * property to be changed. You can use Javascript dotted object notation to
		 * get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default data
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxDataProp
		 *
		 *  @deprecated 1.10. Please use &#x60;ajax&#x60; for this functionality now.
		 */
		&quot;sAjaxDataProp&quot;: &quot;data&quot;,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through &#x60;ajax&#x60;, which should be used instead.
		 *
		 * You can instruct DataTables to load data from an external
		 * source using this parameter (use aData if you want to pass data in you
		 * already have). Simply provide a url a JSON object can be obtained from.
		 *  @type string
		 *  @default null
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.ajaxSource
		 *
		 *  @deprecated 1.10. Please use &#x60;ajax&#x60; for this functionality now.
		 */
		&quot;sAjaxSource&quot;: null,
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   &lt;ul&gt;
		 *     &lt;li&gt;The following options are allowed:
		 *       &lt;ul&gt;
		 *         &lt;li&gt;&#x27;l&#x27; - Length changing&lt;/li&gt;
		 *         &lt;li&gt;&#x27;f&#x27; - Filtering input&lt;/li&gt;
		 *         &lt;li&gt;&#x27;t&#x27; - The table!&lt;/li&gt;
		 *         &lt;li&gt;&#x27;i&#x27; - Information&lt;/li&gt;
		 *         &lt;li&gt;&#x27;p&#x27; - Pagination&lt;/li&gt;
		 *         &lt;li&gt;&#x27;r&#x27; - pRocessing&lt;/li&gt;
		 *       &lt;/ul&gt;
		 *     &lt;/li&gt;
		 *     &lt;li&gt;The following constants are allowed:
		 *       &lt;ul&gt;
		 *         &lt;li&gt;&#x27;H&#x27; - jQueryUI theme &quot;header&quot; classes (&#x27;fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix&#x27;)&lt;/li&gt;
		 *         &lt;li&gt;&#x27;F&#x27; - jQueryUI theme &quot;footer&quot; classes (&#x27;fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix&#x27;)&lt;/li&gt;
		 *       &lt;/ul&gt;
		 *     &lt;/li&gt;
		 *     &lt;li&gt;The following syntax is expected:
		 *       &lt;ul&gt;
		 *         &lt;li&gt;&#x27;&amp;lt;&#x27; and &#x27;&amp;gt;&#x27; - div elements&lt;/li&gt;
		 *         &lt;li&gt;&#x27;&amp;lt;&quot;class&quot; and &#x27;&amp;gt;&#x27; - div with a class&lt;/li&gt;
		 *         &lt;li&gt;&#x27;&amp;lt;&quot;#id&quot; and &#x27;&amp;gt;&#x27; - div with an ID&lt;/li&gt;
		 *       &lt;/ul&gt;
		 *     &lt;/li&gt;
		 *     &lt;li&gt;Examples:
		 *       &lt;ul&gt;
		 *         &lt;li&gt;&#x27;&amp;lt;&quot;wrapper&quot;flipt&amp;gt;&#x27;&lt;/li&gt;
		 *         &lt;li&gt;&#x27;&amp;lt;lf&amp;lt;t&amp;gt;ip&amp;gt;&#x27;&lt;/li&gt;
		 *       &lt;/ul&gt;
		 *     &lt;/li&gt;
		 *   &lt;/ul&gt;
		 *  @type string
		 *  @default lfrtip &lt;i&gt;(when &#x60;jQueryUI&#x60; is false)&lt;/i&gt; &lt;b&gt;or&lt;/b&gt;
		 *    &lt;&quot;H&quot;lfr&gt;t&lt;&quot;F&quot;ip&gt; &lt;i&gt;(when &#x60;jQueryUI&#x60; is true)&lt;/i&gt;
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.dom
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;dom&quot;: &#x27;&amp;lt;&quot;top&quot;i&amp;gt;rt&amp;lt;&quot;bottom&quot;flp&amp;gt;&amp;lt;&quot;clear&quot;&amp;gt;&#x27;
		 *      } );
		 *    } );
		 */
		&quot;sDom&quot;: &quot;lfrtip&quot;,
	
	
		/**
		 * Search delay option. This will throttle full table searches that use the
		 * DataTables provided search input element (it does not effect calls to
		 * &#x60;dt-api search()&#x60;, providing a delay before the search is made.
		 *  @type integer
		 *  @default 0
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.searchDelay
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;searchDelay&quot;: 200
		 *      } );
		 *    } )
		 */
		&quot;searchDelay&quot;: null,
	
	
		/**
		 * DataTables features six different built-in options for the buttons to
		 * display for pagination control:
		 *
		 * * &#x60;numbers&#x60; - Page number buttons only
		 * * &#x60;simple&#x60; - &#x27;Previous&#x27; and &#x27;Next&#x27; buttons only
		 * * &#x27;simple_numbers&#x60; - &#x27;Previous&#x27; and &#x27;Next&#x27; buttons, plus page numbers
		 * * &#x60;full&#x60; - &#x27;First&#x27;, &#x27;Previous&#x27;, &#x27;Next&#x27; and &#x27;Last&#x27; buttons
		 * * &#x60;full_numbers&#x60; - &#x27;First&#x27;, &#x27;Previous&#x27;, &#x27;Next&#x27; and &#x27;Last&#x27; buttons, plus page numbers
		 * * &#x60;first_last_numbers&#x60; - &#x27;First&#x27; and &#x27;Last&#x27; buttons, plus page numbers
		 *  
		 * Further methods can be added using {@link DataTable.ext.oPagination}.
		 *  @type string
		 *  @default simple_numbers
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.pagingType
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;pagingType&quot;: &quot;full_numbers&quot;
		 *      } );
		 *    } )
		 */
		&quot;sPaginationType&quot;: &quot;simple_numbers&quot;,
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a
		 * certain layout, or you have a large number of columns in the table, you
		 * can enable x-scrolling to show the table in a viewport, which can be
		 * scrolled. This property can be &#x60;true&#x60; which will allow the table to
		 * scroll horizontally when needed, or any CSS unit, or a number (in which
		 * case it will be treated as a pixel measurement). Setting as simply &#x60;true&#x60;
		 * is recommended.
		 *  @type boolean|string
		 *  @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollX
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;scrollX&quot;: true,
		 *        &quot;scrollCollapse&quot;: true
		 *      } );
		 *    } );
		 */
		&quot;sScrollX&quot;: &quot;&quot;,
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * &quot;over-sizing&quot; the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;
		 *
		 *  @dtopt Options
		 *  @name DataTable.defaults.scrollXInner
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;scrollX&quot;: &quot;100%&quot;,
		 *        &quot;scrollXInner&quot;: &quot;110%&quot;
		 *      } );
		 *    } );
		 */
		&quot;sScrollXInner&quot;: &quot;&quot;,
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, and enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can be any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default &lt;i&gt;blank string - i.e. disabled&lt;/i&gt;
		 *
		 *  @dtopt Features
		 *  @name DataTable.defaults.scrollY
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;scrollY&quot;: &quot;200px&quot;,
		 *        &quot;paginate&quot;: false
		 *      } );
		 *    } );
		 */
		&quot;sScrollY&quot;: &quot;&quot;,
	
	
		/**
		 * __Deprecated__ The functionality provided by this parameter has now been
		 * superseded by that provided through &#x60;ajax&#x60;, which should be used instead.
		 *
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *
		 *  @dtopt Options
		 *  @dtopt Server-side
		 *  @name DataTable.defaults.serverMethod
		 *
		 *  @deprecated 1.10. Please use &#x60;ajax&#x60; for this functionality now.
		 */
		&quot;sServerMethod&quot;: &quot;GET&quot;,
	
	
		/**
		 * DataTables makes use of renderers when displaying HTML elements for
		 * a table. These renderers can be added or modified by plug-ins to
		 * generate suitable mark-up for a site. For example the Bootstrap
		 * integration plug-in for DataTables uses a paging button renderer to
		 * display pagination buttons in the mark-up required by Bootstrap.
		 *
		 * For further information about the renderers available see
		 * DataTable.ext.renderer
		 *  @type string|object
		 *  @default null
		 *
		 *  @name DataTable.defaults.renderer
		 *
		 */
		&quot;renderer&quot;: null,
	
	
		/**
		 * Set the data property name that DataTables should use to get a row&#x27;s id
		 * to set as the &#x60;id&#x60; property in the node.
		 *  @type string
		 *  @default DT_RowId
		 *
		 *  @name DataTable.defaults.rowId
		 */
		&quot;rowId&quot;: &quot;DT_RowId&quot;
	};
	
	_fnHungarianMap( DataTable.defaults );
	
	
	
	/*
	 * Developer note - See note in model.defaults.js about the use of Hungarian
	 * notation and camel case.
	 */
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.column = {
		/**
		 * Define which column(s) an order will occur on for this column. This
		 * allows a column&#x27;s ordering to take multiple columns into account when
		 * doing a sort or use the data from a different column. For example first
		 * name / last name columns make sense to do a multi-column sort over the
		 * two columns.
		 *  @type array|int
		 *  @default null &lt;i&gt;Takes the value of the column index automatically&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.orderData
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;orderData&quot;: [ 0, 1 ], &quot;targets&quot;: [ 0 ] },
		 *          { &quot;orderData&quot;: [ 1, 0 ], &quot;targets&quot;: [ 1 ] },
		 *          { &quot;orderData&quot;: 2, &quot;targets&quot;: [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;orderData&quot;: [ 0, 1 ] },
		 *          { &quot;orderData&quot;: [ 1, 0 ] },
		 *          { &quot;orderData&quot;: 2 },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;aDataSort&quot;: null,
		&quot;iDataSort&quot;: -1,
	
	
		/**
		 * You can control the default ordering direction, and even alter the
		 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
		 * using this parameter.
		 *  @type array
		 *  @default [ &#x27;asc&#x27;, &#x27;desc&#x27; ]
		 *
		 *  @name DataTable.defaults.column.orderSequence
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;orderSequence&quot;: [ &quot;asc&quot; ], &quot;targets&quot;: [ 1 ] },
		 *          { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ], &quot;targets&quot;: [ 2 ] },
		 *          { &quot;orderSequence&quot;: [ &quot;desc&quot; ], &quot;targets&quot;: [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          null,
		 *          { &quot;orderSequence&quot;: [ &quot;asc&quot; ] },
		 *          { &quot;orderSequence&quot;: [ &quot;desc&quot;, &quot;asc&quot;, &quot;asc&quot; ] },
		 *          { &quot;orderSequence&quot;: [ &quot;desc&quot; ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;asSorting&quot;: [ &#x27;asc&#x27;, &#x27;desc&#x27; ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.searchable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;searchable&quot;: false, &quot;targets&quot;: [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;searchable&quot;: false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		&quot;bSearchable&quot;: true,
	
	
		/**
		 * Enable or disable ordering on this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.orderable
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;orderable&quot;: false, &quot;targets&quot;: [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;orderable&quot;: false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		&quot;bSortable&quot;: true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *
		 *  @name DataTable.defaults.column.visible
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;visible&quot;: false, &quot;targets&quot;: [ 0 ] }
		 *        ] } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;visible&quot;: false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		&quot;bVisible&quot;: true,
	
	
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available.
		 *  @type function
		 *  @param {element} td The TD node that has been created
		 *  @param {*} cellData The Data for the cell
		 *  @param {array|object} rowData The data for the whole row
		 *  @param {int} row The row index for the aoData data store
		 *  @param {int} col The column index for aoColumns
		 *
		 *  @name DataTable.defaults.column.createdCell
		 *  @dtopt Columns
		 *
		 *  @example
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [3],
		 *          &quot;createdCell&quot;: function (td, cellData, rowData, row, col) {
		 *            if ( cellData == &quot;1.7&quot; ) {
		 *              $(td).css(&#x27;color&#x27;, &#x27;blue&#x27;)
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		&quot;fnCreatedCell&quot;: null,
	
	
		/**
		 * This parameter has been replaced by &#x60;data&#x60; in DataTables to ensure naming
		 * consistency. &#x60;dataProp&#x60; can still be used, as there is backwards
		 * compatibility in DataTables for this option, but it is strongly
		 * recommended that you use &#x60;data&#x60; in preference to &#x60;dataProp&#x60;.
		 *  @name DataTable.defaults.column.dataProp
		 */
	
	
		/**
		 * This property can be used to read data from any data source property,
		 * including deeply nested objects / properties. &#x60;data&#x60; can be given in a
		 * number of different ways which effect its behaviour:
		 *
		 * * &#x60;integer&#x60; - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * &#x60;string&#x60; - read an object property from the data source. There are
		 *   three &#x27;special&#x27; options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * &#x60;.&#x60; - Dotted Javascript notation. Just as you use a &#x60;.&#x60; in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in &#x60;data&#x60;. For example: &#x60;browser.version&#x60; or
		 *      &#x60;browser.name&#x60;. If your object parameter name contains a period, use
		 *      &#x60;\\&#x60; to escape it - i.e. &#x60;first\\.name&#x60;.
		 *    * &#x60;[]&#x60; - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: &#x60;name[, ]&#x60; would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * &#x60;()&#x60; - Function notation. Adding &#x60;()&#x60; to the end of a parameter will
		 *      execute a function of the name given. For example: &#x60;browser()&#x60; for a
		 *      simple function on the data source, &#x60;browser.version()&#x60; for a
		 *      function in a nested property or even &#x60;browser().version&#x60; to get an
		 *      object property if the function called returns an object. Note that
		 *      function notation is recommended for use in &#x60;render&#x60; rather than
		 *      &#x60;data&#x60; as it is much simpler to use as a renderer.
		 * * &#x60;null&#x60; - use the original data source for the row rather than plucking
		 *   data directly from it. This action has effects on two other
		 *   initialisation options:
		 *    * &#x60;defaultContent&#x60; - When null is given as the &#x60;data&#x60; option and
		 *      &#x60;defaultContent&#x60; is specified for the column, the value defined by
		 *      &#x60;defaultContent&#x60; will be used for the cell.
		 *    * &#x60;render&#x60; - When null is used for the &#x60;data&#x60; option and the &#x60;render&#x60;
		 *      option is specified for the column, the whole data source for the
		 *      row is used for the renderer.
		 * * &#x60;function&#x60; - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * &#x60;{array|object}&#x60; The data source for the row
		 *      * &#x60;{string}&#x60; The type call data requested - this will be &#x27;set&#x27; when
		 *        setting data or &#x27;filter&#x27;, &#x27;display&#x27;, &#x27;type&#x27;, &#x27;sort&#x27; or undefined
		 *        when gathering data. Note that when &#x60;undefined&#x60; is given for the
		 *        type DataTables expects to get the raw data for the object back&lt;
		 *      * &#x60;{*}&#x60; Data to set when the second parameter is &#x27;set&#x27;.
		 *    * Return:
		 *      * The return value from the function is not required when &#x27;set&#x27; is
		 *        the type of call, but otherwise the return is what will be used
		 *        for the data requested.
		 *
		 * Note that &#x60;data&#x60; is a getter and setter option. If you just require
		 * formatting of data for output, you will likely want to use &#x60;render&#x60; which
		 * is simply a getter and thus simpler to use.
		 *
		 * Note that prior to DataTables 1.9.2 &#x60;data&#x60; was called &#x60;mDataProp&#x60;. The
		 * name change reflects the flexibility of this property and is consistent
		 * with the naming of mRender. If &#x27;mDataProp&#x27; is given, then it will still
		 * be used by DataTables, as it automatically maps the old name to the new
		 * if required.
		 *
		 *  @type string|int|function|null
		 *  @default null &lt;i&gt;Use automatically calculated column index&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.data
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Read table data from objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      &quot;engine&quot;: {value},
		 *    //      &quot;browser&quot;: {value},
		 *    //      &quot;platform&quot;: {value},
		 *    //      &quot;version&quot;: {value},
		 *    //      &quot;grade&quot;: {value}
		 *    //   }
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;ajaxSource&quot;: &quot;sources/objects.txt&quot;,
		 *        &quot;columns&quot;: [
		 *          { &quot;data&quot;: &quot;engine&quot; },
		 *          { &quot;data&quot;: &quot;browser&quot; },
		 *          { &quot;data&quot;: &quot;platform&quot; },
		 *          { &quot;data&quot;: &quot;version&quot; },
		 *          { &quot;data&quot;: &quot;grade&quot; }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Read information from deeply nested objects
		 *    // JSON structure for each row:
		 *    //   {
		 *    //      &quot;engine&quot;: {value},
		 *    //      &quot;browser&quot;: {value},
		 *    //      &quot;platform&quot;: {
		 *    //         &quot;inner&quot;: {value}
		 *    //      },
		 *    //      &quot;details&quot;: [
		 *    //         {value}, {value}
		 *    //      ]
		 *    //   }
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
		 *        &quot;columns&quot;: [
		 *          { &quot;data&quot;: &quot;engine&quot; },
		 *          { &quot;data&quot;: &quot;browser&quot; },
		 *          { &quot;data&quot;: &quot;platform.inner&quot; },
		 *          { &quot;data&quot;: &quot;platform.details.0&quot; },
		 *          { &quot;data&quot;: &quot;platform.details.1&quot; }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;data&#x60; as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: function ( source, type, val ) {
		 *            if (type === &#x27;set&#x27;) {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val);
		 *              source.price_filter  = val==&quot;&quot; ? &quot;&quot; : &quot;$&quot;+numberFormat(val)+&quot; &quot;+val;
		 *              return;
		 *            }
		 *            else if (type === &#x27;display&#x27;) {
		 *              return source.price_display;
		 *            }
		 *            else if (type === &#x27;filter&#x27;) {
		 *              return source.price_filter;
		 *            }
		 *            // &#x27;sort&#x27;, &#x27;type&#x27; and undefined all just use the integer
		 *            return source.price;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using default content
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: null,
		 *          &quot;defaultContent&quot;: &quot;Click to edit&quot;
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using array notation - outputting a list from an array
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: &quot;name[, ]&quot;
		 *        } ]
		 *      } );
		 *    } );
		 *
		 */
		&quot;mData&quot;: null,
	
	
		/**
		 * This property is the rendering partner to &#x60;data&#x60; and it is suggested that
		 * when you want to manipulate data for display (including filtering,
		 * sorting etc) without altering the underlying data for the table, use this
		 * property. &#x60;render&#x60; can be considered to be the the read only companion to
		 * &#x60;data&#x60; which is read / write (then as such more complex). Like &#x60;data&#x60;
		 * this option can be given in a number of different ways to effect its
		 * behaviour:
		 *
		 * * &#x60;integer&#x60; - treated as an array index for the data source. This is the
		 *   default that DataTables uses (incrementally increased for each column).
		 * * &#x60;string&#x60; - read an object property from the data source. There are
		 *   three &#x27;special&#x27; options that can be used in the string to alter how
		 *   DataTables reads the data from the source object:
		 *    * &#x60;.&#x60; - Dotted Javascript notation. Just as you use a &#x60;.&#x60; in
		 *      Javascript to read from nested objects, so to can the options
		 *      specified in &#x60;data&#x60;. For example: &#x60;browser.version&#x60; or
		 *      &#x60;browser.name&#x60;. If your object parameter name contains a period, use
		 *      &#x60;\\&#x60; to escape it - i.e. &#x60;first\\.name&#x60;.
		 *    * &#x60;[]&#x60; - Array notation. DataTables can automatically combine data
		 *      from and array source, joining the data with the characters provided
		 *      between the two brackets. For example: &#x60;name[, ]&#x60; would provide a
		 *      comma-space separated list from the source array. If no characters
		 *      are provided between the brackets, the original array source is
		 *      returned.
		 *    * &#x60;()&#x60; - Function notation. Adding &#x60;()&#x60; to the end of a parameter will
		 *      execute a function of the name given. For example: &#x60;browser()&#x60; for a
		 *      simple function on the data source, &#x60;browser.version()&#x60; for a
		 *      function in a nested property or even &#x60;browser().version&#x60; to get an
		 *      object property if the function called returns an object.
		 * * &#x60;object&#x60; - use different data for the different data types requested by
		 *   DataTables (&#x27;filter&#x27;, &#x27;display&#x27;, &#x27;type&#x27; or &#x27;sort&#x27;). The property names
		 *   of the object is the data type the property refers to and the value can
		 *   defined using an integer, string or function using the same rules as
		 *   &#x60;render&#x60; normally does. Note that an &#x60;_&#x60; option _must_ be specified.
		 *   This is the default value to use if you haven&#x27;t specified a value for
		 *   the data type requested by DataTables.
		 * * &#x60;function&#x60; - the function given will be executed whenever DataTables
		 *   needs to set or get the data for a cell in the column. The function
		 *   takes three parameters:
		 *    * Parameters:
		 *      * {array|object} The data source for the row (based on &#x60;data&#x60;)
		 *      * {string} The type call data requested - this will be &#x27;filter&#x27;,
		 *        &#x27;display&#x27;, &#x27;type&#x27; or &#x27;sort&#x27;.
		 *      * {array|object} The full data source for the row (not based on
		 *        &#x60;data&#x60;)
		 *    * Return:
		 *      * The return value from the function is what will be used for the
		 *        data requested.
		 *
		 *  @type string|int|function|object|null
		 *  @default null Use the data source value.
		 *
		 *  @name DataTable.defaults.column.render
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Create a comma separated list from an array of objects
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;ajaxSource&quot;: &quot;sources/deep.txt&quot;,
		 *        &quot;columns&quot;: [
		 *          { &quot;data&quot;: &quot;engine&quot; },
		 *          { &quot;data&quot;: &quot;browser&quot; },
		 *          {
		 *            &quot;data&quot;: &quot;platform&quot;,
		 *            &quot;render&quot;: &quot;[, ].name&quot;
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Execute a function to obtain data
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: null, // Use the full data source object for the renderer&#x27;s source
		 *          &quot;render&quot;: &quot;browserName()&quot;
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // As an object, extracting different data for the different types
		 *    // This would be used with a data source such as:
		 *    //   { &quot;phone&quot;: 5552368, &quot;phone_filter&quot;: &quot;5552368 555-2368&quot;, &quot;phone_display&quot;: &quot;555-2368&quot; }
		 *    // Here the &#x60;phone&#x60; integer is used for sorting and type detection, while &#x60;phone_filter&#x60;
		 *    // (which has both forms) is used for filtering for if a user inputs either format, while
		 *    // the formatted phone number is the one that is shown in the table.
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: null, // Use the full data source object for the renderer&#x27;s source
		 *          &quot;render&quot;: {
		 *            &quot;_&quot;: &quot;phone&quot;,
		 *            &quot;filter&quot;: &quot;phone_filter&quot;,
		 *            &quot;display&quot;: &quot;phone_display&quot;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Use as a function to create a link from the data source
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;data&quot;: &quot;download_link&quot;,
		 *          &quot;render&quot;: function ( data, type, full ) {
		 *            return &#x27;&lt;a href=&quot;&#x27;+data+&#x27;&quot;&gt;Download&lt;/a&gt;&#x27;;
		 *          }
		 *        } ]
		 *      } );
		 *    } );
		 */
		&quot;mRender&quot;: null,
	
	
		/**
		 * Change the cell type created for the column - either TD cells or TH cells. This
		 * can be useful as TH cells have semantic meaning in the table body, allowing them
		 * to act as a header for a row (you may wish to add scope=&#x27;row&#x27; to the TH elements).
		 *  @type string
		 *  @default td
		 *
		 *  @name DataTable.defaults.column.cellType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Make the first column use TH cells
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [ {
		 *          &quot;targets&quot;: [ 0 ],
		 *          &quot;cellType&quot;: &quot;th&quot;
		 *        } ]
		 *      } );
		 *    } );
		 */
		&quot;sCellType&quot;: &quot;td&quot;,
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.class
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;class&quot;: &quot;my_class&quot;, &quot;targets&quot;: [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;class&quot;: &quot;my_class&quot; },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sClass&quot;: &quot;&quot;,
	
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that &quot;mmm&quot; is much wider then &quot;iiii&quot;, but the latter is a longer
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a &quot;work around&quot; we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn&#x27;t need this!
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;i&gt;
		 *
		 *  @name DataTable.defaults.column.contentPadding
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            &quot;contentPadding&quot;: &quot;mmm&quot;
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sContentPadding&quot;: &quot;&quot;,
	
	
		/**
		 * Allows a default value to be given for a column&#x27;s data, and will be used
		 * whenever a null data source is encountered (this can be because &#x60;data&#x60;
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *
		 *  @name DataTable.defaults.column.defaultContent
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          {
		 *            &quot;data&quot;: null,
		 *            &quot;defaultContent&quot;: &quot;Edit&quot;,
		 *            &quot;targets&quot;: [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            &quot;data&quot;: null,
		 *            &quot;defaultContent&quot;: &quot;Edit&quot;
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sDefaultContent&quot;: null,
	
	
		/**
		 * This parameter is only used in DataTables&#x27; server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.name
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;name&quot;: &quot;engine&quot;, &quot;targets&quot;: [ 0 ] },
		 *          { &quot;name&quot;: &quot;browser&quot;, &quot;targets&quot;: [ 1 ] },
		 *          { &quot;name&quot;: &quot;platform&quot;, &quot;targets&quot;: [ 2 ] },
		 *          { &quot;name&quot;: &quot;version&quot;, &quot;targets&quot;: [ 3 ] },
		 *          { &quot;name&quot;: &quot;grade&quot;, &quot;targets&quot;: [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;name&quot;: &quot;engine&quot; },
		 *          { &quot;name&quot;: &quot;browser&quot; },
		 *          { &quot;name&quot;: &quot;platform&quot; },
		 *          { &quot;name&quot;: &quot;version&quot; },
		 *          { &quot;name&quot;: &quot;grade&quot; }
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sName&quot;: &quot;&quot;,
	
	
		/**
		 * Defines a data source type for the ordering which can be used to read
		 * real-time information from the table (updating the internally cached
		 * version) prior to ordering. This allows ordering to occur on user
		 * editable elements such as form inputs.
		 *  @type string
		 *  @default std
		 *
		 *  @name DataTable.defaults.column.orderDataType
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;targets&quot;: [ 2, 3 ] },
		 *          { &quot;type&quot;: &quot;numeric&quot;, &quot;targets&quot;: [ 3 ] },
		 *          { &quot;orderDataType&quot;: &quot;dom-select&quot;, &quot;targets&quot;: [ 4 ] },
		 *          { &quot;orderDataType&quot;: &quot;dom-checkbox&quot;, &quot;targets&quot;: [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          null,
		 *          null,
		 *          { &quot;orderDataType&quot;: &quot;dom-text&quot; },
		 *          { &quot;orderDataType&quot;: &quot;dom-text&quot;, &quot;type&quot;: &quot;numeric&quot; },
		 *          { &quot;orderDataType&quot;: &quot;dom-select&quot; },
		 *          { &quot;orderDataType&quot;: &quot;dom-checkbox&quot; }
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sSortDataType&quot;: &quot;std&quot;,
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null &lt;i&gt;Derived from the &#x27;TH&#x27; value for this column in the
		 *    original HTML table.&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.title
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;title&quot;: &quot;My column title&quot;, &quot;targets&quot;: [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;title&quot;: &quot;My column title&quot; },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sTitle&quot;: null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be
		 * ordered. Four types (string, numeric, date and html (which will strip
		 * HTML tags before ordering)) are currently available. Note that only date
		 * formats understood by Javascript&#x27;s Date() object will be accepted as type
		 * date. For example: &quot;Mar 26, 2008 5:03 PM&quot;. May take the values: &#x27;string&#x27;,
		 * &#x27;numeric&#x27;, &#x27;date&#x27; or &#x27;html&#x27; (by default). Further types can be adding
		 * through plug-ins.
		 *  @type string
		 *  @default null &lt;i&gt;Auto-detected from raw data&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.type
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;type&quot;: &quot;html&quot;, &quot;targets&quot;: [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;type&quot;: &quot;html&quot; },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sType&quot;: null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applies &#x27;smart&#x27; widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null &lt;i&gt;Automatic&lt;/i&gt;
		 *
		 *  @name DataTable.defaults.column.width
		 *  @dtopt Columns
		 *
		 *  @example
		 *    // Using &#x60;columnDefs&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columnDefs&quot;: [
		 *          { &quot;width&quot;: &quot;20%&quot;, &quot;targets&quot;: [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Using &#x60;columns&#x60;
		 *    $(document).ready( function() {
		 *      $(&#x27;#example&#x27;).dataTable( {
		 *        &quot;columns&quot;: [
		 *          { &quot;width&quot;: &quot;20%&quot; },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		&quot;sWidth&quot;: null
	};
	
	_fnHungarianMap( DataTable.defaults.column );
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable &quot;class&quot; are created on-the-fly as needed (typically by a
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 *
	 * Note that this object is related to {@link DataTable.defaults} but this
	 * one is the internal data store for DataTables&#x27;s cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don&#x27;t need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		&quot;oFeatures&quot;: {
	
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bAutoWidth&quot;: null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all fro DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bDeferRender&quot;: null,
	
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the &#x27;f&#x27; option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bFilter&quot;: null,
	
			/**
			 * Table information element (the &#x27;Showing x of y records&#x27; div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bInfo&quot;: null,
	
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bLengthChange&quot;: null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bPaginate&quot;: null,
	
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bProcessing&quot;: null,
	
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bServerSide&quot;: null,
	
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bSort&quot;: null,
	
			/**
			 * Multi-column sorting
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bSortMulti&quot;: null,
	
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bSortClasses&quot;: null,
	
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bStateSave&quot;: null
		},
	
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		&quot;oScroll&quot;: {
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			&quot;bCollapse&quot;: null,
	
			/**
			 * Width of the scrollbar for the web-browser&#x27;s platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			&quot;iBarWidth&quot;: 0,
	
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			&quot;sX&quot;: null,
	
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			&quot;sXInner&quot;: null,
	
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			&quot;sY&quot;: null
		},
	
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		&quot;oLanguage&quot;: {
			/**
			 * Information callback function. See
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default null
			 */
			&quot;fnInfoCallback&quot;: null
		},
	
		/**
		 * Browser support parameters
		 *  @namespace
		 */
		&quot;oBrowser&quot;: {
			/**
			 * Indicate if the browser incorrectly calculates width:100% inside a
			 * scrolling element (IE6/7)
			 *  @type boolean
			 *  @default false
			 */
			&quot;bScrollOversize&quot;: false,
	
			/**
			 * Determine if the vertical scrollbar is on the right or left of the
			 * scrolling container - needed for rtl language layout, although not
			 * all browsers move the scrollbar (Safari).
			 *  @type boolean
			 *  @default false
			 */
			&quot;bScrollbarLeft&quot;: false,
	
			/**
			 * Flag for if &#x60;getBoundingClientRect&#x60; is fully supported or not
			 *  @type boolean
			 *  @default false
			 */
			&quot;bBounding&quot;: false,
	
			/**
			 * Browser scrollbar width
			 *  @type integer
			 *  @default 0
			 */
			&quot;barWidth&quot;: 0
		},
	
	
		&quot;ajax&quot;: null,
	
	
		/**
		 * Array referencing the nodes which are used for the features. The
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   &lt;ul&gt;
		 *     &lt;li&gt;&#x27;l&#x27; - Length changing&lt;/li&gt;
		 *     &lt;li&gt;&#x27;f&#x27; - Filtering input&lt;/li&gt;
		 *     &lt;li&gt;&#x27;t&#x27; - The table!&lt;/li&gt;
		 *     &lt;li&gt;&#x27;i&#x27; - Information&lt;/li&gt;
		 *     &lt;li&gt;&#x27;p&#x27; - Pagination&lt;/li&gt;
		 *     &lt;li&gt;&#x27;r&#x27; - pRocessing&lt;/li&gt;
		 *   &lt;/ul&gt;
		 *  @type array
		 *  @default []
		 */
		&quot;aanFeatures&quot;: [],
	
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		&quot;aoData&quot;: [],
	
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		&quot;aiDisplay&quot;: [],
	
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		&quot;aiDisplayMaster&quot;: [],
	
		/**
		 * Map of row ids to data indexes
		 *  @type object
		 *  @default {}
		 */
		&quot;aIds&quot;: {},
	
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		&quot;aoColumns&quot;: [],
	
		/**
		 * Store information about the table&#x27;s header
		 *  @type array
		 *  @default []
		 */
		&quot;aoHeader&quot;: [],
	
		/**
		 * Store information about the table&#x27;s footer
		 *  @type array
		 *  @default []
		 */
		&quot;aoFooter&quot;: [],
	
		/**
		 * Store the applied global search information in case we want to force a
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		&quot;oPreviousSearch&quot;: {},
	
		/**
		 * Store the applied search for each column - see
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		&quot;aoPreSearchCols&quot;: [],
	
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * &lt;ul&gt;
		 *   &lt;li&gt;Index 0 - column number&lt;/li&gt;
		 *   &lt;li&gt;Index 1 - current sorting direction&lt;/li&gt;
		 * &lt;/ul&gt;
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		&quot;aaSorting&quot;: null,
	
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		&quot;aaSortingFixed&quot;: [],
	
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		&quot;asStripeClasses&quot;: null,
	
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		&quot;asDestroyStripes&quot;: [],
	
		/**
		 * If restoring a table - we should restore its width
		 *  @type int
		 *  @default 0
		 */
		&quot;sDestroyWidth&quot;: 0,
	
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		&quot;aoRowCallback&quot;: [],
	
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		&quot;aoHeaderCallback&quot;: [],
	
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		&quot;aoFooterCallback&quot;: [],
	
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		&quot;aoDrawCallback&quot;: [],
	
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		&quot;aoRowCreatedCallback&quot;: [],
	
		/**
		 * Callback functions for just before the table is redrawn. A return of
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		&quot;aoPreDrawCallback&quot;: [],
	
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		&quot;aoInitComplete&quot;: [],
	
	
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		&quot;aoStateSaveParams&quot;: [],
	
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		&quot;aoStateLoadParams&quot;: [],
	
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		&quot;aoStateLoaded&quot;: [],
	
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default &lt;i&gt;Empty string&lt;/i&gt;
		 */
		&quot;sTableId&quot;: &quot;&quot;,
	
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		&quot;nTable&quot;: null,
	
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		&quot;nTHead&quot;: null,
	
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		&quot;nTFoot&quot;: null,
	
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		&quot;nTBody&quot;: null,
	
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		&quot;nTableWrapper&quot;: null,
	
		/**
		 * Indicate if when using server-side processing the loading of data
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		&quot;bDeferLoading&quot;: false,
	
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		&quot;bInitialised&quot;: false,
	
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * &#x27;nTr&#x27; and &#x27;nParent&#x27;
		 *  @type array
		 *  @default []
		 */
		&quot;aoOpenRows&quot;: [],
	
		/**
		 * Dictate the positioning of DataTables&#x27; control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		&quot;sDom&quot;: null,
	
		/**
		 * Search delay (in mS)
		 *  @type integer
		 *  @default null
		 */
		&quot;searchDelay&quot;: null,
	
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default two_button
		 */
		&quot;sPaginationType&quot;: &quot;two_button&quot;,
	
		/**
		 * The state duration (for &#x60;stateSave&#x60;) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		&quot;iStateDuration&quot;: 0,
	
		/**
		 * Array of callback functions for state saving. Each array element is an
		 * object with the following parameters:
		 *   &lt;ul&gt;
		 *     &lt;li&gt;function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object
		 *       (i.e. &#x27;&quot;param&quot;: [ 0, 1, 2]&#x27;)&lt;/li&gt;
		 *     &lt;li&gt;string:sName - name of callback&lt;/li&gt;
		 *   &lt;/ul&gt;
		 *  @type array
		 *  @default []
		 */
		&quot;aoStateSave&quot;: [],
	
		/**
		 * Array of callback functions for state loading. Each array element is an
		 * object with the following parameters:
		 *   &lt;ul&gt;
		 *     &lt;li&gt;function:fn - function to call. Takes two parameters, oSettings
		 *       and the object stored. May return false to cancel state loading&lt;/li&gt;
		 *     &lt;li&gt;string:sName - name of callback&lt;/li&gt;
		 *   &lt;/ul&gt;
		 *  @type array
		 *  @default []
		 */
		&quot;aoStateLoad&quot;: [],
	
		/**
		 * State that was saved. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		&quot;oSavedState&quot;: null,
	
		/**
		 * State that was loaded. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		&quot;oLoadedState&quot;: null,
	
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		&quot;sAjaxSource&quot;: null,
	
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		&quot;sAjaxDataProp&quot;: null,
	
		/**
		 * Note if draw should be blocked while getting data
		 *  @type boolean
		 *  @default true
		 */
		&quot;bAjaxDataGet&quot;: true,
	
		/**
		 * The last jQuery XHR object that was used for server-side data gathering.
		 * This can be used for working with the XHR information in one of the
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		&quot;jqXHR&quot;: null,
	
		/**
		 * JSON returned from the server in the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		&quot;json&quot;: undefined,
	
		/**
		 * Data submitted as part of the last Ajax request
		 *  @type object
		 *  @default undefined
		 */
		&quot;oAjaxData&quot;: undefined,
	
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		&quot;fnServerData&quot;: null,
	
		/**
		 * Functions which are called prior to sending an Ajax request so extra
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		&quot;aoServerParams&quot;: [],
	
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		&quot;sServerMethod&quot;: null,
	
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		&quot;fnFormatNumber&quot;: null,
	
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		&quot;aLengthMenu&quot;: null,
	
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		&quot;iDraw&quot;: 0,
	
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		&quot;bDrawing&quot;: false,
	
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		&quot;iDrawError&quot;: -1,
	
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		&quot;_iDisplayLength&quot;: 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		&quot;_iDisplayStart&quot;: 0,
	
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		&quot;_iRecordsTotal&quot;: 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		&quot;_iRecordsDisplay&quot;: 0,
	
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		&quot;oClasses&quot;: {},
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		&quot;bFiltered&quot;: false,
	
		/**
		 * Flag attached to the settings object so you can check in the draw
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		&quot;bSorted&quot;: false,
	
		/**
		 * Indicate that if multiple rows are in the header and there is more than
		 * one unique cell per column, if the top one (true) or bottom one (false)
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		&quot;bSortCellsTop&quot;: null,
	
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		&quot;oInit&quot;: null,
	
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		&quot;aoDestroyCallback&quot;: [],
	
	
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		&quot;fnRecordsTotal&quot;: function ()
		{
			return _fnDataSource( this ) == &#x27;ssp&#x27; ?
				this._iRecordsTotal * 1 :
				this.aiDisplayMaster.length;
		},
	
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		&quot;fnRecordsDisplay&quot;: function ()
		{
			return _fnDataSource( this ) == &#x27;ssp&#x27; ?
				this._iRecordsDisplay * 1 :
				this.aiDisplay.length;
		},
	
		/**
		 * Get the display end point - aiDisplay index
		 *  @type function
		 */
		&quot;fnDisplayEnd&quot;: function ()
		{
			var
				len      = this._iDisplayLength,
				start    = this._iDisplayStart,
				calc     = start + len,
				records  = this.aiDisplay.length,
				features = this.oFeatures,
				paginate = features.bPaginate;
	
			if ( features.bServerSide ) {
				return paginate === false || len === -1 ?
					start + records :
					Math.min( start+len, this._iRecordsDisplay );
			}
			else {
				return ! paginate || calc&gt;records || len===-1 ?
					records :
					calc;
			}
		},
	
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		&quot;oInstance&quot;: null,
	
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		&quot;sInstance&quot;: null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		&quot;iTabIndex&quot;: 0,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		&quot;nScrollHead&quot;: null,
	
		/**
		 * DIV container for the footer scrolling table if scrolling
		 */
		&quot;nScrollFoot&quot;: null,
	
		/**
		 * Last applied sort
		 *  @type array
		 *  @default []
		 */
		&quot;aLastSort&quot;: [],
	
		/**
		 * Stored plug-in instances
		 *  @type object
		 *  @default {}
		 */
		&quot;oPlugins&quot;: {},
	
		/**
		 * Function used to get a row&#x27;s id from the row&#x27;s data
		 *  @type function
		 *  @default null
		 */
		&quot;rowIdFn&quot;: null,
	
		/**
		 * Data location where to store a row&#x27;s id
		 *  @type string
		 *  @default null
		 */
		&quot;rowId&quot;: null
	};

	/**
	 * Extension object for DataTables that is used to provide all extension
	 * options.
	 *
	 * Note that the &#x60;DataTable.ext&#x60; object is available through
	 * &#x60;jQuery.fn.dataTable.ext&#x60; where it may be accessed and manipulated. It is
	 * also aliased to &#x60;jQuery.fn.dataTableExt&#x60; for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	
	
	/**
	 * DataTables extensions
	 * 
	 * This namespace acts as a collection area for plug-ins that can be used to
	 * extend DataTables capabilities. Indeed many of the build in methods
	 * use this method to provide their own capabilities (sorting methods for
	 * example).
	 *
	 * Note that this namespace is aliased to &#x60;jQuery.fn.dataTableExt&#x60; for legacy
	 * reasons
	 *
	 *  @namespace
	 */
	DataTable.ext = _ext = {
		/**
		 * Buttons. For use with the Buttons extension for DataTables. This is
		 * defined here so other extensions can define buttons regardless of load
		 * order. It is _not_ used by DataTables core.
		 *
		 *  @type object
		 *  @default {}
		 */
		buttons: {},
	
	
		/**
		 * Element class names
		 *
		 *  @type object
		 *  @default {}
		 */
		classes: {},
	
	
		/**
		 * DataTables build type (expanded by the download builder)
		 *
		 *  @type string
		 */
		build:&quot;dt/dt-1.10.16&quot;,
	
	
		/**
		 * Error reporting.
		 * 
		 * How should DataTables report an error. Can take the value &#x27;alert&#x27;,
		 * &#x27;throw&#x27;, &#x27;none&#x27; or a function.
		 *
		 *  @type string|function
		 *  @default alert
		 */
		errMode: &quot;alert&quot;,
	
	
		/**
		 * Feature plug-ins.
		 * 
		 * This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are then available for
		 * use through the &#x60;dom&#x60; initialisation option.
		 * 
		 * Each feature plug-in is described by an object which must have the
		 * following properties:
		 * 
		 * * &#x60;fnInit&#x60; - function that is used to initialise the plug-in,
		 * * &#x60;cFeature&#x60; - a character so the feature can be enabled by the &#x60;dom&#x60;
		 *   instillation option. This is case sensitive.
		 *
		 * The &#x60;fnInit&#x60; function has the following input parameters:
		 *
		 * 1. &#x60;{object}&#x60; DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 *
		 * And the following return is expected:
		 * 
		 * * {node|null} The element which contains your feature. Note that the
		 *   return may also be void if your plug-in does not require to inject any
		 *   DOM elements into DataTables control (&#x60;dom&#x60;) - for example this might
		 *   be useful when developing a plug-in which allows table control via
		 *   keyboard entry
		 *
		 *  @type array
		 *
		 *  @example
		 *    $.fn.dataTable.ext.features.push( {
		 *      &quot;fnInit&quot;: function( oSettings ) {
		 *        return new TableTools( { &quot;oDTSettings&quot;: oSettings } );
		 *      },
		 *      &quot;cFeature&quot;: &quot;T&quot;
		 *    } );
		 */
		feature: [],
	
	
		/**
		 * Row searching.
		 * 
		 * This method of searching is complimentary to the default type based
		 * searching, and a lot more comprehensive as it allows you complete control
		 * over the searching logic. Each element in this array is a function
		 * (parameters described below) that is called for every row in the table,
		 * and your logic decides if it should be included in the searching data set
		 * or not.
		 *
		 * Searching functions have the following input parameters:
		 *
		 * 1. &#x60;{object}&#x60; DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. &#x60;{array|object}&#x60; Data for the row to be processed (same as the
		 *    original format that was passed in as the data source, or an array
		 *    from a DOM data source
		 * 3. &#x60;{int}&#x60; Row index ({@link DataTable.models.oSettings.aoData}), which
		 *    can be useful to retrieve the &#x60;TR&#x60; element if you need DOM interaction.
		 *
		 * And the following return is expected:
		 *
		 * * {boolean} Include the row in the searched result set (true) or not
		 *   (false)
		 *
		 * Note that as with the main search ability in DataTables, technically this
		 * is &quot;filtering&quot;, since it is subtractive. However, for consistency in
		 * naming we call it searching here.
		 *
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom search being applied to the
		 *    // fourth column (i.e. the data[3] index) based on two input values
		 *    // from the end-user, matching the data in a certain range.
		 *    $.fn.dataTable.ext.search.push(
		 *      function( settings, data, dataIndex ) {
		 *        var min = document.getElementById(&#x27;min&#x27;).value * 1;
		 *        var max = document.getElementById(&#x27;max&#x27;).value * 1;
		 *        var version = data[3] == &quot;-&quot; ? 0 : data[3]*1;
		 *
		 *        if ( min == &quot;&quot; &amp;&amp; max == &quot;&quot; ) {
		 *          return true;
		 *        }
		 *        else if ( min == &quot;&quot; &amp;&amp; version &lt; max ) {
		 *          return true;
		 *        }
		 *        else if ( min &lt; version &amp;&amp; &quot;&quot; == max ) {
		 *          return true;
		 *        }
		 *        else if ( min &lt; version &amp;&amp; version &lt; max ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		search: [],
	
	
		/**
		 * Selector extensions
		 *
		 * The &#x60;selector&#x60; option can be used to extend the options available for the
		 * selector modifier options (&#x60;selector-modifier&#x60; object data type) that
		 * each of the three built in selector types offer (row, column and cell +
		 * their plural counterparts). For example the Select extension uses this
		 * mechanism to provide an option to select only rows, columns and cells
		 * that have been marked as selected by the end user (&#x60;{selected: true}&#x60;),
		 * which can be used in conjunction with the existing built in selector
		 * options.
		 *
		 * Each property is an array to which functions can be pushed. The functions
		 * take three attributes:
		 *
		 * * Settings object for the host table
		 * * Options object (&#x60;selector-modifier&#x60; object type)
		 * * Array of selected item indexes
		 *
		 * The return is an array of the resulting item indexes after the custom
		 * selector has been applied.
		 *
		 *  @type object
		 */
		selector: {
			cell: [],
			column: [],
			row: []
		},
	
	
		/**
		 * Internal functions, exposed for used in plug-ins.
		 * 
		 * Please note that you should not need to use the internal methods for
		 * anything other than a plug-in (and even then, try to avoid if possible).
		 * The internal function may change between releases.
		 *
		 *  @type object
		 *  @default {}
		 */
		internal: {},
	
	
		/**
		 * Legacy configuration options. Enable and disable legacy options that
		 * are available in DataTables.
		 *
		 *  @type object
		 */
		legacy: {
			/**
			 * Enable / disable DataTables 1.9 compatible server-side processing
			 * requests
			 *
			 *  @type boolean
			 *  @default null
			 */
			ajax: null
		},
	
	
		/**
		 * Pagination plug-in methods.
		 * 
		 * Each entry in this object is a function and defines which buttons should
		 * be shown by the pagination rendering method that is used for the table:
		 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
		 * buttons are displayed in the document, while the functions here tell it
		 * what buttons to display. This is done by returning an array of button
		 * descriptions (what each button will do).
		 *
		 * Pagination types (the four built in options and any additional plug-in
		 * options defined here) can be used through the &#x60;paginationType&#x60;
		 * initialisation parameter.
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. &#x60;{int} page&#x60; The current page index
		 * 2. &#x60;{int} pages&#x60; The number of pages in the table
		 *
		 * Each function is expected to return an array where each element of the
		 * array can be one of:
		 *
		 * * &#x60;first&#x60; - Jump to first page when activated
		 * * &#x60;last&#x60; - Jump to last page when activated
		 * * &#x60;previous&#x60; - Show previous page when activated
		 * * &#x60;next&#x60; - Show next page when activated
		 * * &#x60;{int}&#x60; - Show page of the index given
		 * * &#x60;{array}&#x60; - A nested array containing the above elements to add a
		 *   containing &#x27;DIV&#x27; element (might be useful for styling).
		 *
		 * Note that DataTables v1.9- used this object slightly differently whereby
		 * an object with two functions would be defined for each plug-in. That
		 * ability is still supported by DataTables 1.10+ to provide backwards
		 * compatibility, but this option of use is now decremented and no longer
		 * documented in DataTables 1.10+.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Show previous, next and current page buttons only
		 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
		 *      return [ &#x27;previous&#x27;, page, &#x27;next&#x27; ];
		 *    };
		 */
		pager: {},
	
	
		renderer: {
			pageButton: {},
			header: {}
		},
	
	
		/**
		 * Ordering plug-ins - custom data source
		 * 
		 * The extension options for ordering of data available here is complimentary
		 * to the default type based ordering that DataTables typically uses. It
		 * allows much greater control over the the data that is being used to
		 * order a column, but is necessarily therefore more complex.
		 * 
		 * This type of ordering is useful if you want to do ordering based on data
		 * live from the DOM (for example the contents of an &#x27;input&#x27; element) rather
		 * than just the static string that DataTables knows of.
		 * 
		 * The way these plug-ins work is that you create an array of the values you
		 * wish to be ordering for the column in question and then return that
		 * array. The data in the array much be in the index order of the rows in
		 * the table (not the currently ordering order!). Which order data gathering
		 * function is run here depends on the &#x60;dt-init columns.orderDataType&#x60;
		 * parameter that is used for the column (if any).
		 *
		 * The functions defined take two parameters:
		 *
		 * 1. &#x60;{object}&#x60; DataTables settings object: see
		 *    {@link DataTable.models.oSettings}
		 * 2. &#x60;{int}&#x60; Target column index
		 *
		 * Each function is expected to return an array:
		 *
		 * * &#x60;{array}&#x60; Data for the column to be ordering upon
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Ordering using &#x60;input&#x60; node values
		 *    $.fn.dataTable.ext.order[&#x27;dom-text&#x27;] = function  ( settings, col )
		 *    {
		 *      return this.api().column( col, {order:&#x27;index&#x27;} ).nodes().map( function ( td, i ) {
		 *        return $(&#x27;input&#x27;, td).val();
		 *      } );
		 *    }
		 */
		order: {},
	
	
		/**
		 * Type based plug-ins.
		 *
		 * Each column in DataTables has a type assigned to it, either by automatic
		 * detection or by direct assignment using the &#x60;type&#x60; option for the column.
		 * The type of a column will effect how it is ordering and search (plug-ins
		 * can also make use of the column type if required).
		 *
		 * @namespace
		 */
		type: {
			/**
			 * Type detection functions.
			 *
			 * The functions defined in this object are used to automatically detect
			 * a column&#x27;s type, making initialisation of DataTables super easy, even
			 * when complex data is in the table.
			 *
			 * The functions defined take two parameters:
			 *
		     *  1. &#x60;{*}&#x60; Data from the column cell to be analysed
		     *  2. &#x60;{settings}&#x60; DataTables settings object. This can be used to
		     *     perform context specific type detection - for example detection
		     *     based on language settings such as using a comma for a decimal
		     *     place. Generally speaking the options from the settings will not
		     *     be required
			 *
			 * Each function is expected to return:
			 *
			 * * &#x60;{string|null}&#x60; Data type detected, or null if unknown (and thus
			 *   pass it on to the other type detection functions.
			 *
			 *  @type array
			 *
			 *  @example
			 *    // Currency type detection plug-in:
			 *    $.fn.dataTable.ext.type.detect.push(
			 *      function ( data, settings ) {
			 *        // Check the numeric part
			 *        if ( ! $.isNumeric( data.substring(1) ) ) {
			 *          return null;
			 *        }
			 *
			 *        // Check prefixed by currency
			 *        if ( data.charAt(0) == &#x27;$&#x27; || data.charAt(0) == &#x27;&amp;pound;&#x27; ) {
			 *          return &#x27;currency&#x27;;
			 *        }
			 *        return null;
			 *      }
			 *    );
			 */
			detect: [],
	
	
			/**
			 * Type based search formatting.
			 *
			 * The type based searching functions can be used to pre-format the
			 * data to be search on. For example, it can be used to strip HTML
			 * tags or to de-format telephone numbers for numeric only searching.
			 *
			 * Note that is a search is not defined for a column of a given type,
			 * no search formatting will be performed.
			 * 
			 * Pre-processing of searching data plug-ins - When you assign the sType
			 * for a column (or have it automatically detected for you by DataTables
			 * or a type detection plug-in), you will typically be using this for
			 * custom sorting, but it can also be used to provide custom searching
			 * by allowing you to pre-processing the data and returning the data in
			 * the format that should be searched upon. This is done by adding
			 * functions this object with a parameter name which matches the sType
			 * for that target column. This is the corollary of &lt;i&gt;afnSortData&lt;/i&gt;
			 * for searching data.
			 *
			 * The functions defined take a single parameter:
			 *
		     *  1. &#x60;{*}&#x60; Data from the column cell to be prepared for searching
			 *
			 * Each function is expected to return:
			 *
			 * * &#x60;{string|null}&#x60; Formatted string that will be used for the searching.
			 *
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    $.fn.dataTable.ext.type.search[&#x27;title-numeric&#x27;] = function ( d ) {
			 *      return d.replace(/\n/g,&quot; &quot;).replace( /&lt;.*?&gt;/g, &quot;&quot; );
			 *    }
			 */
			search: {},
	
	
			/**
			 * Type based ordering.
			 *
			 * The column type tells DataTables what ordering to apply to the table
			 * when a column is sorted upon. The order for each type that is defined,
			 * is defined by the functions available in this object.
			 *
			 * Each ordering option can be described by three properties added to
			 * this object:
			 *
			 * * &#x60;{type}-pre&#x60; - Pre-formatting function
			 * * &#x60;{type}-asc&#x60; - Ascending order function
			 * * &#x60;{type}-desc&#x60; - Descending order function
			 *
			 * All three can be used together, only &#x60;{type}-pre&#x60; or only
			 * &#x60;{type}-asc&#x60; and &#x60;{type}-desc&#x60; together. It is generally recommended
			 * that only &#x60;{type}-pre&#x60; is used, as this provides the optimal
			 * implementation in terms of speed, although the others are provided
			 * for compatibility with existing Javascript sort functions.
			 *
			 * &#x60;{type}-pre&#x60;: Functions defined take a single parameter:
			 *
		     *  1. &#x60;{*}&#x60; Data from the column cell to be prepared for ordering
			 *
			 * And return:
			 *
			 * * &#x60;{*}&#x60; Data to be sorted upon
			 *
			 * &#x60;{type}-asc&#x60; and &#x60;{type}-desc&#x60;: Functions are typical Javascript sort
			 * functions, taking two parameters:
			 *
		     *  1. &#x60;{*}&#x60; Data to compare to the second parameter
		     *  2. &#x60;{*}&#x60; Data to compare to the first parameter
			 *
			 * And returning:
			 *
			 * * &#x60;{*}&#x60; Ordering match: &lt;0 if first parameter should be sorted lower
			 *   than the second parameter, ===0 if the two parameters are equal and
			 *   &gt;0 if the first parameter should be sorted height than the second
			 *   parameter.
			 * 
			 *  @type object
			 *  @default {}
			 *
			 *  @example
			 *    // Numeric ordering of formatted numbers with a pre-formatter
			 *    $.extend( $.fn.dataTable.ext.type.order, {
			 *      &quot;string-pre&quot;: function(x) {
			 *        a = (a === &quot;-&quot; || a === &quot;&quot;) ? 0 : a.replace( /[^\d\-\.]/g, &quot;&quot; );
			 *        return parseFloat( a );
			 *      }
			 *    } );
			 *
			 *  @example
			 *    // Case-sensitive string ordering, with no pre-formatting method
			 *    $.extend( $.fn.dataTable.ext.order, {
			 *      &quot;string-case-asc&quot;: function(x,y) {
			 *        return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
			 *      },
			 *      &quot;string-case-desc&quot;: function(x,y) {
			 *        return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));
			 *      }
			 *    } );
			 */
			order: {}
		},
	
		/**
		 * Unique DataTables instance counter
		 *
		 * @type int
		 * @private
		 */
		_unique: 0,
	
	
		//
		// Depreciated
		// The following properties are retained for backwards compatiblity only.
		// The should not be used in new projects and will be removed in a future
		// version
		//
	
		/**
		 * Version check function.
		 *  @type function
		 *  @depreciated Since 1.10
		 */
		fnVersionCheck: DataTable.fnVersionCheck,
	
	
		/**
		 * Index for what &#x27;this&#x27; index API functions should use
		 *  @type int
		 *  @deprecated Since v1.10
		 */
		iApiIndex: 0,
	
	
		/**
		 * jQuery UI class container
		 *  @type object
		 *  @deprecated Since v1.10
		 */
		oJUIClasses: {},
	
	
		/**
		 * Software version
		 *  @type string
		 *  @deprecated Since v1.10
		 */
		sVersion: DataTable.version
	};
	
	
	//
	// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	//
	$.extend( _ext, {
		afnFiltering: _ext.search,
		aTypes:       _ext.type.detect,
		ofnSearch:    _ext.type.search,
		oSort:        _ext.type.order,
		afnSortData:  _ext.order,
		aoFeatures:   _ext.feature,
		oApi:         _ext.internal,
		oStdClasses:  _ext.classes,
		oPagination:  _ext.pager
	} );
	
	
	$.extend( DataTable.ext.classes, {
		&quot;sTable&quot;: &quot;dataTable&quot;,
		&quot;sNoFooter&quot;: &quot;no-footer&quot;,
	
		/* Paging buttons */
		&quot;sPageButton&quot;: &quot;paginate_button&quot;,
		&quot;sPageButtonActive&quot;: &quot;current&quot;,
		&quot;sPageButtonDisabled&quot;: &quot;disabled&quot;,
	
		/* Striping classes */
		&quot;sStripeOdd&quot;: &quot;odd&quot;,
		&quot;sStripeEven&quot;: &quot;even&quot;,
	
		/* Empty row */
		&quot;sRowEmpty&quot;: &quot;dataTables_empty&quot;,
	
		/* Features */
		&quot;sWrapper&quot;: &quot;dataTables_wrapper&quot;,
		&quot;sFilter&quot;: &quot;dataTables_filter&quot;,
		&quot;sInfo&quot;: &quot;dataTables_info&quot;,
		&quot;sPaging&quot;: &quot;dataTables_paginate paging_&quot;, /* Note that the type is postfixed */
		&quot;sLength&quot;: &quot;dataTables_length&quot;,
		&quot;sProcessing&quot;: &quot;dataTables_processing&quot;,
	
		/* Sorting */
		&quot;sSortAsc&quot;: &quot;sorting_asc&quot;,
		&quot;sSortDesc&quot;: &quot;sorting_desc&quot;,
		&quot;sSortable&quot;: &quot;sorting&quot;, /* Sortable in both directions */
		&quot;sSortableAsc&quot;: &quot;sorting_asc_disabled&quot;,
		&quot;sSortableDesc&quot;: &quot;sorting_desc_disabled&quot;,
		&quot;sSortableNone&quot;: &quot;sorting_disabled&quot;,
		&quot;sSortColumn&quot;: &quot;sorting_&quot;, /* Note that an int is postfixed for the sorting order */
	
		/* Filtering */
		&quot;sFilterInput&quot;: &quot;&quot;,
	
		/* Page length */
		&quot;sLengthSelect&quot;: &quot;&quot;,
	
		/* Scrolling */
		&quot;sScrollWrapper&quot;: &quot;dataTables_scroll&quot;,
		&quot;sScrollHead&quot;: &quot;dataTables_scrollHead&quot;,
		&quot;sScrollHeadInner&quot;: &quot;dataTables_scrollHeadInner&quot;,
		&quot;sScrollBody&quot;: &quot;dataTables_scrollBody&quot;,
		&quot;sScrollFoot&quot;: &quot;dataTables_scrollFoot&quot;,
		&quot;sScrollFootInner&quot;: &quot;dataTables_scrollFootInner&quot;,
	
		/* Misc */
		&quot;sHeaderTH&quot;: &quot;&quot;,
		&quot;sFooterTH&quot;: &quot;&quot;,
	
		// Deprecated
		&quot;sSortJUIAsc&quot;: &quot;&quot;,
		&quot;sSortJUIDesc&quot;: &quot;&quot;,
		&quot;sSortJUI&quot;: &quot;&quot;,
		&quot;sSortJUIAscAllowed&quot;: &quot;&quot;,
		&quot;sSortJUIDescAllowed&quot;: &quot;&quot;,
		&quot;sSortJUIWrapper&quot;: &quot;&quot;,
		&quot;sSortIcon&quot;: &quot;&quot;,
		&quot;sJUIHeader&quot;: &quot;&quot;,
		&quot;sJUIFooter&quot;: &quot;&quot;
	} );
	
	
	var extPagination = DataTable.ext.pager;
	
	function _numbers ( page, pages ) {
		var
			numbers = [],
			buttons = extPagination.numbers_length,
			half = Math.floor( buttons / 2 ),
			i = 1;
	
		if ( pages &lt;= buttons ) {
			numbers = _range( 0, pages );
		}
		else if ( page &lt;= half ) {
			numbers = _range( 0, buttons-2 );
			numbers.push( &#x27;ellipsis&#x27; );
			numbers.push( pages-1 );
		}
		else if ( page &gt;= pages - 1 - half ) {
			numbers = _range( pages-(buttons-2), pages );
			numbers.splice( 0, 0, &#x27;ellipsis&#x27; ); // no unshift in ie6
			numbers.splice( 0, 0, 0 );
		}
		else {
			numbers = _range( page-half+2, page+half-1 );
			numbers.push( &#x27;ellipsis&#x27; );
			numbers.push( pages-1 );
			numbers.splice( 0, 0, &#x27;ellipsis&#x27; );
			numbers.splice( 0, 0, 0 );
		}
	
		numbers.DT_el = &#x27;span&#x27;;
		return numbers;
	}
	
	
	$.extend( extPagination, {
		simple: function ( page, pages ) {
			return [ &#x27;previous&#x27;, &#x27;next&#x27; ];
		},
	
		full: function ( page, pages ) {
			return [  &#x27;first&#x27;, &#x27;previous&#x27;, &#x27;next&#x27;, &#x27;last&#x27; ];
		},
	
		numbers: function ( page, pages ) {
			return [ _numbers(page, pages) ];
		},
	
		simple_numbers: function ( page, pages ) {
			return [ &#x27;previous&#x27;, _numbers(page, pages), &#x27;next&#x27; ];
		},
	
		full_numbers: function ( page, pages ) {
			return [ &#x27;first&#x27;, &#x27;previous&#x27;, _numbers(page, pages), &#x27;next&#x27;, &#x27;last&#x27; ];
		},
		
		first_last_numbers: function (page, pages) {
	 		return [&#x27;first&#x27;, _numbers(page, pages), &#x27;last&#x27;];
	 	},
	
		// For testing and plug-ins to use
		_numbers: _numbers,
	
		// Number of number buttons (including ellipsis) to show. _Must be odd!_
		numbers_length: 7
	} );
	
	
	$.extend( true, DataTable.ext.renderer, {
		pageButton: {
			_: function ( settings, host, idx, buttons, page, pages ) {
				var classes = settings.oClasses;
				var lang = settings.oLanguage.oPaginate;
				var aria = settings.oLanguage.oAria.paginate || {};
				var btnDisplay, btnClass, counter=0;
	
				var attach = function( container, buttons ) {
					var i, ien, node, button;
					var clickHandler = function ( e ) {
						_fnPageChange( settings, e.data.action, true );
					};
	
					for ( i=0, ien=buttons.length ; i&lt;ien ; i++ ) {
						button = buttons[i];
	
						if ( $.isArray( button ) ) {
							var inner = $( &#x27;&lt;&#x27;+(button.DT_el || &#x27;div&#x27;)+&#x27;/&gt;&#x27; )
								.appendTo( container );
							attach( inner, button );
						}
						else {
							btnDisplay = null;
							btnClass = &#x27;&#x27;;
	
							switch ( button ) {
								case &#x27;ellipsis&#x27;:
									container.append(&#x27;&lt;span class=&quot;ellipsis&quot;&gt;&amp;#x2026;&lt;/span&gt;&#x27;);
									break;
	
								case &#x27;first&#x27;:
									btnDisplay = lang.sFirst;
									btnClass = button + (page &gt; 0 ?
										&#x27;&#x27; : &#x27; &#x27;+classes.sPageButtonDisabled);
									break;
	
								case &#x27;previous&#x27;:
									btnDisplay = lang.sPrevious;
									btnClass = button + (page &gt; 0 ?
										&#x27;&#x27; : &#x27; &#x27;+classes.sPageButtonDisabled);
									break;
	
								case &#x27;next&#x27;:
									btnDisplay = lang.sNext;
									btnClass = button + (page &lt; pages-1 ?
										&#x27;&#x27; : &#x27; &#x27;+classes.sPageButtonDisabled);
									break;
	
								case &#x27;last&#x27;:
									btnDisplay = lang.sLast;
									btnClass = button + (page &lt; pages-1 ?
										&#x27;&#x27; : &#x27; &#x27;+classes.sPageButtonDisabled);
									break;
	
								default:
									btnDisplay = button + 1;
									btnClass = page === button ?
										classes.sPageButtonActive : &#x27;&#x27;;
									break;
							}
	
							if ( btnDisplay !== null ) {
								node = $(&#x27;&lt;a&gt;&#x27;, {
										&#x27;class&#x27;: classes.sPageButton+&#x27; &#x27;+btnClass,
										&#x27;aria-controls&#x27;: settings.sTableId,
										&#x27;aria-label&#x27;: aria[ button ],
										&#x27;data-dt-idx&#x27;: counter,
										&#x27;tabindex&#x27;: settings.iTabIndex,
										&#x27;id&#x27;: idx === 0 &amp;&amp; typeof button === &#x27;string&#x27; ?
											settings.sTableId +&#x27;_&#x27;+ button :
											null
									} )
									.html( btnDisplay )
									.appendTo( container );
	
								_fnBindAction(
									node, {action: button}, clickHandler
								);
	
								counter++;
							}
						}
					}
				};
	
				// IE9 throws an &#x27;unknown error&#x27; if document.activeElement is used
				// inside an iframe or frame. Try / catch the error. Not good for
				// accessibility, but neither are frames.
				var activeEl;
	
				try {
					// Because this approach is destroying and recreating the paging
					// elements, focus is lost on the select button which is bad for
					// accessibility. So we want to restore focus once the draw has
					// completed
					activeEl = $(host).find(document.activeElement).data(&#x27;dt-idx&#x27;);
				}
				catch (e) {}
	
				attach( $(host).empty(), buttons );
	
				if ( activeEl !== undefined ) {
					$(host).find( &#x27;[data-dt-idx=&#x27;+activeEl+&#x27;]&#x27; ).focus();
				}
			}
		}
	} );
	
	
	
	// Built in type detection. See model.ext.aTypes for information about
	// what is required from this methods.
	$.extend( DataTable.ext.type.detect, [
		// Plain numbers - first since V8 detects some plain numbers as dates
		// e.g. Date.parse(&#x27;55&#x27;) (but not all, e.g. Date.parse(&#x27;22&#x27;)...).
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal ) ? &#x27;num&#x27;+decimal : null;
		},
	
		// Dates (only those recognised by the browser&#x27;s Date.parse)
		function ( d, settings )
		{
			// V8 tries _very_ hard to make a string passed into &#x60;Date.parse()&#x60;
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d &amp;&amp; !(d instanceof Date) &amp;&amp; ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null &amp;&amp; !isNaN(parsed)) || _empty(d) ? &#x27;date&#x27; : null;
		},
	
		// Formatted numbers
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true ) ? &#x27;num-fmt&#x27;+decimal : null;
		},
	
		// HTML numeric
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal ) ? &#x27;html-num&#x27;+decimal : null;
		},
	
		// HTML numeric, formatted
		function ( d, settings )
		{
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true ) ? &#x27;html-num-fmt&#x27;+decimal : null;
		},
	
		// HTML (this is strict checking - there must be html)
		function ( d, settings )
		{
			return _empty( d ) || (typeof d === &#x27;string&#x27; &amp;&amp; d.indexOf(&#x27;&lt;&#x27;) !== -1) ?
				&#x27;html&#x27; : null;
		}
	] );
	
	
	
	// Filter formatting functions. See model.ext.ofnSearch for information about
	// what is required from these methods.
	// 
	// Note that additional search methods are added for the html numbers and
	// html formatted numbers by &#x60;_addNumericSort()&#x60; when we know what the decimal
	// place is
	
	
	$.extend( DataTable.ext.type.search, {
		html: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === &#x27;string&#x27; ?
					data
						.replace( _re_new_lines, &quot; &quot; )
						.replace( _re_html, &quot;&quot; ) :
					&#x27;&#x27;;
		},
	
		string: function ( data ) {
			return _empty(data) ?
				data :
				typeof data === &#x27;string&#x27; ?
					data.replace( _re_new_lines, &quot; &quot; ) :
					data;
		}
	} );
	
	
	
	var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
		if ( d !== 0 &amp;&amp; (!d || d === &#x27;-&#x27;) ) {
			return -Infinity;
		}
	
		// If a decimal place other than &#x60;.&#x60; is used, it needs to be given to the
		// function so we can detect it and replace with a &#x60;.&#x60; which is the only
		// decimal place Javascript recognises - it is not locale aware.
		if ( decimalPlace ) {
			d = _numToDecimal( d, decimalPlace );
		}
	
		if ( d.replace ) {
			if ( re1 ) {
				d = d.replace( re1, &#x27;&#x27; );
			}
	
			if ( re2 ) {
				d = d.replace( re2, &#x27;&#x27; );
			}
		}
	
		return d * 1;
	};
	
	
	// Add the numeric &#x27;deformatting&#x27; functions for sorting and search. This is done
	// in a function to provide an easy ability for the language options to add
	// additional methods if a non-period decimal place is used.
	function _addNumericSort ( decimalPlace ) {
		$.each(
			{
				// Plain numbers
				&quot;num&quot;: function ( d ) {
					return __numericReplace( d, decimalPlace );
				},
	
				// Formatted numbers
				&quot;num-fmt&quot;: function ( d ) {
					return __numericReplace( d, decimalPlace, _re_formatted_numeric );
				},
	
				// HTML numeric
				&quot;html-num&quot;: function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html );
				},
	
				// HTML numeric, formatted
				&quot;html-num-fmt&quot;: function ( d ) {
					return __numericReplace( d, decimalPlace, _re_html, _re_formatted_numeric );
				}
			},
			function ( key, fn ) {
				// Add the ordering method
				_ext.type.order[ key+decimalPlace+&#x27;-pre&#x27; ] = fn;
	
				// For HTML types add a search formatter that will strip the HTML
				if ( key.match(/^html\-/) ) {
					_ext.type.search[ key+decimalPlace ] = _ext.type.search.html;
				}
			}
		);
	}
	
	
	// Default sort methods
	$.extend( _ext.type.order, {
		// Dates
		&quot;date-pre&quot;: function ( d ) {
			return Date.parse( d ) || -Infinity;
		},
	
		// html
		&quot;html-pre&quot;: function ( a ) {
			return _empty(a) ?
				&#x27;&#x27; :
				a.replace ?
					a.replace( /&lt;.*?&gt;/g, &quot;&quot; ).toLowerCase() :
					a+&#x27;&#x27;;
		},
	
		// string
		&quot;string-pre&quot;: function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) ?
				&#x27;&#x27; :
				typeof a === &#x27;string&#x27; ?
					a.toLowerCase() :
					! a.toString ?
						&#x27;&#x27; :
						a.toString();
		},
	
		// string-asc and -desc are retained only for compatibility with the old
		// sort methods
		&quot;string-asc&quot;: function ( x, y ) {
			return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
		},
	
		&quot;string-desc&quot;: function ( x, y ) {
			return ((x &lt; y) ? 1 : ((x &gt; y) ? -1 : 0));
		}
	} );
	
	
	// Numeric sorting types - order doesn&#x27;t matter here
	_addNumericSort( &#x27;&#x27; );
	
	
	$.extend( true, DataTable.ext.renderer, {
		header: {
			_: function ( settings, cell, column, classes ) {
				// No additional mark-up required
				// Attach a sort listener to update on sort - note that using the
				// &#x60;DT&#x60; namespace will allow the event to be removed automatically
				// on destroy, while the &#x60;dt&#x60; namespaced event is the one we are
				// listening for
				$(settings.nTable).on( &#x27;order.dt.DT&#x27;, function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) { // need to check this this is the host
						return;               // table, not a nested one
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass(
							column.sSortingClass +&#x27; &#x27;+
							classes.sSortAsc +&#x27; &#x27;+
							classes.sSortDesc
						)
						.addClass( columns[ colIdx ] == &#x27;asc&#x27; ?
							classes.sSortAsc : columns[ colIdx ] == &#x27;desc&#x27; ?
								classes.sSortDesc :
								column.sSortingClass
						);
				} );
			},
	
			jqueryui: function ( settings, cell, column, classes ) {
				$(&#x27;&lt;div/&gt;&#x27;)
					.addClass( classes.sSortJUIWrapper )
					.append( cell.contents() )
					.append( $(&#x27;&lt;span/&gt;&#x27;)
						.addClass( classes.sSortIcon+&#x27; &#x27;+column.sSortingClassJUI )
					)
					.appendTo( cell );
	
				// Attach a sort listener to update on sort
				$(settings.nTable).on( &#x27;order.dt.DT&#x27;, function ( e, ctx, sorting, columns ) {
					if ( settings !== ctx ) {
						return;
					}
	
					var colIdx = column.idx;
	
					cell
						.removeClass( classes.sSortAsc +&quot; &quot;+classes.sSortDesc )
						.addClass( columns[ colIdx ] == &#x27;asc&#x27; ?
							classes.sSortAsc : columns[ colIdx ] == &#x27;desc&#x27; ?
								classes.sSortDesc :
								column.sSortingClass
						);
	
					cell
						.find( &#x27;span.&#x27;+classes.sSortIcon )
						.removeClass(
							classes.sSortJUIAsc +&quot; &quot;+
							classes.sSortJUIDesc +&quot; &quot;+
							classes.sSortJUI +&quot; &quot;+
							classes.sSortJUIAscAllowed +&quot; &quot;+
							classes.sSortJUIDescAllowed
						)
						.addClass( columns[ colIdx ] == &#x27;asc&#x27; ?
							classes.sSortJUIAsc : columns[ colIdx ] == &#x27;desc&#x27; ?
								classes.sSortJUIDesc :
								column.sSortingClassJUI
						);
				} );
			}
		}
	} );
	
	/*
	 * Public helper functions. These aren&#x27;t used internally by DataTables, or
	 * called by any of the options passed into DataTables, but they can be used
	 * externally by developers working with DataTables. They are helper functions
	 * to make working with DataTables a little bit easier.
	 */
	
	var __htmlEscapeEntities = function ( d ) {
		return typeof d === &#x27;string&#x27; ?
			d.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;).replace(/&quot;/g, &#x27;&amp;quot;&#x27;) :
			d;
	};
	
	/**
	 * Helpers for &#x60;columns.render&#x60;.
	 *
	 * The options defined here can be used with the &#x60;columns.render&#x60; initialisation
	 * option to provide a display renderer. The following functions are defined:
	 *
	 * * &#x60;number&#x60; - Will format numeric data (defined by &#x60;columns.data&#x60;) for
	 *   display, retaining the original unformatted data for sorting and filtering.
	 *   It takes 5 parameters:
	 *   * &#x60;string&#x60; - Thousands grouping separator
	 *   * &#x60;string&#x60; - Decimal point indicator
	 *   * &#x60;integer&#x60; - Number of decimal points to show
	 *   * &#x60;string&#x60; (optional) - Prefix.
	 *   * &#x60;string&#x60; (optional) - Postfix (/suffix).
	 * * &#x60;text&#x60; - Escape HTML to help prevent XSS attacks. It has no optional
	 *   parameters.
	 *
	 * @example
	 *   // Column definition using the number renderer
	 *   {
	 *     data: &quot;salary&quot;,
	 *     render: $.fn.dataTable.render.number( &#x27;\&#x27;&#x27;, &#x27;.&#x27;, 0, &#x27;$&#x27; )
	 *   }
	 *
	 * @namespace
	 */
	DataTable.render = {
		number: function ( thousands, decimal, precision, prefix, postfix ) {
			return {
				display: function ( d ) {
					if ( typeof d !== &#x27;number&#x27; &amp;&amp; typeof d !== &#x27;string&#x27; ) {
						return d;
					}
	
					var negative = d &lt; 0 ? &#x27;-&#x27; : &#x27;&#x27;;
					var flo = parseFloat( d );
	
					// If NaN then there isn&#x27;t much formatting that we can do - just
					// return immediately, escaping any HTML (this was supposed to
					// be a number after all)
					if ( isNaN( flo ) ) {
						return __htmlEscapeEntities( d );
					}
	
					flo = flo.toFixed( precision );
					d = Math.abs( flo );
	
					var intPart = parseInt( d, 10 );
					var floatPart = precision ?
						decimal+(d - intPart).toFixed( precision ).substring( 2 ):
						&#x27;&#x27;;
	
					return negative + (prefix||&#x27;&#x27;) +
						intPart.toString().replace(
							/\B(?=(\d{3})+(?!\d))/g, thousands
						) +
						floatPart +
						(postfix||&#x27;&#x27;);
				}
			};
		},
	
		text: function () {
			return {
				display: __htmlEscapeEntities
			};
		}
	};
	
	
	/*
	 * This is really a good bit rubbish this method of exposing the internal methods
	 * publicly... - To be fixed in 2.0 using methods on the prototype
	 */
	
	
	/**
	 * Create a wrapper function for exporting an internal functions to an external API.
	 *  @param {string} fn API function name
	 *  @returns {function} wrapped function
	 *  @memberof DataTable#internal
	 */
	function _fnExternApiFunc (fn)
	{
		return function() {
			var args = [_fnSettingsFromNode( this[DataTable.ext.iApiIndex] )].concat(
				Array.prototype.slice.call(arguments)
			);
			return DataTable.ext.internal[fn].apply( this, args );
		};
	}
	
	
	/**
	 * Reference to internal functions for use by plug-in developers. Note that
	 * these methods are references to internal functions and are considered to be
	 * private. If you use these methods, be aware that they are liable to change
	 * between versions.
	 *  @namespace
	 */
	$.extend( DataTable.ext.internal, {
		_fnExternApiFunc: _fnExternApiFunc,
		_fnBuildAjax: _fnBuildAjax,
		_fnAjaxUpdate: _fnAjaxUpdate,
		_fnAjaxParameters: _fnAjaxParameters,
		_fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
		_fnAjaxDataSrc: _fnAjaxDataSrc,
		_fnAddColumn: _fnAddColumn,
		_fnColumnOptions: _fnColumnOptions,
		_fnAdjustColumnSizing: _fnAdjustColumnSizing,
		_fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
		_fnColumnIndexToVisible: _fnColumnIndexToVisible,
		_fnVisbleColumns: _fnVisbleColumns,
		_fnGetColumns: _fnGetColumns,
		_fnColumnTypes: _fnColumnTypes,
		_fnApplyColumnDefs: _fnApplyColumnDefs,
		_fnHungarianMap: _fnHungarianMap,
		_fnCamelToHungarian: _fnCamelToHungarian,
		_fnLanguageCompat: _fnLanguageCompat,
		_fnBrowserDetect: _fnBrowserDetect,
		_fnAddData: _fnAddData,
		_fnAddTr: _fnAddTr,
		_fnNodeToDataIndex: _fnNodeToDataIndex,
		_fnNodeToColumnIndex: _fnNodeToColumnIndex,
		_fnGetCellData: _fnGetCellData,
		_fnSetCellData: _fnSetCellData,
		_fnSplitObjNotation: _fnSplitObjNotation,
		_fnGetObjectDataFn: _fnGetObjectDataFn,
		_fnSetObjectDataFn: _fnSetObjectDataFn,
		_fnGetDataMaster: _fnGetDataMaster,
		_fnClearTable: _fnClearTable,
		_fnDeleteIndex: _fnDeleteIndex,
		_fnInvalidate: _fnInvalidate,
		_fnGetRowElements: _fnGetRowElements,
		_fnCreateTr: _fnCreateTr,
		_fnBuildHead: _fnBuildHead,
		_fnDrawHead: _fnDrawHead,
		_fnDraw: _fnDraw,
		_fnReDraw: _fnReDraw,
		_fnAddOptionsHtml: _fnAddOptionsHtml,
		_fnDetectHeader: _fnDetectHeader,
		_fnGetUniqueThs: _fnGetUniqueThs,
		_fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
		_fnFilterComplete: _fnFilterComplete,
		_fnFilterCustom: _fnFilterCustom,
		_fnFilterColumn: _fnFilterColumn,
		_fnFilter: _fnFilter,
		_fnFilterCreateSearch: _fnFilterCreateSearch,
		_fnEscapeRegex: _fnEscapeRegex,
		_fnFilterData: _fnFilterData,
		_fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
		_fnUpdateInfo: _fnUpdateInfo,
		_fnInfoMacros: _fnInfoMacros,
		_fnInitialise: _fnInitialise,
		_fnInitComplete: _fnInitComplete,
		_fnLengthChange: _fnLengthChange,
		_fnFeatureHtmlLength: _fnFeatureHtmlLength,
		_fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
		_fnPageChange: _fnPageChange,
		_fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
		_fnProcessingDisplay: _fnProcessingDisplay,
		_fnFeatureHtmlTable: _fnFeatureHtmlTable,
		_fnScrollDraw: _fnScrollDraw,
		_fnApplyToChildren: _fnApplyToChildren,
		_fnCalculateColumnWidths: _fnCalculateColumnWidths,
		_fnThrottle: _fnThrottle,
		_fnConvertToWidth: _fnConvertToWidth,
		_fnGetWidestNode: _fnGetWidestNode,
		_fnGetMaxLenString: _fnGetMaxLenString,
		_fnStringToCss: _fnStringToCss,
		_fnSortFlatten: _fnSortFlatten,
		_fnSort: _fnSort,
		_fnSortAria: _fnSortAria,
		_fnSortListener: _fnSortListener,
		_fnSortAttachListener: _fnSortAttachListener,
		_fnSortingClasses: _fnSortingClasses,
		_fnSortData: _fnSortData,
		_fnSaveState: _fnSaveState,
		_fnLoadState: _fnLoadState,
		_fnSettingsFromNode: _fnSettingsFromNode,
		_fnLog: _fnLog,
		_fnMap: _fnMap,
		_fnBindAction: _fnBindAction,
		_fnCallbackReg: _fnCallbackReg,
		_fnCallbackFire: _fnCallbackFire,
		_fnLengthOverflow: _fnLengthOverflow,
		_fnRenderer: _fnRenderer,
		_fnDataSource: _fnDataSource,
		_fnRowAttributes: _fnRowAttributes,
		_fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant
		                                // in 1.10, so this dead-end function is
		                                // added to prevent errors
	} );
	

	// jQuery access
	$.fn.dataTable = DataTable;

	// Provide access to the host jQuery object (circular reference)
	DataTable.$ = $;

	// Legacy aliases
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;

	// With a capital &#x60;D&#x60; we return a DataTables API instance rather than a
	// jQuery object
	$.fn.DataTable = function ( opts ) {
		return $(this).dataTable( opts ).api();
	};

	// All properties that are available to $.fn.dataTable should also be
	// available on $.fn.DataTable
	$.each( DataTable, function ( prop, val ) {
		$.fn.DataTable[ prop ] = val;
	} );


	// Information about events fired by DataTables - for documentation.
	/**
	 * Draw event, fired whenever the table is redrawn on the page, at the same
	 * point as fnDrawCallback. This may be useful for binding events or
	 * performing calculations when the table is altered at all.
	 *  @name DataTable#draw.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Search event, fired when the searching applied to the table (using the
	 * built-in global search, or column filters) is altered.
	 *  @name DataTable#search.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Order event, fired when the ordering applied to the table is altered.
	 *  @name DataTable#order.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * DataTables initialisation complete event, fired when the table is fully
	 * drawn, including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used&lt;/li&gt;&lt;/ol&gt;
	 */

	/**
	 * State save event, fired when the table has changed state a new state save
	 * is required. This event allows modification of the state saving object
	 * prior to actually doing the save, including addition or other state
	 * properties (for plug-ins) or modification of a DataTables core property.
	 *  @name DataTable#stateSaveParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */

	/**
	 * State load event, fired when the table is loading state from the stored
	 * data, but prior to the settings object being modified by the saved state
	 * - allowing modification of the saved state is required or loading of
	 * state for a plug-in.
	 *  @name DataTable#stateLoadParams.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * State loaded event, fired when state has been loaded from stored data and
	 * the settings object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * Processing event, fired when DataTables is doing some kind of processing
	 * (be it, order, searcg or anything else). It can be used to indicate to
	 * the end user that there is something happening, or that something has
	 * finished.
	 *  @name DataTable#processing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */

	/**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	 * request to made to the server for new data. This event is called before
	 * DataTables processed the returned data, so it can also be used to pre-
	 * process the data returned from the server, if needed.
	 *
	 * Note that this trigger is called in &#x60;fnServerData&#x60;, if you override
	 * &#x60;fnServerData&#x60; and which to use this event, you need to trigger it in you
	 * success function.
	 *  @name DataTable#xhr.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {object} json JSON returned from the server
	 *
	 *  @example
	 *     // Use a custom property returned from the server in another DOM element
	 *     $(&#x27;#table&#x27;).dataTable().on(&#x27;xhr.dt&#x27;, function (e, settings, json) {
	 *       $(&#x27;#status&#x27;).html( json.status );
	 *     } );
	 *
	 *  @example
	 *     // Pre-process the data returned from the server
	 *     $(&#x27;#table&#x27;).dataTable().on(&#x27;xhr.dt&#x27;, function (e, settings, json) {
	 *       for ( var i=0, ien=json.aaData.length ; i&lt;ien ; i++ ) {
	 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	 *       }
	 *       // Note no return - manipulate the data directly in the JSON object.
	 *     } );
	 */

	/**
	 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	 * or passing the bDestroy:true parameter in the initialisation object. This
	 * can be used to remove bound events, added DOM nodes, etc.
	 *  @name DataTable#destroy.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page length change event, fired when number of records to show on each
	 * page (the length) is changed.
	 *  @name DataTable#length.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {integer} len New length
	 */

	/**
	 * Column sizing has changed.
	 *  @name DataTable#column-sizing.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Column visibility has changed.
	 *  @name DataTable#column-visibility.dt
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 *  @param {int} column Column index
	 *  @param {bool} vis &#x60;false&#x60; if column now hidden, or &#x60;true&#x60; if visible
	 */

	return $.fn.dataTable;
}));



    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
